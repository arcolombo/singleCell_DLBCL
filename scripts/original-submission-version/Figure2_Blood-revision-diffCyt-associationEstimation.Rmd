---
title: "Single-cell spatial analysis of tumor immune architecture in diffuse large B cell lymphoma"
author: "Anthony Colombo+,Monirath Hav+, Erik Gerdtsson, Mohan Singh, Alexander Xu, Denaly Chen, Jane Houldsworth, Rita Shaknovich, Tomohiro Aoki, Lauren Chong, Katsuyoshi Takata, Elizabeth Chavez, Christian Steidl, James Hicks, Peter Kuhn, Imran Siddiqi, Akil Merchant*"
date: "`r Sys.Date()`"
output: html_document
fig_width: 15
fig_height: 15 
---


# {.tabset}  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setup {.tabset}

### Helper Functions
```{r helperFunction, eval=TRUE}

 zScorePatientExpression<-function(full.dn4=NULL,markers=NULL,ROIID.column=NULL){
  X3<-full.dn4[,c(markers,ROIID.column)]%>%group_by(ROIID)%>%summarise_all(funs(sd))%>%data.frame
  X2<-full.dn4[,c(markers,ROIID.column)]%>%group_by(ROIID)%>%summarise_all(funs(mean))%>%data.frame
   ###
   z<-full.dn4
  for(cl in unique(full.dn4$ROIID)){
   for(mark in colnames(X2)[-1]){
  z[which(z$ROIID==cl),which(colnames(z)==mark)]<- ( z[which(z$ROIID==cl),which(colnames(z)==mark)]-X2[which(X2$ROIID==cl),which(colnames(X2)==mark)])/(X3[which(X3$ROIID==cl),which(colnames(X3)==mark)])
   }
 }
 return(z)
 }


 makeJoyPlot<-function(z,marker=NULL){
   ltlist<-list()
     for(roi in unique(z$ROIID)){
      lt = data.frame(density(z[which(z$ROIID==roi),marker])[c("x","y")])
    ltlist[[(length(ltlist)+1)]]<-lt
     }
    marker1= rowAnnotation(Z= anno_joyplot(ltlist, width = unit(4, "cm"), 
    gp = gpar(fill = color_clusters),
	 transparency = 0.35)) 
  marker1@anno_list[[1]]@name <-gsub("Cell_","",marker)
  names(marker1@anno_list)<-gsub("Cell_","",marker)
    return(marker1)
   }


 ## this function performs Chi-square on the direct standardized counts per case
## direct standardization, standardizes the number of cells per case.
## direct standardization takes the given sub-community relative proportion, and then multiplies by the average number of cells across all cases (19,919). Each sub-community cluster has a different relative abundance.  By multiplying the cluster proportion by the standardized case cell average, it returns the expected number of cells in a sub-cluster assuming that all cases had the same number of cells.  It balances the expectation if all cases captured the same number of cells. so it scales the relative case proportions under the expectation that all cases had the same average cells. 

## The parameter 'conditionOnPrimary' can compare enrichment across COO conditioned on a primary component ###(TRUE), or across all components (FALSE).  default is to leave FALSE, more conservative.
 
chiHelperMeanScale<-function(pheno=NULL,full.dn4=NULL,phenotypeColumn="unsup.subcommunity",conditionOnPrimary=FALSE){
 ### the features are average to scale the data.
	##only works for HANS COO
	##phenotype column is the column of phenoytpe levels.
    message(pheno)
    primary<-sapply(strsplit(pheno,"_"),function(x) x[1])
    ta<-as.data.frame.matrix(table(full.dn4$case,full.dn4[,phenotypeColumn]))
    ta<-ta/rowSums(ta)
    ## direct standardization
    ta<-round(mean(table(full.dn4$case))*ta)
    ta$COO<-full.dn4$COO[match(rownames(ta),full.dn4$case)]
    ta2<-ta[,c(pheno,"COO")]
    x11<-round(mean(ta2[which(ta2$COO=="GCB"),1]))+1
    x12<-round(mean(ta2[which(ta2$COO!="GCB"),1]))+1
	##conditioned on the same phenotype family.
  if(conditionOnPrimary==TRUE){
    ta3<-ta[,grepl(primary,colnames(ta))]
  }else{
      ta3<-ta[,which(colnames(ta)!=pheno)]
  }
    ta3<-ta3[,which(colnames(ta3)!=pheno)]
    ta3$COO<-ta2$COO[match(rownames(ta3),rownames(ta2))]
   ta3<-ta3%>%group_by(COO)%>%summarise_all(funs(mean))%>%data.frame()
    x21<-round(mean(as.numeric(ta3[which(ta3$COO=="GCB"),-1])))+1
    x22<-round(mean(as.numeric(ta3[which(ta3$COO=="NGCB"),-1])))+1
    mat<-matrix(c(x11,x21,x12,x22),nrow=2,ncol=2)
	rownames(mat)<-c(paste0(pheno,"+"),paste0(pheno,"-"))
	colnames(mat)<-c("GCB","NGCB")
 ### need OR with confidence intervals
     require(epitools)
     dd<-oddsratio(mat,rev="both")
	return(dd)
}

geeGLMHANS<-function(pheno=NULL,cluster.counts=NULL,COO="HANS.binary",conditionOnPrimary=FALSE){
 ### the features are percentages.
	##only works for HANS COO binary cluster feature must be made
	##phenotype column is the column of phenoytpe levels.
    message(pheno)
    primary<-sapply(strsplit(pheno,"_"),function(x) x[1])

 library(gee)
 ### need OR with confidence intervals
    form<-formula(paste0(COO,"~",pheno,"+ipi"))
     dd<- geeglm(form, id = Case_Number, data = cluster.counts,family = binomial(link = "logit"), corstr = "exchangeable", scale.fix = TRUE)
     dd<-coef(summary(dd))
	return(dd)
}







chiHelperMeanScaleLabeled<-function(pheno=NULL,full.dn4=NULL,phenotypeColumn="unsup.subcommunity"){
 ### the features are average to scale the data.
	##only works for HANS COO
	##phenotype column is the column of phenoytpe levels.
    message(pheno)
    primary<-pheno
    ta<-as.data.frame.matrix(table(full.dn4$case,full.dn4[,phenotypeColumn]))
    ta<-ta/rowSums(ta)
    ## direct standardization
    ta<-round(mean(table(full.dn4$case))*ta)
    ta$COO<-full.dn4$COO[match(rownames(ta),full.dn4$case)]
    ta2<-ta[,c(pheno,"COO")]
    x11<-round(mean(ta2[which(ta2$COO=="GCB"),1]))+1
    x12<-round(mean(ta2[which(ta2$COO!="GCB"),1]))+1
   
    ta3<-ta[,which(colnames(ta)!=pheno)]
    ta3$COO<-ta2$COO[match(rownames(ta3),rownames(ta2))]
   ta3<-ta3%>%group_by(COO)%>%summarise_all(funs(mean))%>%data.frame()
    x21<-round(mean(as.numeric(ta3[which(ta3$COO=="GCB"),-1])))+1
    x22<-round(mean(as.numeric(ta3[which(ta3$COO=="NGCB"),-1])))+1
    mat<-matrix(c(x11,x21,x12,x22),nrow=2,ncol=2)
	rownames(mat)<-c(paste0(pheno,"+"),paste0(pheno,"-"))
	colnames(mat)<-c("GCB","NGCB")
 ### need OR with confidence intervals
     require(epitools)
     dd<-oddsratio(mat,rev="both")
	return(dd)
  }

 ### logistic regression using direct standardization.
 ##logistic regression standard.
 logisticRegressionClinicalOdds<-function(pheno=NULL,full.dn4=NULL,phenotypeColumn=NULL,mycFeature=NULL,groupA=1){
    message(pheno)
   #this function returns the OR (exp the coefficients and CI in the model.)
    primary<-sapply(strsplit(pheno,"_"),function(x) x[1])
    ta<-as.data.frame.matrix(table(full.dn4$case,full.dn4[,phenotypeColumn]))
    ta<-ta/rowSums(ta)
    ## direct standardization
    ta<-round(mean(table(full.dn4$case))*ta)
	ta<-as.data.frame(scale(ta))
    ta$feature<-full.dn4[match(rownames(ta),full.dn4$case),mycFeature]
    ta$feature<-ifelse(ta$feature==groupA,1,0)
  colnames(ta)[which(colnames(ta)=="feature")]<-mycFeature
    myForm<-formula(paste0(mycFeature,"~",pheno))
	fit<-glm(myForm,ta,family='binomial')
	ci<-exp(confint(fit))
  dd<-exp(coef(glm(myForm,ta,family='binomial')))
   dd<-cbind(ci,dd)%>%data.frame
  colnames(dd)<-c("lower.2.5%","upper.97.5%",paste0("OddsRatio.",groupA))
  pv<-summary(fit)%>%coef%>%data.frame
  dd$p<-pv[,4]
	return(dd[pheno,])
  } 

  logisticRegressionClinicalLogOdds<-function(pheno=NULL,full.dn4=NULL,phenotypeColumn=NULL,mycFeature=NULL,groupA=1){
    message(pheno)
   #this function returns the OR (exp the coefficients and CI in the model.)
    primary<-sapply(strsplit(pheno,"_"),function(x) x[1])
    ta<-as.data.frame.matrix(table(full.dn4$case,full.dn4[,phenotypeColumn]))
    ta<-ta/rowSums(ta)
    ## direct standardization
    ta<-round(mean(table(full.dn4$case))*ta)
	ta<-as.data.frame(scale(ta))
    ta$feature<-full.dn4[match(rownames(ta),full.dn4$case),mycFeature]
    ta$feature<-ifelse(ta$feature==groupA,1,0)
  colnames(ta)[which(colnames(ta)=="feature")]<-mycFeature
    myForm<-formula(paste0(mycFeature,"~",pheno))
	fit<-glm(myForm,ta,family='binomial')
	ci<-(confint(fit))
  dd<-(coef(glm(myForm,ta,family='binomial')))
   dd<-cbind(ci,dd)%>%data.frame
  colnames(dd)<-c("lower.2.5%","upper.97.5%",paste0("LogOddsRatio.",groupA))
  pv<-summary(fit)%>%coef%>%data.frame
  dd$p<-pv[,4]
	return(dd[pheno,])
  } 
  
  ## REVISION 10-15 adding a chisquare test for EBER in general way.
  generalChiHelperMeanScale<-function(pheno=NULL,full.dn4=NULL,phenotypeColumn="unsup.subcommunity",conditionOnPrimary=FALSE,responseColumn='eber'){
 ### the features are average to scale the data.
	##only works for HANS COO
	##phenotype column is the column of phenoytpe levels.
    ## the responseColumn is the response binary variable y~ phenotypeColumn_i, where y is binary
    message(pheno)
    primary<-sapply(strsplit(pheno,"_"),function(x) x[1])
    ta<-as.data.frame.matrix(table(full.dn4$case,full.dn4[,phenotypeColumn]))
    ta<-ta/rowSums(ta)
    ## direct standardization
    ta<-round(mean(table(full.dn4$case))*ta)
    ta$COO<-full.dn4[match(rownames(ta),full.dn4$case),responseColumn]
    ta2<-ta[,c(pheno,"COO")]
    x11<-round(mean(ta2[which(ta2$COO==1),1]))+1
    x12<-round(mean(ta2[which(ta2$COO!=1),1]))+1
	##conditioned on the same phenotype family.
  if(conditionOnPrimary==TRUE){
    ta3<-ta[,grepl(primary,colnames(ta))]
  }else{
      ta3<-ta[,which(colnames(ta)!=pheno)]
  }
    ta3<-ta3[,which(colnames(ta3)!=pheno)]
    ta3$COO<-ta2$COO[match(rownames(ta3),rownames(ta2))]
   ta3<-ta3%>%group_by(COO)%>%summarise_all(funs(mean))%>%data.frame()
    x21<-round(mean(as.numeric(ta3[which(ta3$COO==1),-1])))+1
    x22<-round(mean(as.numeric(ta3[which(ta3$COO==0),-1])))+1
    mat<-matrix(c(x11,x21,x12,x22),nrow=2,ncol=2)
	rownames(mat)<-c(paste0(pheno,"+"),paste0(pheno,"-"))
	colnames(mat)<-c("1","0")
 ### need OR with confidence intervals
     require(epitools)
     dd<-oddsratio(mat,rev="both")
	return(dd)
  }

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", 
  "#B17BA6", "#FF7F00", "#FDB462", "#E7298A", "#E78AC3", 
  "#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", 
  "#E6AB02", "#7570B3", "#BEAED4", "#666666", "#999999", 
  "#aa8282", "#d4b7b7", "#8600bf", "#ba5ce3", "#808000", 
  "#aeae5c", "#1e90ff", "#00bfff", "#56ff0d", "#ffff00")

 getPhenoColors<-function(full.dn4){
 require(circlize)
  tsn<-full.dn4[,c("Cell_CD20",
	"Cell_CD3",
	"Cell_CD4",
	"Cell_CD31",
	"Cell_CD4",
	"Cell_CD68",
	"Cell_CD8",
	"Cell_FOXP3",
	"Cell_BCL2",
	"uniqueLabel","response","ROIID",
	"unsup.subcommunity")]
  ##balanced response representation.
   table(tsn$response)
  tsn$primary.phenotype<-tsn$unsup.subcommunity
 
   cd8s<-colorRampPalette(c("darkseagreen","green"),20)
  cd4s<-colorRampPalette(c("lightsteelblue1","blue"),20)
  macs<-colorRampPalette(c("magenta","maroon4"),20)
   tregs<-colorRampPalette(c("plum2","purple"),20)
   tumrs<-colorRampPalette(c("grey24","grey64"),20)
   endos<-colorRampPalette(c("rosybrown1","red"),20)

   phenoColors<-c(cd4s(14)[seq(1,14,2)],
	cd8s(14)[seq(1,14,2)],macs(12)[seq(1,12,2)],tregs(12)[seq(1,12,2)],tumrs(11),endos(6))

 names(phenoColors)<-levels(factor(tsn$primary.phenotype))
   ##manual color change code.
   phenoColors["Macrophage_2"]<-"darkblue"
   phenoColors["Macrophage_5"]<-"yellow"
   phenoColors["CD8_7"]<-"black"

   return(phenoColors)
 }

getSpatialPhenoColors<-function(full.dn4=NULL){
	##this uses the color coding from the Tumor spatial classification
  phenoColors<-phenoColors<-getPhenoColors(full.dn4)

   cols<-data.frame(phenotype= unique(full.dn4$tumor.5nn.class.unsup),
	colors="black",
	stringsAsFactors=FALSE)
   for(i in 1:nrow(cols)){
   id<-which(names(phenoColors)[i]==cols$phenotype)
   cols$colors[id]<-phenoColors[i]
  }
        
 	cols[which(cols$phenotype=="Tumor_b"),"colors"]<-"lightslategrey"
     cols[which(cols$phenotype=="Tumor_g"),"colors"]<-"gray89"
       cols[which(cols$phenotype=="Tumor_c"),"colors"]<-"black"
 	 cols[which(cols$phenotype=="Tumor_f"),"colors"]<-"khaki1"
   cols[which(cols$phenotype=="Tumor_i"),"colors"]<-"tan3"
 ###REF
	       cols[which(cols$phenotype=="Tumor_e"),"colors"]<-"orange"
 	       cols[which(cols$phenotype=="Tumor_a"),"colors"]<-"cyan"
  	       cols[which(cols$phenotype=="Tumor_h"),"colors"]<-"lightpink"

    	cols[which(cols$phenotype=="Tumor_d"),"colors"]<-color_clusters[6]


   return(cols)
 }

mutationClinicalSheetAssembly<-function(mutationsToGather=c("TP53","BCL2","BCL6","CD79B","SGK1","MYD88","MYC","NOTCH1","NOTCH2","EZH2","CREBBP"),full.dn4=NULL){
 ## the mutation of MYD88 is specifically controlled for L265P region.
 ## the column header for the non-syn SNP annotation for MYD88 is AA.Mutation.Cosmic_v70

   mutations<-read.csv("~/IMC-Ranalysis/DLBCL/mutational-genomic-table/TMA CGI genomic data.csv",header=T)
   colnames(mutations)<-gsub("USC076","USC76",colnames(mutations))
  #  clinic<-read.csv("~/Documents/imageAnalysis/DLBCL/simpleModel-1-14/DLBCL-mutation-analysis/patient.clinical.table.csv",header=T)
    # library(XLConnect) 
  # wb<-XLConnect::loadWorkbook("~/Documents/imageAnalysis/DLBCL/simpleModel-1-14/DLBCL-mutation-analysis/clinicalDataRevisedFinal_final.xlsx")
  # clinic <- readWorksheet(wb, 1);  
   clinic<-read.csv("~/IMC-Ranalysis/DLBCL/simpleModel-1-14/DLBCL-mutation-analysis/clinicalDataRevisedFinal_finalSheet.csv",header=T)

  clinic$MB<-gsub(" ","",clinic$End..MB)
 mut.tag<-colnames(mutations)[9:67]
  mutt<-data.frame(mut.tag,id=sapply(strsplit(gsub("\\.","_",mut.tag),"_"),function(x) x[1])
) 

  mutt$id[which(mutt[,"id"]=="USC076")]<-"USC76"
  tag<- as.character(clinic[,"MB"])
  tag<-gsub(" ","",tag)
  tag<-data.frame(tag=tag,stringsAsFactors=FALSE)
  inters<-intersect(tag[,1],mutt$id)
   key<-data.frame(MB=tag[match(inters,tag[,1]),],stringsAsFactors=FALSE)
  key$id<-mutt[match(inters,mutt[,2]),1]
 ##fix a column header
 ## USC76 has a funcy header.
 ##
  casemuts<-mutations[,match(key$id,colnames(mutations))]
  casemuts$gene.name<-mutations[,"gene_name..Homo_sapiens_ensembl_v74_mRNA."]
  casemuts$chromosome<-as.character(mutations$Chromosome)
 casemuts$aminoAcid<-as.character(mutations$AA.Mutation.Cosmic_v70)
 casemuts$aminoAcid<-gsub( "\"","",mutations$AA.Mutation.Cosmic_v70)
  casemuts$gene.name<-as.character(casemuts$gene.name)
 ##for MYD88, the gene name will have the aminoAcid appended.
  casemuts$gene.name[which(casemuts$gene.name=="MYD88" & casemuts$aminoAcid=="L265P, L265P")]<-"MYD88.L265P"
  casemuts<-casemuts[which(casemuts$aminoAcid!="S219C, S219C, S219C, S219C" & casemuts$aminoAcid!="M232T, M232T" & casemuts$aminoAcid!="0.999, 0.999" & casemuts$aminoAcid!="S251N, S243N, S251N, S243N"),]
  casemuts[which(casemuts$gene.name=="MYD88" & casemuts$chromosome==""),"gene.name"]<-"MYD88.L265P"
 casemuts[which(casemuts$gene.name=="MYD88.L265P" & casemuts$chromosome==""),1:20]<-ifelse(casemuts[which(casemuts$gene.name=="MYD88.L265P" & casemuts$chromosome!=""),1:20]!=0,1,0)
  casem<- casemuts[which(casemuts$chromosome==""),]
 mutationsToGather[which(mutationsToGather=="MYD88")]<-"MYD88.L265P"
  dat<-casem[casem$gene.name%in%mutationsToGather,]
   ### 
   for(i in mutationsToGather){
  key[,i]<-0
 key[match(colnames(dat)[which(dat[dat$gene.name==i,]==1)],key$id),i]<-1
   }
  #write.csv(key,file="~/Documents/imageAnalysis/DLBCL/simpleModel-1-14/DLBCL-mutation-analysis/Mutational.CNV.categorical.table.csv")
write.csv(key,file="~/IMC-Ranalysis/DLBCL/simpleModel-1-14/DLBCL-mutation-analysis/Mutational.CNV.categorical.table.csv")

  ## append to the clinical sheet
  clinic2<-clinic[,!colnames(clinic)%in%mutationsToGather]
 clinic2<-left_join(clinic2,key[,c("MB",mutationsToGather)],by="MB")
  for(i in mutationsToGather){
  clinic2[which(is.na(clinic2[,i])), i]<-0
  }
 ##add the factor to control for replicates
  replicate<-model.matrix(~0+clinic2$MB)
  replicate<-replicate[,which(colSums(replicate)>1)]  
 colnames(replicate)<-substring(colnames(replicate),11)
  clinic2<-data.frame(clinic2,replicate)
 clinic2$WES.avail<-FALSE
  clinic2$WES.avail[match(key$MB,clinic2$MB)]<-TRUE
 clinic2$Case_ID<-paste0("Case_",clinic2$X)
  return(clinic2)

}


 chiHelperStatus<-function(pheno=NULL,full.dn4=NULL,phenotypeColumn=NULL,mycFeature="MYC.Rearrange",groupA=1){
 ## sums the phenotype totals per patient across a clinical feature
  ## we do not use averages, this is penalized for missing phenotypes.
  ## generalized for other clinical factors.
  ## Patient level data
###phenotype column is the pheno cluster column
 ### mycFetaure is patient clinical var
 ## groupA is the level of the mycFeature for positive.
	##use the means to scale the data.
    message(pheno)
    primary<-sapply(strsplit(pheno,"_"),function(x) x[1])
    ta<-as.data.frame.matrix(table(full.dn4$case,full.dn4[,phenotypeColumn]))
    ta<-ta/(rowSums(ta)+1)
    ## direct standardization
    ta<-round(mean(table(full.dn4$case))*ta)
    ta$MYC<-full.dn4[match(rownames(ta),full.dn4$case),mycFeature]
    ta2<-ta[,c(pheno,"MYC")]
    x11<-round(sum(ta2[which(ta2$MYC==groupA),1]))+100
    x12<-round(sum(ta2[which(ta2$MYC!=groupA),1]))+100
    ta3<-ta[,grepl(primary,colnames(ta))]
    ta3<-ta3[,which(colnames(ta3)!=pheno)]
    ta3$MYC<-ta2$MYC[match(rownames(ta3),rownames(ta2))]
   ta3<-ta3%>%group_by(MYC)%>%summarise_all(funs(sum))%>%data.frame()
    x21<-round(sum(as.numeric(ta3[which(ta3$MYC==groupA),-1])))+100
    x22<-round(sum(as.numeric(ta3[which(ta3$MYC!=groupA),-1])))+100
    mat<-matrix(c(x11,x21,x12,x22),nrow=2,ncol=2)
	rownames(mat)<-c(paste0(pheno,"+"),paste0(pheno,"-"))
	colnames(mat)<-c(paste0(mycFeature,"+"),paste0(mycFeature,"-"))
 ### need OR with confidence intervals
     require(epitools)
     dd<-oddsratio(mat,rev="both")
	return(dd)
  }



 ### individual mutations at the class level
 ## ignores 'Tumor_11' cluster that cluster was not studied in phenotype analysis.
  patientMutationOddsRatio<-function(mutation=NULL){
   ### odds ratio of mutations
	print(mutation)
 ta<-as.data.frame.matrix(table(full.dn4[which(full.dn4$WES.available==TRUE & full.dn4$dimCD20.filtered=='NO'),mutation],full.dn4$COO[which(full.dn4$WES.available==TRUE& full.dn4$dimCD20.filtered=='NO')]))+400
  dd<-epitools::oddsratio(as.matrix(ta))
   return(dd$measure[2,])  
  }


 zScorePatientExpression<-function(full.dn4=NULL,markers=NULL,ROIID.column=NULL){
  X3<-full.dn4[,c(markers,ROIID.column)]%>%group_by(ROIID)%>%summarise_all(funs(sd))%>%data.frame
  X2<-full.dn4[,c(markers,ROIID.column)]%>%group_by(ROIID)%>%summarise_all(funs(mean))%>%data.frame
   ###
   z<-full.dn4
  for(cl in unique(full.dn4$ROIID)){
   for(mark in colnames(X2)[-1]){
  z[which(z$ROIID==cl),which(colnames(z)==mark)]<- ( z[which(z$ROIID==cl),which(colnames(z)==mark)]-X2[which(X2$ROIID==cl),which(colnames(X2)==mark)])/(X3[which(X3$ROIID==cl),which(colnames(X3)==mark)])
   }
 }
 return(z)
 }


 empiricalFitMutationCaseLevel<-function(full.dn4=NULL,design=NULL,toDrop=NULL,phenotypeCommunity=NULL){
 ## fit the model at the case level, and not ROI level
   patient<-as.data.frame.matrix(table(full.dn4$case,full.dn4[,phenotypeCommunity]))
  ### patient/rowSums(patient) is the rate of phenotype_j per patient
 ##  direct standardization multiples all the rates by a constant cohort average across all patients and all phenotypes.  this models equal number of phenotypes per patient.
   ##modeled as a proportion 
  y<-100*patient/rowSums(patient)
 # y<-mean(table(full.dn4$ROIID))*y
  #mean(rowMeans(patient))
	y2<-as.data.frame(t(y))
   y2$annotation<-sapply(strsplit(rownames(y2),"_"),function(x) x[1])
   pat.pheno<-y2
    pat.pheno<-pat.pheno[,which(colnames(pat.pheno)!="annotation")]
    design<-design[match(colnames(pat.pheno),rownames(design)),]  
   stopifnot(all( colnames(pat.pheno)==rownames(design)))
    require(limma)
  if(!is.null(toDrop)==TRUE){
  pat.pheno<-pat.pheno[!rownames(pat.pheno)%in%toDrop,]
  }
  fit <- lmFit(pat.pheno,design)
 #  Moderated t-statistic
  fit <- eBayes(fit)
 print( topTable(fit,coef=2))
  return(fit)
 }
 
  empiricalFitMutationROIIDLevel<-function(full.dn4=NULL,design=NULL,toDrop=NULL,phenotypeCommunity=NULL){
 ## fit the model at the case level, and not ROI level
   patient<-as.data.frame.matrix(table(full.dn4$ROIID,full.dn4[,phenotypeCommunity]))
  ### patient/rowSums(patient) is the rate of phenotype_j per patient
 ##  direct standardization multiples all the rates by a constant cohort average across all patients and all phenotypes.  this models equal number of phenotypes per patient.
   ##modeled as a proportion 
  y<-100*patient/rowSums(patient)
 # y<-mean(table(full.dn4$ROIID))*y
  #mean(rowMeans(patient))
	y2<-as.data.frame(t(y))
   y2$annotation<-sapply(strsplit(rownames(y2),"_"),function(x) x[1])
   pat.pheno<-y2
    pat.pheno<-pat.pheno[,which(colnames(pat.pheno)!="annotation")]
    design<-design[match(colnames(pat.pheno),rownames(design)),]  
   stopifnot(all( colnames(pat.pheno)==rownames(design)))
    require(limma)
  if(!is.null(toDrop)==TRUE){
  pat.pheno<-pat.pheno[!rownames(pat.pheno)%in%toDrop,]
  }
  fit <- lmFit(pat.pheno,design)
 #  Moderated t-statistic
  fit <- eBayes(fit)
 print( topTable(fit,coef=2))
  return(fit)
 }


getMutationColors<-function(){

 # mutCols<-c("thistle1",
#	"darkorchid2",
#	"purple3",
#	"khaki",
#	"white",
#	"dodgerblue",
#	"cyan2",
#	"cadetblue4",
#	"hotpink",
#	"lightblue1",
#	"seagreen2",
#	 "black")
  mutCols<-c(
	#BCL2+	
	"thistle1",
	#BCL2+BCL6+EZH2"
	"grey79",
	#BCL2+EZH2+
	"aquamarine4",
	#BCL6+CD79b+
	"purple3",
	#CD79b
	"khaki",
	#EZH2
	"black",
	#MYD88
	"hotpink",
	##TP53"
 	"dodgerblue",
	##TP53 CD79b
	"cyan2",
	#TP53+CD79B+MYD88
	"darkorchid2",
	#TP53+SGK+
	"cadetblue2",
	"lightblue1",
	"seagreen2",
	"none")


  names(mutCols)<-c("BCL2+",
	"BCL6+BCL2+EZH2+","BCL2+EZH2+","BCL6+CD79B+","CD79B+","EZH2+","MYD88.L265P+",
	"TP53+","TP53+CD79B+","TP53+CD79B+MYD88.L265P+",
	"TP53+SGK1+","NOTCH1+","NOTCH2+","none")
 return(mutCols)
}


local_diffcyt<-
function (d_input, experiment_info = NULL, marker_info = NULL, 
    design = NULL, formula = NULL, contrast, analysis_type = c("DA", 
        "DS"), method_DA = c("diffcyt-DA-edgeR", 
        "diffcyt-DA-voom", "diffcyt-DA-GLMM","diffcyt-DA-GLMM-Local"), method_DS = c("diffcyt-DS-limma", 
        "diffcyt-DS-LMM"), markers_to_test = NULL, clustering_to_use = NULL, 
    cols_to_include = NULL, subsampling = FALSE, n_sub = NULL, 
    seed_sub = NULL, transform = TRUE, cofactor = 5, cols_clustering = NULL, 
    xdim = 10, ydim = 10, meta_clustering = FALSE, meta_k = 40, 
    seed_clustering = NULL, min_cells = 3, min_samples = NULL, 
    normalize = FALSE, norm_factors = "TMM", trend_method = "none", 
    block_id = NULL, trend = TRUE, weights = TRUE, plot = FALSE, 
    path = ".", verbose = TRUE) 
{
    analysis_type <- match.arg(analysis_type)
    method_DA <- match.arg(method_DA)
    method_DS <- match.arg(method_DS)
    if (!is(d_input, "SingleCellExperiment")) {
        if (is.null(experiment_info) | is.null(marker_info)) {
            stop("'experiment_info' and 'marker_info' must be provided (unless using a SingleCellExperiment ", 
                "object from CATALYST as input)")
        }
        if (verbose) 
            message("preparing data...")
        d_se <- prepareData(d_input, experiment_info, marker_info, 
            cols_to_include, subsampling, n_sub, seed_sub)
        if (transform) {
            if (verbose) 
                message("transforming data...")
            d_se <- transformData(d_se, cofactor)
        }
        if (verbose) 
            message("generating clusters...")
        d_se <- generateClusters(d_se, cols_clustering, xdim, 
            ydim, meta_clustering, meta_k, seed_clustering)
    }
    else if (is(d_input, "SingleCellExperiment")) {
        if (verbose) 
            message("using SingleCellExperiment object from CATALYST as input")
        if (is.null(clustering_to_use)) {
            stopifnot("cluster_id" %in% colnames(colData(d_input)))
            if (verbose) 
                message("using cluster IDs stored in column named 'cluster_id' in 'colData' of ", 
                  "SingleCellExperiment object from CATALYST")
            clustering_name <- colnames(metadata(d_input)$cluster_codes)[1]
        }
        else if (!is.null(clustering_to_use)) {
            stopifnot(as.character(clustering_to_use) %in% colnames(metadata(d_input)$cluster_codes))
            stopifnot("cluster_id" %in% colnames(colData(d_input)))
            if (verbose) 
                message("using cluster IDs from clustering stored in column '", 
                  clustering_to_use, "' of 'cluster_codes' data frame in 'metadata' of SingleCellExperiment object from CATALYST")
            code_id <- colData(d_input)$cluster_id
            cluster_id <- metadata(d_input)$cluster_codes[, clustering_to_use][code_id]
            stopifnot(length(cluster_id) == nrow(colData(d_input)), 
                length(code_id) == nrow(colData(d_input)))
            colData(d_input)$code_id <- code_id
            colData(d_input)$cluster_id <- cluster_id
            clustering_name <- clustering_to_use
        }
        stopifnot("sample_id" %in% colnames(colData(d_input)))
        stopifnot("cluster_id" %in% colnames(colData(d_input)))
        stopifnot("cluster_codes" %in% names(metadata(d_input)))
        if (!("experiment_info" %in% names(metadata(d_input)))) {
            if (verbose) 
                message("generating 'experiment_info' from input object")
            m <- match(levels(droplevels(factor(d_input$sample_id))), 
                d_input$sample_id)
            experiment_info <- data.frame(colData(d_input)[m, 
                ], check.names = FALSE, row.names = NULL)
            metadata <- as.list(c(metadata(d_input), experiment_info))
        }
        else {
            experiment_info <- metadata(d_input)$experiment_info
            metadata <- metadata(d_input)
        }
        cs_by_s <- split(seq_len(ncol(d_input)), colData(d_input)$sample_id)
        cs <- unlist(cs_by_s[as.character(experiment_info$sample_id)])
        es <- t(assays(d_input)[["exprs"]])[cs, , drop = FALSE]
        d_se <- SummarizedExperiment(assays = list(exprs = es), 
            rowData = colData(d_input)[cs, ], colData = rowData(d_input), 
            metadata = metadata)
    }
    if (verbose) 
        message("calculating features...")
    d_counts <- calcCounts(d_se)
    if (analysis_type == "DS") {
        d_medians <- calcMedians(d_se)
        d_medians_by_cluster_marker <- calcMediansByClusterMarker(d_se)
        d_medians_by_sample_marker <- calcMediansBySampleMarker(d_se)
    }
    if (analysis_type == "DA" && method_DA == "diffcyt-DA-edgeR") {
        if (verbose) 
            message("calculating DA tests using method 'diffcyt-DA-edgeR'...")
        res <- testDA_edgeR(d_counts, design, contrast, trend_method, 
            min_cells, min_samples, normalize, norm_factors)
    }
    if (analysis_type == "DA" && method_DA == "diffcyt-DA-voom") {
        if (verbose) 
            message("calculating DA tests using method 'diffcyt-DA-voom'...")
        res <- testDA_voom(d_counts, design, contrast, block_id, 
            min_cells, min_samples, normalize, norm_factors, 
            plot, path)
    }
    if (analysis_type == "DA" && method_DA == "diffcyt-DA-GLMM") {
        if (verbose) 
            message("calculating DA tests using method 'diffcyt-DA-GLMM'...")
        res <- testDA_GLMM(d_counts, formula, contrast, min_cells, 
            min_samples, normalize, norm_factors)
    }
    
    if (analysis_type == "DA" && method_DA == "diffcyt-DA-GLMM-Local") {
        if (verbose) 
            message("calculating DA tests using method 'diffcyt-DA-GLMM'...")
        res <- testDA_GLMM_Local(d_counts, formula, contrast, min_cells, 
            min_samples, normalize, norm_factors)
    }
    
    if (analysis_type == "DS" && method_DS == "diffcyt-DS-limma") {
        if (verbose) 
            message("calculating DS tests using method 'diffcyt-DS-limma'...")
        res <- testDS_limma(d_counts, d_medians, design, contrast, 
            block_id, trend, weights, markers_to_test, min_cells, 
            min_samples, plot, path)
    }
    if (analysis_type == "DS" && method_DS == "diffcyt-DS-LMM") {
        if (verbose) 
            message("calculating DS tests using method 'diffcyt-DS-LMM'...")
        res <- testDS_LMM(d_counts, d_medians, formula, contrast, 
            weights, markers_to_test, min_cells, min_samples)
    }
    if (!is(d_input, "SingleCellExperiment")) {
        if (analysis_type == "DA") {
            return(list(res = res, d_se = d_se, d_counts = d_counts))
        }
        else if (analysis_type == "DS") {
            return(list(res = res, d_se = d_se, d_counts = d_counts, 
                d_medians = d_medians, d_medians_by_cluster_marker = d_medians_by_cluster_marker, 
                d_medians_by_sample_marker = d_medians_by_sample_marker))
        }
    }
    else if (is(d_input, "SingleCellExperiment")) {
        metadata(res) <- as.list(c(metadata(res), clustering_name = clustering_name))
        if (analysis_type == "DA") {
            return(list(res = res, d_counts = d_counts))
        }
        else if (analysis_type == "DS") {
            return(list(res = res, d_counts = d_counts, d_medians = d_medians, 
                d_medians_by_cluster_marker = d_medians_by_cluster_marker, 
                d_medians_by_sample_marker = d_medians_by_sample_marker))
        }
    }
}



library(multcomp)
    
testDA_GLMM_Local<-function (d_counts, formula, contrast=createContrast(c(0,0,0,0,0,0,0,0,1,0,0,0,-1/2,0,-1/2,0,0,0,0)), min_cells = 3, min_samples = NULL, 
    normalize = FALSE, norm_factors = "TMM") 
{
    if (is.null(min_samples)) {
        min_samples <- ncol(d_counts)/2
    }
    counts <- assays(d_counts)[["counts"]]
    cluster_id <- rowData(d_counts)$cluster_id
    tf <- counts >= min_cells
    ix_keep <- apply(tf, 1, function(r) sum(r) >= min_samples)
    counts <- counts[ix_keep, , drop = FALSE]
    cluster_id <- cluster_id[ix_keep]
    if (normalize & norm_factors == "TMM") {
        norm_factors <- edgeR::calcNormFactors(counts, method = "TMM")
    }
    if (normalize) {
        n_cells_smp <- colSums(counts)/norm_factors
    }
    else {
        n_cells_smp <- colSums(counts)
    }
    if (ncol(contrast) == 1 & nrow(contrast) > 1) {
        contrast <- t(contrast)
    }
    p_vals <- rep(NA, length(cluster_id))
    estimatedEff<-rep(NA,length(cluster_id))
    for (i in seq_along(cluster_id)) {
        p_vals[i] <- tryCatch({
            y <- counts[i, ]/n_cells_smp
            data_i <- cbind(y, n_cells_smp, formula$data)
            fit <- lme4::glmer(formula$formula, data = data_i, family = "binomial", 
                weights = n_cells_smp)
            test <- multcomp::glht(fit, contrast)
            summary(test)$test$pvalues
        }, error = function(e) NA)
    }
    
    ###extracting the LogFC.
    for (i in seq_along(cluster_id)) {
    estimatedEff[i] <- tryCatch({
      y <- counts[i, ]/n_cells_smp
      data_i <- cbind(y, n_cells_smp, formula$data)
      fit <- lme4::glmer(formula$formula, data = data_i, family = "binomial", 
        weights = n_cells_smp)
       # fitOut<-msigetSummary.merMod(fit)$coef
      #estimates<-estimates<-fitOut[,,]
      #estimatedEff[i]<-sum(estimates[,1]*contrast)
      test <- multcomp::glht(fit, contrast)
      summary(test)$test$coefficients
          }, error = function(e) NA)
 }
    
    p_adj <- p.adjust(p_vals, method = "fdr")
    stopifnot(length(p_vals) == length(p_adj))
    out <- data.frame(p_val = p_vals, p_adj = p_adj, estimate=estimatedEff, stringsAsFactors = FALSE)
    row_data <- as.data.frame(matrix(as.numeric(NA), nrow = nlevels(cluster_id), 
        ncol = ncol(out)))
    colnames(row_data) <- colnames(out)
    cluster_id_nm <- as.numeric(cluster_id)
    row_data[cluster_id_nm, ] <- out
    row_data <- cbind(cluster_id = rowData(d_counts)$cluster_id, 
        row_data)
    res <- d_counts
    rowData(res) <- row_data
    if (normalize) {
        metadata(res)$norm_factors <- norm_factors
    }
    res<-res[order(rowData(res)$p_adj),]
}


###states
testDS_LMM_Local<-function (d_counts, d_medians, formula, contrast, weights = TRUE, 
    markers_to_test = NULL, min_cells = 3, min_samples = NULL) 
{
    if (is.null(min_samples)) {
        min_samples <- ncol(d_counts)/2
    }
    if (!is.null(markers_to_test)) {
        markers_to_test <- markers_to_test
    }
    else {
        markers_to_test <- metadata(d_medians)$id_state_markers
    }
    counts <- assays(d_counts)[["counts"]]
    cluster_id <- rowData(d_counts)$cluster_id
    tf <- counts >= min_cells
    ix_keep <- apply(tf, 1, function(r) sum(r) >= min_samples)
    counts <- counts[ix_keep, , drop = FALSE]
    cluster_id <- cluster_id[ix_keep]
    if (is.logical(weights)) {
        if (weights) {
            weights <- colSums(counts)
        }
        else {
            weights <- NULL
        }
    }
    else if (is.numeric(weights)) {
        stopifnot(length(weights) == ncol(d_counts))
    }
    if (ncol(contrast) == 1 & nrow(contrast) > 1) {
        contrast <- t(contrast)
    }
    state_names <- names(assays(d_medians))[markers_to_test]
    meds <- do.call("rbind", {
        lapply(as.list(assays(d_medians)[state_names]), function(a) a[as.character(cluster_id), 
            , drop = FALSE])
    })
    meds_all <- do.call("rbind", as.list(assays(d_medians)[state_names]))
    p_vals <- rep(NA, nrow(meds))
    estimatedEff<-rep(NA,length(cluster_id))

    for (i in seq_len(nrow(meds))) {
        p_vals[i] <- tryCatch({
            y <- meds[i, ]
            data_i <- cbind(cbind(y, weights), formula$data)
            if (formula$random_terms) {
                fit <- lme4::lmer(formula$formula, data = data_i, weights = weights)
            }
            else {
                fit <- lm(formula$formula, data = data_i, weights = weights)
            }
            test <- multcomp::glht(fit, contrast)
            summary(test)$test$pvalues
        }, error = function(e) NA)
    }
    
    ###extracting the LogFC.
    for (i in seq_along(cluster_id)) {
    estimatedEff[i] <- tryCatch({
      y <- meds[i, ]
      data_i <- cbind(cbind(y, weights), formula$data)
     if (formula$random_terms) {
                fit <- lme4::lmer(formula$formula, data = data_i, weights = weights)
            }
            else {
                fit <- lm(formula$formula, data = data_i, weights = weights)
            }
       
      test <- multcomp::glht(fit, contrast)
      summary(test)$test$coefficients
          }, error = function(e) NA)
 }
    
    p_adj <- p.adjust(p_vals, method = "fdr")
    stopifnot(length(p_vals) == length(p_adj))
    out <- data.frame(p_val = p_vals, p_adj = p_adj,estimate=estimatedEff, stringsAsFactors = FALSE)
    row_data <- as.data.frame(matrix(as.numeric(NA), nrow = nlevels(cluster_id) * 
        length(state_names), ncol = ncol(out)))
    colnames(row_data) <- colnames(out)
    cluster_id_nm <- as.numeric(cluster_id)
    s <- seq(0, nlevels(cluster_id) * (length(state_names) - 
        1), by = nlevels(cluster_id))
    r1 <- rep(cluster_id_nm, length(state_names))
    r2 <- rep(s, each = length(cluster_id_nm))
    stopifnot(length(s) == length(state_names))
    stopifnot(length(r1) == length(r2))
    rows <- r1 + r2
    row_data[rows, ] <- out
    clus <- factor(rep(levels(cluster_id), length(state_names)), 
        levels = levels(cluster_id))
    stat <- factor(rep(state_names, each = length(levels(cluster_id))), 
        levels = state_names)
    stopifnot(length(clus) == nrow(row_data), length(stat) == 
        nrow(row_data))
    row_data <- cbind(data.frame(cluster_id = clus, marker_id = stat, 
        stringsAsFactors = FALSE), row_data)
    col_data <- colData(d_medians)
    res <- SummarizedExperiment(meds_all, rowData = row_data, 
        colData = col_data)
    res<-res[order(rowData(res)$p_adj),]
}
 


testDS_limma_local<-function (d_counts, d_medians, design, contrast, block_id = NULL, 
    trend = TRUE, weights = TRUE, markers_to_test = NULL, min_cells = 3, 
    min_samples = NULL, plot = FALSE, path = ".") 
{
    if (!is.null(block_id) & !is.factor(block_id)) {
        block_id <- factor(block_id, levels = unique(block_id))
    }
    if (is.null(min_samples)) {
        min_samples <- ncol(d_counts)/2
    }
    if (!is.null(markers_to_test)) {
        markers_to_test <- markers_to_test
    }
    else {
        markers_to_test <- metadata(d_medians)$id_state_markers
    }
    counts <- assays(d_counts)[["counts"]]
    cluster_id <- rowData(d_counts)$cluster_id
    tf <- counts >= min_cells
    ix_keep <- apply(tf, 1, function(r) sum(r) >= min_samples)
    counts <- counts[ix_keep, , drop = FALSE]
    cluster_id <- cluster_id[ix_keep]
    state_names <- names(assays(d_medians))[markers_to_test]
    meds <- do.call("rbind", {
        lapply(as.list(assays(d_medians)[state_names]), function(a) a[as.character(cluster_id), 
            , drop = FALSE])
    })
    meds_all <- do.call("rbind", as.list(assays(d_medians)[state_names]))
    if (!is.null(block_id)) {
        dupcor <- duplicateCorrelation(meds, design, block = block_id)
    }
    if (weights) {
        weights <- counts[as.character(rep(cluster_id, length(state_names))), 
            ]
        stopifnot(nrow(weights) == nrow(meds))
    }
    else {
        weights <- NULL
    }
    if (!is.null(block_id)) {
        message("Fitting linear models with random effects term for 'block_id'.")
        fit <- lmFit(meds, design, weights = weights, block = block_id, 
            correlation = dupcor$consensus.correlation)
    }
    else {
        fit <- lmFit(meds, design, weights = weights)
    }
    fit <- contrasts.fit(fit, contrast)
    efit <- eBayes(fit, trend = trend)
    if (plot) {
        pdf(file.path(path, "SA_plot.pdf"), width = 6, 
            height = 6)
        plotSA(efit)
        dev.off()
    }
    top <- limma::topTable(efit, coef = 1, number = Inf, adjust.method = "BH", 
        sort.by = "none")
    if (!all(top$ID %in% cluster_id)) {
        stop("cluster labels do not match")
    }
    row_data <- as.data.frame(matrix(as.numeric(NA), nrow = nlevels(cluster_id) * 
        length(state_names), ncol = ncol(top)))
    colnames(row_data) <- colnames(top)
    cluster_id_nm <- as.numeric(cluster_id)
    s <- seq(0, nlevels(cluster_id) * (length(state_names) - 
        1), by = nlevels(cluster_id))
    r1 <- rep(cluster_id_nm, length(state_names))
    r2 <- rep(s, each = length(cluster_id_nm))
    stopifnot(length(s) == length(state_names))
    stopifnot(length(r1) == length(r2))
    rows <- r1 + r2
    row_data[rows, ] <- top
    clus <- factor(rep(levels(cluster_id), length(state_names)), 
        levels = levels(cluster_id))
    stat <- factor(rep(state_names, each = length(levels(cluster_id))), 
        levels = state_names)
    stopifnot(length(clus) == nrow(row_data), length(stat) == 
        nrow(row_data))
    row_data <- cbind(data.frame(cluster_id = clus, marker_id = stat, 
        stringsAsFactors = FALSE), row_data)
    colnames(row_data)[colnames(row_data) == "P.Value"] <- "p_val"
    colnames(row_data)[colnames(row_data) == "adj.P.Val"] <- "p_adj"
    col_data <- colData(d_medians)
    res <- SummarizedExperiment(meds_all, rowData = row_data, 
        colData = col_data)
   res<- res[order(rowData(res)$p_adj),]
}


    
plotMedianExpressionBoxplot<-function(d_medians=NULL,cluster=NULL,marker=NULL,clinicalFactor=NULL){
  ex<-assays(d_medians)[[as.character(marker)]]
  ex<-as.data.frame(t(ex))
    ex$highIPI<-factor(exper_info2$highIPI[match(rownames(ex),exper_info2$sample_id)])
    ex$REF<-factor(exper_info2$group_id[match(rownames(ex),exper_info2$sample_id)])
  ex$NGCB<-factor(exper_info2$NGCB[match(rownames(ex),exper_info2$sample_id)])
  ex$C1<-factor(exper_info2$C1[match(rownames(ex),exper_info2$sample_id)])
  ex$C2<-factor(exper_info2$C2[match(rownames(ex),exper_info2$sample_id)])
  ex$C3<-factor(exper_info2$C3[match(rownames(ex),exper_info2$sample_id)])
  ex$C4<-factor(exper_info2$C4[match(rownames(ex),exper_info2$sample_id)])
  ex$C5<-factor(exper_info2$C5[match(rownames(ex),exper_info2$sample_id)])
  ex$doubleExpressor<-factor(exper_info2$doubleExpressor[match(rownames(ex),exper_info2$sample_id)])
   gg<-ggplot(ex,aes_string(x=clinicalFactor,y=cluster))+geom_boxplot()+ylab(paste0(marker," Normalized Median expression"))+ggtitle(cluster)+geom_jitter(color="grey")
  return(gg)
}


     
plotAbundanceCPMDiffCyt<-function(d_counts=NULL,cluster=NULL,marker=NULL,clinicalFactor=NULL){
   
  counts<-assays(d_counts)[["counts"]]
  cluster_id <- rowData(d_counts)$cluster_id
    tf <- counts >= 50
    ix_keep <- apply(tf, 1, function(r) sum(r) >=4)
    counts <- counts[ix_keep, , drop = FALSE]
    cluster_id <- cluster_id[ix_keep]
    
   norm.factors<-edgeR::calcNormFactors(counts,method="TMM")
    y <- edgeR::DGEList(counts,norm.factors = norm.factors)
  
  ###generate CPM counts of abundance  
  y <- edgeR::estimateDisp(y, design, trend.method = "none")
  logCPM<-asinh(edgeR::cpm(y))
  logCPM<-as.data.frame(t(logCPM))
  logCPM$highIPI<-factor(exper_info2$highIPI[match(rownames(logCPM),exper_info2$sample_id)])
    logCPM$REF<-factor(exper_info2$group_id[match(rownames(logCPM),exper_info2$sample_id)])
  logCPM$NGCB<-factor(exper_info2$NGCB[match(rownames(logCPM),exper_info2$sample_id)])
  logCPM$C1<-factor(exper_info2$C1[match(rownames(logCPM),exper_info2$sample_id)])
  logCPM$C2<-factor(exper_info2$C2[match(rownames(logCPM),exper_info2$sample_id)])
  logCPM$C3<-factor(exper_info2$C3[match(rownames(logCPM),exper_info2$sample_id)])
  logCPM$C4<-factor(exper_info2$C4[match(rownames(logCPM),exper_info2$sample_id)])
  logCPM$C5<-factor(exper_info2$C5[match(rownames(logCPM),exper_info2$sample_id)])
  logCPM$doubleExpressor<-factor(exper_info2$doubleExpressor[match(rownames(logCPM),exper_info2$sample_id)])
 gg<-ggplot(logCPM,aes_string(x=clinicalFactor,y=cluster))+geom_boxplot()+ylab(paste0(cluster," Log-CPM"))+ggtitle(cluster)+geom_jitter(color="grey")
 return(gg)
} 

## 1-8: we use pch symbols 12 instead of 7.
createAnnotation<-function(DS=NULL,full.dn4,X=NULL,phenotype="unsup.subcommunity"){
  ddf<-diffcyt::topTable(DS,format_vals = TRUE,top_n=10, show_logFC = TRUE)%>%as.data.frame
    print(ddf)
  key<-data.frame(cluster_id=NA,marker_id=NA,logFC=0,p_adj=NA,symbol=NA,id=rownames(X))
  key<-key[match(rownames(X),key$id),]
  rez<-ddf[which(ddf$p_adj<0.1),]
  rez$id<-as.character(full.dn4[match(rez$cluster_id,full.dn4[,phenotype]),phenotype])
  rez$symbol<-NA
  rez$symbol[which(rez$p_adj<=0.01)]<-12
  rez$symbol[which(rez$p_adj>0.01 & rez$p_adj<=0.05)]<-3
    rez$symbol[which(rez$p_adj>0.05 & rez$p_adj<0.1)]<-17
key[match(rez$id,key$id),c("cluster_id","logFC","p_adj","symbol")]<-rez[,c("cluster_id","logFC","p_adj","symbol")]  
     return(key)
}   


 
findChapuyProportion<-function(sce=NULL,cluster="C1",phenotype="unsup.subcommunity",tmeOnly=TRUE,modelResults=NULL){
  #computes the conditional prob, and Z-score from mean 
  modelRes<-as.data.frame(topTable(modelResults,top_n=60,show_logFC = TRUE))
    c1size<-as.data.frame.matrix(table(colData(sce)$cluster_id,colData(sce)[,cluster]))
 clusterTotal<- as.data.frame(table(full.dn4[,phenotype]))
  c1size$clusterTotal<-0
  c1size$clusterTotal[match(clusterTotal$Var1, rownames(c1size))]<-clusterTotal$Freq
  c1size$chapuyProp<-0
  c1size$condProb<-0
  c1size$Z<-0
  tmeID<-!grepl("Tumor",rownames(c1size))
   c1size$chapuyProp<-100*c1size[,"1"]/sum(c1size[,"1"])
 
 if(any(c1size$chapuyProp>13)){
  c1size$chapuyProp[which(c1size$chapuyProp>13)]<-8.5
 }
   
   
 if(any(c1size$chapuyProp<1)){
  c1size$chapuyProp[which(c1size$chapuyProp<2)]<-1
  }
  
   Tot<-ncol(sce)
  if(tmeOnly==FALSE){
  c1size$condProb<-100*(c1size[,"1"]/Tot)/(sum(c1size[,"1"])/Tot)
     c1size$Z<-(c1size$condProb-mean(c1size$condProb))/sd(c1size$condProb)
  }else{
   c1size$condProb[tmeID]<-100*(c1size[tmeID,"1"]/Tot)/(sum(c1size[tmeID,"1"])/Tot)
   c1size$Z[tmeID]<-(c1size$condProb[tmeID]-mean(c1size$condProb[tmeID]))/sd(c1size$condProb[tmeID])
  }
   c1size$logFC<-modelRes$logFC[match(rownames(c1size),rownames(modelRes))]
   c1size$logFC[is.na(c1size$logFC)]<-0
   
     c1size$adj_p<-modelRes$p_adj[match(rownames(c1size),rownames(modelRes))]

   return(c1size)
}


grabMedianNormalized<-function(d_medians=NULL,cluster=NULL,marker=NULL,clinicalFactor=NULL){
  ex<-assays(d_medians)[[as.character(marker)]]
  ex<-as.data.frame(t(ex))
   #ex<-ex[,cluster]
    ex$highIPI<-factor(exper_info2$highIPI[match(rownames(ex),exper_info2$sample_id)])
    ex$REF<-factor(exper_info2$group_id[match(rownames(ex),exper_info2$sample_id)])
  ex$NGCB<-factor(exper_info2$NGCB[match(rownames(ex),exper_info2$sample_id)])
  ex$C1<-factor(exper_info2$C1[match(rownames(ex),exper_info2$sample_id)])
  ex$C2<-factor(exper_info2$C2[match(rownames(ex),exper_info2$sample_id)])
  ex$C3<-factor(exper_info2$C3[match(rownames(ex),exper_info2$sample_id)])
  ex$C4<-factor(exper_info2$C4[match(rownames(ex),exper_info2$sample_id)])
  ex$C5<-factor(exper_info2$C5[match(rownames(ex),exper_info2$sample_id)])
  ex$doubleExpressor<-factor(exper_info2$doubleExpressor[match(rownames(ex),exper_info2$sample_id)])
  return(ex[,c(cluster,"highIPI","REF","NGCB","C1","C2","C3","C4","C5")])
}






## phenograph to spatial point patter (PPP) object
 phenographToPPP<-function(case=NULL,marksCase=NULL,shift=FALSE){
 suppressPackageStartupMessages( require(spatstat))
  ##case: the case is the phenographed CSV 
  ##returns the PPP object, with marks as the original data frame.
  ##note that the window minimum is set to 0. This **SHOULD** not hopefully interfere with the spatial coordinates.
 ##this change of min 0 was necessary for clusterset function which conflicted with the window range.
  if(shift==TRUE){
  minX<-min(case[,"X_position"])
  minY<-min(case[,"Y_position"])
 case[,"X_position"]<-case[,"X_position"]-minX
 case[,"Y_position"]<-case[,"Y_position"]-minY
    mypat<-ppp(case[,"X_position"],case[,"Y_position"],c(min(case[,"X_position"]),summary(case[,"X_position"])[6]),c(min(case[,"Y_position"]),summary(case[,"Y_position"])[6]),marks=marksCase)
  ##shifting via spatstat causes non-stationary errors. FIXME: use manual shifting of coordinates prior   
 #mypat<-spatstat::shift(mypat,c(-minX,-minY))
  }else{
    #mypat<-ppp(case[,"X_position"],case[,"Y_position"],c(0,summary(case[,"X_position"])[6]),c(0,summary(case[,"Y_position"])[6]),marks=marksCase)
 mypat<-ppp(case[,"X_position"],case[,"Y_position"],c(min(case[,"X_position"]),max(case[,"X_position"])),c(min(case[,"Y_position"]),max(case[,"Y_position"])),marks=marksCase) 
 } 

 ## scale in  micrometers
   unitname(mypat)<-"micrometer"

  return(mypat)
 }

 #### borrowing from Vito's pipeline.
  findSecondObjectNumber<-function(pp=NULL,minDistance=13.5){
  ##FIX ME : use apply nbhd
   x<-pairdist(pp)
    id<-apply(x,1,function(x) which(x<=minDistance))
  ##stack the list into long format
  names(id)<-as.character(seq(1,npoints(pp)))
  datRel<-stack(id)
 ##the second object near the first fixed object.
  colnames(datRel)<-c("Second Object Number","First Object Number")
   ##exclude self
   datRel<-datRel[which(datRel[,"First Object Number"]!=datRel[,"Second Object Number"]),]
   datRel[,1]<-as.numeric(datRel[,1])
  datRel[,2]<-as.numeric(datRel[,2])
   return(datRel)
  }




 createRelationTable<-function(dn5=NULL,myPheno=NULL,minDistance=12){
  ##for each ROI, create PPP
  dat_relation2<-c()
  for(roi in unique(dn5$ROIID)){
   message(roi)
   dats<-subset(dn5,dn5$ROIID==roi)
   synth3.cells<-phenographToPPP(case=dats,marks=factor(dats[,myPheno]))
   dat_relation<-findSecondObjectNumber(pp=synth3.cells,minDistance=minDistance)
  dat_relation$Relationship<-"Neighbors"
  dat_relation[,"First Object Name"]<-"cell"
  dat_relation[,"First Image Number"]<-roi
  dat_relation[,"Second Object Name"]<-"cell"
  dat_relation[,"Second Image Number"]<-roi
  dat_relation2<-rbind(dat_relation2,dat_relation)
  }
 return(data.table(dat_relation2))
}



makePermutationNBHD<-function(dat_cells=NULL,dat_relation=NULL,n_perm=100,pthreshold=0.05){
  d = prepare_tables(dat_cells, dat_relation)
  dat_baseline = apply_labels(d[[1]], d[[2]]) %>%
  aggregate_histo()


 set.seed(12312)
   dat_perm = rbindlist(mclapply(1:n_perm, function(x){
  dat_labels = shuffle_labels(d[[1]])
  apply_labels(dat_labels, d[[2]]) %>%
    aggregate_histo()
  },mc.cores = 1
  ), idcol = 'run') 
 
   dat_p <- calc_p_vals(dat_baseline, dat_perm, n_perm = n_perm, p_tresh = pthreshold) 
 ### plotting heatmap.
  
   pmat = dcast(dat_p, 'FirstLabel ~ SecondLabel', value.var = 'sigval', fun.aggregate = sum,
             fill=0, drop=F)
   rname = pmat$FirstLabel
   pmat<-as.data.table(pmat)
   pmat = pmat[,which(colnames(pmat)!="FirstLabel"),with=FALSE] %>%
    as.matrix()
row.names(pmat) <- rname
 ### he structures his probabilities greater than and less than.
  return(list(pmat=pmat,dat_p=dat_p))
 }

## Vito Methodology.
 performVitoInteraction<-function(full.dn4.5nn2=NULL,phenotypeColumn=NULL,saveName=NULL,minDistance=15){
  zz<-full.dn4.5nn2
 table(zz[,phenotypeColumn])
   ### Vito's spatial analysis subtypes.
  dat_cells<-data.frame(ImageNumber=zz$ROIID,
	ObjectNumber=zz$CellId,
	label=as.character(zz[,phenotypeColumn]),
	group=zz$ROIID)
  dat_cells<-data.table(dat_cells)
  dat_relation<-createRelationTable(dn5=zz,myPheno=phenotypeColumn,minDistance=minDistance)
 save(dat_relation,file=paste0("dat_relation_",minDistance,"_",saveName,".RData"))

  p1<-makePermutationNBHD(dat_cells=dat_cells,dat_relation=dat_relation,n_perm=1000)
  save(p1,file=paste0("p1_",minDistance,"_",saveName,".RData"))
   require(pheatmap)
  cols = rev(brewer.pal(11,'Spectral'))
  cmap = colorRampPalette(cols)
  hr <- hclust(dist(p1$pmat), method="ward.D")
     pheatmap(p1$pmat, 
	color = cmap(25), 
    cluster_cols = TRUE, 
    cluster_rows = TRUE, 
    labels_col = colnames(p1),
    labels_row = colnames(p1), 
    display_numbers = TRUE,  
    fontsize = 14,
    cutree_rows=2,
	cutree_cols=2)

  return(p1)
 }
 
 
 
 getPhenoColorsAnnotatedLabel<-function(full.dn4){
 ##this requires the T-Cell names to not be included.
 require(circlize)
  tsn<-full.dn4[which(!is.na(full.dn4$tSNE1) & !is.na(full.dn4$tSNE2)),c("tSNE1",
	"tSNE2",
	"Cell_CD20",
	"Cell_CD3",
	"Cell_CD4",
	"Cell_CD31",
	"Cell_CD4",
	"Cell_CD68",
	"Cell_CD8",
	"Cell_FOXP3",
	"Cell_BCL2",
	"uniqueLabel","response","ROIID",
	"annotated.label")]
  ##balanced response representation.
   table(tsn$response)
  tsn$primary.phenotype<-(tsn$annotated.label)
   cd8s<-colorRampPalette(c("darkseagreen","green"),5)
  cd4s<-colorRampPalette(c("lightsteelblue1","blue"),5)
  macs<-colorRampPalette(c("magenta","maroon4"),5)
   tregs<-colorRampPalette(c("plum2","purple"),5)
   tumrs<-colorRampPalette(c("grey24","grey64"),20)
   phenoColors<-c(cd4s(5),
	cd8s(3),"red",macs(4),
	tregs(3),
	tumrs(2),'bisque')

 names(phenoColors)<-c(levels(factor(tsn$primary.phenotype)),'Tumor_11')
   ##manual color change code.
   phenoColors["Memory CD4"]<-"darkblue"
    phenoColors["CD45RA- exhausted CD4"]<-"turquoise2"
   phenoColors["Ki67+ memory CD4"]<-"steelblue4"

   phenoColors["Exhausted CD8"]<-"springgreen4"

 ##
    phenoColors["M1-Macrophage"]<-"magenta4"
    phenoColors["M2-Macrophage"]<-"hotpink2"
     phenoColors["PD-L1+ M2-Macrophage"]<-"lightpink"
 
 ## tregs
      phenoColors["T-reg"]<-"mediumorchid4"
       phenoColors["Highly suppressive T-reg"]<-"yellow"

 # full<-ggplot(tsn,  aes(x = tSNE1, y = tSNE2, color = primary.phenotype)) +
 # geom_point(size = 0.8) +
 # theme_bw() +
 # scale_color_manual(values = phenoColors) +
 # guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))
 # full

   return(phenoColors)
 }
 
 
    
    
distanceCalculationROI<-function(synth=NULL,zz=NULL,cluster.column="cd8.case.cluster"){
  require(Rphenograph)
  nnd1<-grabDistanceRange(synth,uniqueLabel=zz$uniqueLabel,k=1)
    nnd2<-grabDistanceRange(synth,uniqueLabel=zz$uniqueLabel,k=2)
  nnd3<-grabDistanceRange(synth,uniqueLabel=zz$uniqueLabel,k=3)
  nnd4<-grabDistanceRange(synth,uniqueLabel=zz$uniqueLabel,k=4)
  nnd5<-grabDistanceRange(synth,uniqueLabel=zz$uniqueLabel,k=5)
  #nnd6<-grabDistanceRange(synth,uniqueLabel=zz$uniqueLabel,k=6)
  #nnd7<-grabDistanceRange(synth,uniqueLabel=zz$uniqueLabel,k=7)
  #nnd8<-grabDistanceRange(synth,uniqueLabel=zz$uniqueLabel,k=8)
  
  ## assemble
  nnd<-cbind(nnd1[,grepl("k_",colnames(nnd1))],
	nnd2[,grepl("k_",colnames(nnd2))],
	nnd3[,grepl("k_",colnames(nnd3))],
	nnd4[,grepl("k_",colnames(nnd4))],
	nnd5[,grepl("k_",colnames(nnd5))])
	#nnd6[,grepl("k_",colnames(nnd6))],
	#nnd7[,grepl("k_",colnames(nnd7))],
	#nnd8[,grepl("k_",colnames(nnd8))])
    nnd$uniqueLabel<-zz$uniqueLabel
    nnd$marks<-marks(synth)
   stopifnot(all(nrow(nnd)==nrow(zz)))
     nnd$ROIID<-zz$ROIID
    nnd$cluster<-zz[,cluster.column]
  return(nnd)
}




 grabDistanceRange<-function(synth=NULL,uniqueLabel=NULL,k=1,from=NULL,to=NULL){
  nnd<-as.data.frame(nndist(synth,k=k,by=marks(synth)))
  colnames(nnd)<-paste0("k_",k,"_",colnames(nnd))
  for(i in 1:ncol(nnd)){
  nnd[which(is.infinite(nnd[,i])),i] <-300
 }##
   nnd$marks<-marks(synth)
   nnd$K=1
   nnd$uniqueLabel<-uniqueLabel 
  return(nnd)
 }
 
 
 

 createExpressionFormat<-function(ex=NULL,exper_info2){
  ex<-as.data.frame(t(ex))
    ex$highIPI<-factor(exper_info2$highIPI[match(rownames(ex),exper_info2$sample_id)])
    ex$REF<-factor(exper_info2$group_id[match(rownames(ex),exper_info2$sample_id)])
  ex$NGCB<-factor(exper_info2$NGCB[match(rownames(ex),exper_info2$sample_id)])
  ex$C1<-factor(exper_info2$C1[match(rownames(ex),exper_info2$sample_id)])
  ex$C2<-factor(exper_info2$C2[match(rownames(ex),exper_info2$sample_id)])
  ex$C3<-factor(exper_info2$C3[match(rownames(ex),exper_info2$sample_id)])
  ex$C4<-factor(exper_info2$C4[match(rownames(ex),exper_info2$sample_id)])
  ex$C5<-factor(exper_info2$C5[match(rownames(ex),exper_info2$sample_id)])
  ex$doubleExpressor<-factor(exper_info2$doubleExpressor[match(rownames(ex),exper_info2$sample_id)])
  ex$REF<-as.character(ex$REF)
  ex$REF[which(ex$REF=="Primary refract")]<-"Primary refractory"
  return(ex)
 }
 
  

getResponderColors<-function(){
 response.vars=c("darkslateblue","firebrick2","grey64")
 names(response.vars)<-c("CR","Primary refractory","not enriched")
  return(response.vars)
}



ecoxph <- function(X, surv, tol=1e-3, max.iter=50){
    if(class(X)=="data.frame")
        X = as.matrix(X)
    beta0 = rep(0,ncol(X))
    beta1 = rep(1,ncol(X))
    sigma2 = 1
    iter = 1
    while(max(abs(beta1-beta0))>tol& iter < max.iter){
        fit = coxph(surv ~ ridge(X, theta=1/sigma2, scale=FALSE))
        sigma2 = (1 + sum((fit$coefficients-mean(fit$coefficients))^2))/(ncol(X))   
        beta0 = beta1
        beta1 = fit$coefficients
        #cat(beta1,"\n")
        #cat(sigma,"\n")
        iter = iter+1
    }
    fit$sigma2 = sigma2
    names(fit$coefficients) = colnames(X)
    return(fit)
}

 readkey<-function () 
{
    cat("Press [enter] to continue")
    line <- readline()
}



```
### Library
- loads the library and clinical participant sheet.
```{r, eval=TRUE}
  require(ggplot2)
 suppressPackageStartupMessages( require(ComplexHeatmap))
 suppressPackageStartupMessages( require(knitr))
 suppressPackageStartupMessages( require(kableExtra))
suppressPackageStartupMessages( require(spatstat))
 suppressPackageStartupMessages(library(dplyr))
 suppressPackageStartupMessages(library(magrittr))
 suppressPackageStartupMessages(library(survival))
  suppressPackageStartupMessages(library(Hmisc))

 library(data.table)
library(dplyr)
library(magrittr)
library(dtplyr)
library(ggplot2)
library(parallel)
library(neighbouRhood)
library(gplots)
library(RColorBrewer)
 library(hrbrthemes)
  
   library(extrafont)
   # font_import()
  
     #clinic<-read.csv("~/Documents/imageAnalysis/DLBCL/monirath/myData/USC_CGI_DLBCL_Data_Final.csv",header=T)
 clinic<-read.csv("~/IMC-Ranalysis/DLBCL/monirath/myData/USC_CGI_DLBCL_Data_Final.csv")

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", 
  "#B17BA6", "#FF7F00", "#FDB462", "#E7298A", "#E78AC3", 
  "#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", 
  "#E6AB02", "#7570B3", "#BEAED4", "#666666", "#999999", 
  "#aa8282", "#d4b7b7", "#8600bf", "#ba5ce3", "#808000", 
  "#aeae5c", "#1e90ff", "#00bfff", "#56ff0d", "#ffff00")


```




### Figure 2
- This shows the expression standardization and the association with mutation factors (Figure S8 A).
- includes the endothlial meta-clusters; previously meta-clustering ignored endothelial sub-clusters. (revision 7-14)

```{r Figure2A, eval=TRUE,warning=FALSE,message=FALSE,fig.height = 13, fig.width = 18}

 # load("~/Documents/imageAnalysis/DLBCL/monirath/myData/revision-comments-11-6/survival-analysis-morphological-variants/PDL1-neighborhood-analysis/workingDir/re-phenotype/full.dn4.subType.corrected.mutation.tsne.CD20dim.filtered.RData")

 #load(file="~/Documents/imageAnalysis/DLBCL/monirath/myData/revision-comments-11-6/survival-analysis-morphological-variants/PDL1-neighborhood-analysis/workingDir/re-phenotype/full.dn4.subType.corrected.mutation.tsne.CD20dim.appended.un.filtered.RData")
load(file="~/IMC-Ranalysis/DLBCL/monirath/myData/revision-comments-11-6/full.dn4.subType.corrected.mutation.tsne.CD20dim.appended.un.filtered.RData")

 ##compile into 1 column unsupervised.community  
  full.dn4$unsup.subcommunity<-as.character(full.dn4$unsup.subcommunity)
     full.dn4$unsup.subcommunity[which(full.dn4$subType.correction=="Endothelial")]<-paste0("Endothelial_",full.dn4$Endothelial_subphenograph_cluster_meta[which(full.dn4$subType.correction=="Endothelial")])

  full.dn4$unsup.subcommunity<-factor(full.dn4$unsup.subcommunity,
	levels=c("CD4_1",
	       "CD4_2",
		"CD4_3",
		"CD4_4",
		"CD4_5","CD4_6","CD4_7",
	        "CD8_1","CD8_2","CD8_3","CD8_4","CD8_5","CD8_6","CD8_7",
 	       "Macrophage_1","Macrophage_2","Macrophage_3","Macrophage_4","Macrophage_5",
	"Macrophage_6",
	"TREG_1","TREG_2","TREG_3","TREG_4","TREG_5",     
	 "TREG_6",
	 "Tumor_1","Tumor_2","Tumor_3", "Tumor_4", "Tumor_5","Tumor_6","Tumor_7","Tumor_8", "Tumor_9",  "Tumor_10" ,"Tumor_11",
	"Endothelial_1",	"Endothelial_2",	"Endothelial_3", 	"Endothelial_4", 	"Endothelial_5", 	"Endothelial_6"  ))




  set.seed(1234)
  table(full.dn4$phenograph_cluster_meta,full.dn4$cell.type.new)
    

  lineage_markers<-c( "Cell_BCL2",
                       "Cell_BCL6",
                       "Cell_CD20",
                       "Cell_CD206",
                       "Cell_CD3",
                       "Cell_CD30",
                       "Cell_CD31",
                       "Cell_CD4",
                       "Cell_CD45RA",
                       "Cell_CD45RO",
                       "Cell_CD68" ,
                       "Cell_CD8",
                       "Cell_EphrinB2",
                       "Cell_FOXP3",
                       "Cell_HLADR" )
   induc<-c("Cell_C",
            "Cell_CCR4",
            "Cell_CD134",
            "Cell_CXCR3",
            "Cell_Granzym",
            "Cell_ICOS",
            "Cell_Ki67",
            "Cell_Lag3",
            "Cell_PD1",
            "Cell_PDL1",
            "Cell_PDL2",
            "Cell_Tbet",
            "Cell_Tim3",
            "Cell_Vimentin",
            "Cell_Vista",
            "Cell_p",
	"Area.norm",
	"Eccentricity.norm",
	"Solidity.norm",
	"Perimeter.norm",
	"Percent_Touching.norm",
	"Number_Neighbors.norm")

```
# Panel
- Using the MAUI software we need to set up a column output Isotope, Label, Start, Stop, BaselineStart, BaselineEnd, Batch, nnK, NoiseT
- exploratory use for maui image corrections.
```{r}
   panel<-dir("~/IMC-Ranalysis/multiple-myeloma/Data/MAUI_Structure/extracted/Point1/TIFs/")
   
 iso<-sapply(strsplit(panel,"\\."),function(x)x[2])
 iso<-substr(iso,3,5)%>%as.numeric
 label<- sapply(strsplit(panel,"\\."),function(x)x[1])

 
  panny<-data.frame(Isotope=iso,Label=label)
 panny<-panny[order(panny$Isotope),]

  panny$Start<-panny$Isotope-0.2
  panny$Stop<-panny$Isotope+0.2
  
   panny$BaselineStart<-panny$Isotope-0.5
  panny$BaselineEnd<-panny$Isotope-0.4
  
  write.csv(panny,file="~/IMC-Ranalysis/multiple-myeloma/Data/MAUI_Structure/info/panel.csv",row.names = FALSE)
 
```

# Preliminary Heatmap
- creates a heatmap of the measurement means (Z-scores)
```{r}
 ## we include the full panel, and morphological features (and DNA).
  zz<- zScorePatientExpression(full.dn4=full.dn4,markers=c(1:31,104:111),ROIID.column=32)
  zz[,c(1:31,32,104:111)]%>%group_by(ROIID)%>%summarise_all(funs(sd))%>%data.frame
  zz[,c(1:31,32,104:111)]%>%group_by(ROIID)%>%summarise_all(funs(mean))%>%data.frame
  ##note for the original expression profile we keep ND and all patients, but remove Tumor_11 dimCD20 from the analysis.  we omit Tumor_11 cluster. must keep ND subjects.

 ## for phenotype analysis we remove dim CD20, (Tumor_11) cluster.
   zz<-zz[which(zz$dimCD20.filtered=='NO'),]

 ## show the ROI standardization.
  z<-zz
   d<-data.frame(ROI=unique(z$ROIID),col=c(color_clusters,color_clusters[1:11]) )
 
 roiCol<-d[,2] 
  names(roiCol)<-d[,1]
  ### add ROI annotation. 
 rois<-HeatmapAnnotation(ROI=unique(z$ROIID),
	which="row",
	col=list(ROI=roiCol),
	annotation_legend_param=list(ncol=5))


   bcl2<-makeJoyPlot(z,marker="Cell_BCL2")
   bcl6<-makeJoyPlot(z,marker="Cell_BCL6")
     cd20<-makeJoyPlot(z,marker="Cell_CD20")
   cd206<-makeJoyPlot(z,marker="Cell_CD206")
    CD3<-makeJoyPlot(z,marker="Cell_CD3")
   CD31<-makeJoyPlot(z,marker="Cell_CD31")
   CD4<-makeJoyPlot(z,marker="Cell_CD4")
   CD45RA<-makeJoyPlot(z,marker="Cell_CD45RA")
   cd45ro<-makeJoyPlot(z,marker="Cell_CD45RO")
   cd68<-makeJoyPlot(z,marker="Cell_CD68")
    cd8<-makeJoyPlot(z,marker="Cell_CD8")
   foxp3<-makeJoyPlot(z,marker="Cell_FOXP3")
   hladr<-makeJoyPlot(z,marker="Cell_HLADR")
   ccr4<-makeJoyPlot(z,marker="Cell_CCR4")
    cxcr3<-makeJoyPlot(z,marker="Cell_CXCR3")
    granz<-makeJoyPlot(z,marker="Cell_Granzym")
    icos<-makeJoyPlot(z,marker="Cell_ICOS")
   ki<-makeJoyPlot(z,marker="Cell_Ki67")
   lag<-makeJoyPlot(z,marker="Cell_Lag3")
   pd1<-makeJoyPlot(z,marker="Cell_PD1")
   pdl1<-makeJoyPlot(z,marker="Cell_PDL1")
    tim3<-makeJoyPlot(z,marker="Cell_Tim3")
    vista<-makeJoyPlot(z,marker="Cell_Vista")
    vimentin<-makeJoyPlot(z,marker="Cell_Vimentin") 

     eph<-makeJoyPlot(z,marker="Cell_EphrinB2") 
     cc<-makeJoyPlot(z,marker="Cell_C") 
      cd134<-makeJoyPlot(z,marker="Cell_CD134") 
      pdl2<-makeJoyPlot(z,marker="Cell_PDL2") 
     pp<-makeJoyPlot(z,marker="Cell_p")
 

  draw(bcl2+bcl6+cd20+cd206+CD3+rois)
  draw(CD31+CD4+CD45RA+cd45ro+cd68+cd8+rois)
 # savePlot(file="patient.zscores.expression.png")
 draw(foxp3+hladr+ccr4+cxcr3+granz+rois)
  draw(icos+ki+lag+pd1+pdl1+tim3+rois)
  #savePlot(file="patient.zscores.expression2.png")
  draw(vista+vimentin+eph+cc+rois)
  draw(cd134+pdl2+pp+rois)
   # savePlot(file="patient.zscores.expression3.png")



 ### Heatmap the sub-clusters and the clinical associations.

   X<-z[,c(1:31,which(colnames(z)=='unsup.subcommunity'))]%>%group_by(unsup.subcommunity)%>%summarise_all(funs(mean))%>%data.frame
   colnames(X)<-gsub("Cell_","",colnames(X))
  X$unsup.subcommunity<-droplevels(X$unsup.subcommunity)
 colnames(X)[which(colnames(X)=='C')]<-'cMYC'
 colnames(X)[which(colnames(X)=='p')]<-'pSTAT3'
 colnames(X)[which(colnames(X)=='Tim3')]<-'TIM-3'
 colnames(X)[which(colnames(X)=='Vista')]<-'VISTA'
  colnames(X)[which(colnames(X)=='PDL1')]<-'PD-L1'
   colnames(X)[which(colnames(X)=='PD1')]<-'PD-1'
   colnames(X)[which(colnames(X)=='PDL2')]<-'PD-L2'
  colnames(X)[which(colnames(X)=='Lag3')]<-'LAG-3'

  require(dendsort);require(pvclust)
  rpt.pv<-pvclust(log(1+X[,-1]),nboot=100,method.hclust="average")
  rpt.dend<-dendsort(hclust(dist(log(1+X[,c(-1)]))),isReverse=TRUE)
  library(ComplexHeatmap);library(dendextend)

 ## uses the full panel and the unsupervised community
   phenoColors<-getPhenoColors(full.dn4)
  heats<-Heatmap(X[,c(-1)],
                 cluster_rows=rpt.dend,
                cluster_columns=rpt.pv$hclust,
 name="Measurement mean",
rect_gp = gpar(col = "white", lwd = 1))

    rpt.dend=color_branches(rpt.dend,k=37,
	col=phenoColors[as.character(X$unsup.subcommunity[row_order(heats)])])
  ###need to set rownames.  
    rownames(X)<-X$unsup.subcommunity

  

  ### annotation row for COO.
 txb.df<-data.frame(Phenotype=X$unsup.subcommunity)
 txb.sel.col=list(Phenotype=phenoColors[match(levels(X$unsup.subcommunity),names(phenoColors))])
   myid<-which(txb.df[,1]%in%c("Macrophage_1","TREG_2","TREG_6","Tumor_6"))
   mylab<-txb.df[myid,1]
   
 rowAnn <- rowAnnotation(df=txb.df, 
	col=txb.sel.col,
	 annotation_width=unit(c(1, 3), "cm"), 
	gap=unit(1, "mm"),annotation_legend_param=list(Phenotype=list(ncol=3,title_position="topcenter")))

 ##FIX The row annotation need to be included to the heatmap to have the row labeling.
  heats<-Heatmap(as.matrix(X[,c(-1)]),
                  cluster_rows=rpt.dend,
                  cluster_columns=rpt.pv$hclust,
		name="Measurement mean",
		right_annotation = rowAnn,
		rect_gp = gpar(col = "white", lwd = 1))
 
 
 
 
# rowAnnLabeled <- HeatmapAnnotation(df=txb.df,which="row", 
#	col=txb.sel.col,
#	 annotation_width=unit(c(1, 4), "cm"), 
#	gap=unit(1, "mm"),annotation_legend_param=list(Phenotype=list(ncol=3,title_position="topcenter")))

	#link = anno_mark(at =seq(1,nrow(txb.df)) ,
   #     labels = as.character(txb.df[,1])))
 # heats+rowAnnLabeled
   #savePlot(file="Figure1.subCommunity.clinical.mutations.Labeled.png")

 ###updating the mutational profile in the Figure 1 plot.
 #############
 clustSize<-as.data.frame(table(full.dn4$unsup.subcommunity))
  rownames(clustSize)<-clustSize$Var1
 clustSize<-clustSize[match(X$unsup.subcommunity,clustSize$Var1),]
  #clustSize<-clustSize[row_order(heats),]
  #rownames(clustSize)<-clustSize[,"Var1"]
  clustSize<-data.frame(clustSize[,-1],row.names=rownames(clustSize))

   ## annotation bar plot of cluster size.
  size<-rowAnnotation("Cluster size" = anno_barplot(clustSize,
	 gp = gpar(fill = phenoColors[match(levels(X$unsup.subcommunity),names(phenoColors))]), 
    axis_param = list(direction = "reverse"), border=FALSE,
    bar_width = 1, width = unit(2, "cm")))
 
 clusterHeat<- size+heats
 
   save(clusterHeat,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-figure-revision/Final-figures-Tucker/Figure2/clusterHeatmap.RData")

 clusterHeat
```


### ANOVA model at cluster level
- Using the standardized cluster mean intensities, perform an ANOVA on clusters to model the detected significant enrichments.
- cluster level ANOVA, this compares the ANOVA of the sub-phenograph cluster. This is a type of one-way ANOVA across phenograph clusters.

```{r, eval=TRUE,warning=FALSE,message=FALSE}

   zz<- zScorePatientExpression(full.dn4=full.dn4,markers=c(1:31,104:111),ROIID.column=32)
 ### calculate any expression differences across sub-clusters and treatment response.
 
  ## ignore Tumor_11 cluster
   zz<-zz[which(zz$unsup.subcommunity!="Tumor_11"),]

 
  subExpr<-zz%>%group_by(ROIID,unsup.subcommunity)%>%summarise(CXCR3=mean(Cell_CXCR3),
	CCR4=mean(Cell_CCR4),
	BCL2=mean(Cell_BCL2),
	BCL6=mean(Cell_BCL6),
	CD30=mean(Cell_CD30),
	Ki67=mean(Cell_Ki67),
	cMyc=mean(Cell_C),
	PDL1=mean(Cell_PDL1),
	TIM3=mean(Cell_Tim3),
	LAG3=mean(Cell_Lag3),
	PD1=mean(Cell_PD1),
	ICOS=mean(Cell_ICOS),
	Vista=mean(Cell_Vista),
	CD45RO=mean(Cell_CD45RO),
	CD45RA=mean(Cell_CD45RA),
	CD206=mean(Cell_CD206),
	NND.tumor=mean(NND.Tumor),
	HLADR=mean(Cell_HLADR),
	cMYC=mean(Cell_C),
	CD68=mean(Cell_CD68),
	CD206=mean(Cell_CD206),
	EphrinB2=mean(Cell_EphrinB2))%>%data.frame

  subExpr$unsup.subcommunity<-droplevels(subExpr$unsup.subcommunity)

 
	##split the NND by biological distances.	
	subExpr$NND.status<-">25"
	subExpr$NND.status[which(subExpr$NND.tumor<=10)]<-"10"
	subExpr$NND.status[which(subExpr$NND.tumor>10 & subExpr$NND.tumor<=25)]<-"25"

	## add response clinical variables.
	subExpr$case<-full.dn4$case[match(subExpr$ROIID,full.dn4$ROIID)]
	subExpr$response<-full.dn4$response[match(subExpr$case,full.dn4$case)]
	subExpr$treatment<-full.dn4$treatment.status[match(subExpr$case,full.dn4$case)]
	subExpr$COO<-full.dn4$COO[match(subExpr$case,full.dn4$case)]
	##because we are comparing response drop LTF and ND
	#subExpr<-subExpr[which(subExpr$response!='LTF'),]
	
	subExpr$response<-droplevels(subExpr$response)


  
	### model the effect estimates for global trends.
	#lag3.eff<-model.tables(lag3,'effects')
	#cd45ro.eff<-model.tables(cd45ro,'effects')
	#pd1.eff<-model.tables(pd1,'effects')
	#ki67.eff<-model.tables(ki67,'effects')
	#tim3.eff<-model.tables(tim3,'effects')
	#dr.eff<-model.tables(hladr,'effects')

	## global model. more comprehensive.
	####	total levels was 37 without endothelial.
	# Including now endothelial we have 42 cluster levels with endothelial (ignoring Tumor_11)
	# using endothelial we have 42 as total.
	alpha_noint <- rbind(
	grandMean=rep(1,42)/42,
	cd41.vs.mean=ifelse(subExpr[,2]%>%levels=="CD4_1",41,-1)/42,
	cd42.vs.mean=ifelse(subExpr[,2]%>%levels=="CD4_2",41,-1)/42,
	cd43.vs.mean=ifelse(subExpr[,2]%>%levels=="CD4_3",41,-1)/42,
	cd44.vs.mean=ifelse(subExpr[,2]%>%levels=="CD4_4",41,-1)/42,
	cd45.vs.mean=ifelse(subExpr[,2]%>%levels=="CD4_5",41,-1)/42,
	cd46.vs.mean=ifelse(subExpr[,2]%>%levels=="CD4_6",41,-1)/42,
	cd47.vs.mean=ifelse(subExpr[,2]%>%levels=="CD4_7",41,-1)/42,	

	cd81.vs.mean=ifelse(subExpr[,2]%>%levels=="CD8_1",41,-1)/42,
	cd82.vs.mean=ifelse(subExpr[,2]%>%levels=="CD8_2",41,-1)/42,
	cd83.vs.mean=ifelse(subExpr[,2]%>%levels=="CD8_3",41,-1)/42,
	cd84.vs.mean=ifelse(subExpr[,2]%>%levels=="CD8_4",41,-1)/42,
	cd85.vs.mean=ifelse(subExpr[,2]%>%levels=="CD8_5",41,-1)/42,
	cd86.vs.mean=ifelse(subExpr[,2]%>%levels=="CD8_6",41,-1)/42,
	cd87.vs.mean=ifelse(subExpr[,2]%>%levels=="CD8_7",41,-1)/42,
	## 
	t1.vs.mean=ifelse(subExpr[,2]%>%levels=="Tumor_1",41,-1)/42,
	t2.vs.mean=ifelse(subExpr[,2]%>%levels=="Tumor_2",41,-1)/42,
	t3.vs.mean=ifelse(subExpr[,2]%>%levels=="Tumor_3",41,-1)/42,
	t4.vs.mean=ifelse(subExpr[,2]%>%levels=="Tumor_4",41,-1)/42,
	t5.vs.mean=ifelse(subExpr[,2]%>%levels=="Tumor_5",41,-1)/42,
	t6.vs.mean=ifelse(subExpr[,2]%>%levels=="Tumor_6",41,-1)/42,
	t7.vs.mean=ifelse(subExpr[,2]%>%levels=="Tumor_7",41,-1)/42,
	t8.vs.mean=ifelse(subExpr[,2]%>%levels=="Tumor_8",41,-1)/42,
	t9.vs.mean=ifelse(subExpr[,2]%>%levels=="Tumor_9",41,-1)/42,
	t10.vs.mean=ifelse(subExpr[,2]%>%levels=="Tumor_10",41,-1)/42,

	treg1.vs.mean=ifelse(subExpr[,2]%>%levels=="TREG_1",41,-1)/42,
	treg2.vs.mean=ifelse(subExpr[,2]%>%levels=="TREG_2",41,-1)/42,
	treg3.vs.mean=ifelse(subExpr[,2]%>%levels=="TREG_3",41,-1)/42,
	treg4.vs.mean=ifelse(subExpr[,2]%>%levels=="TREG_4",41,-1)/42,
	treg5.vs.mean=ifelse(subExpr[,2]%>%levels=="TREG_5",41,-1)/42,
	treg6.vs.mean=ifelse(subExpr[,2]%>%levels=="TREG_6",41,-1)/42,
	
	mac1.vs.mean=ifelse(subExpr[,2]%>%levels=="Macrophage_1",41,-1)/42,
	mac2.vs.mean=ifelse(subExpr[,2]%>%levels=="Macrophage_2",41,-1)/42,
	mac3.vs.mean=ifelse(subExpr[,2]%>%levels=="Macrophage_3",41,-1)/42,
	mac4.vs.mean=ifelse(subExpr[,2]%>%levels=="Macrophage_4",41,-1)/42,
	mac5.vs.mean=ifelse(subExpr[,2]%>%levels=="Macrophage_5",41,-1)/42,
	mac6.vs.mean=ifelse(subExpr[,2]%>%levels=="Macrophage_6",41,-1)/42,
	
	end1.vs.mean=ifelse(subExpr[,2]%>%levels=="Endothelial_1",41,-1)/42,
	end2.vs.mean=ifelse(subExpr[,2]%>%levels=="Endothelial_2",41,-1)/42,
	end3.vs.mean=ifelse(subExpr[,2]%>%levels=="Endothelial_3",41,-1)/42,
	end4.vs.mean=ifelse(subExpr[,2]%>%levels=="Endothelial_4",41,-1)/42,
	end5.vs.mean=ifelse(subExpr[,2]%>%levels=="Endothelial_5",41,-1)/42,
	end6.vs.mean=ifelse(subExpr[,2]%>%levels=="Endothelial_6",41,-1)/42
	   )

   library(multcomp);library(lme4)
	tim3.global <- lmer(TIM3 ~ 0+unsup.subcommunity +(1|case), data = subExpr)
	lag3.global <- lmer(LAG3 ~ 0+unsup.subcommunity +(1|case), data = subExpr)
	pd1.global <- lmer(PD1 ~ 0+unsup.subcommunity +(1|case), data = subExpr)
	cxcr3.global <- lmer(CXCR3 ~ 0+unsup.subcommunity +(1|case), data = subExpr)
	ccr4.global <- lmer(CCR4 ~ 0+unsup.subcommunity +(1|case), data = subExpr)
	hladr.global <- lmer(HLADR ~ 0+unsup.subcommunity +(1|case), data = subExpr)
	pdl1.global <- lmer(PDL1 ~ 0+unsup.subcommunity +(1|case), data = subExpr)
	icos.global <- lmer(ICOS ~ 0+unsup.subcommunity +(1|case), data = subExpr)
	ki67.global <- lmer(Ki67 ~ 0+unsup.subcommunity +(1|case), data = subExpr)
	vista.global <- lmer(Vista ~ 0+unsup.subcommunity +(1|case), data = subExpr)
	bcl6.global <- lmer(BCL6 ~ 0+unsup.subcommunity +(1|case), data = subExpr)
	bcl2.global <- lmer(BCL2 ~ 0+unsup.subcommunity +(1|case), data = subExpr)
	cd206.global <- lmer(CD206 ~ 0+unsup.subcommunity +(1|case), data = subExpr)
	cd45ro.global <- lmer(CD45RO ~ 0+unsup.subcommunity +(1|case), data = subExpr)
	cd45ra.global <- lmer(CD45RA ~ 0+unsup.subcommunity +(1|case), data = subExpr)
 cd68.global <- lmer(CD68 ~ 0+unsup.subcommunity +(1|case), data = subExpr)
 cmyc.global <- lmer(cMYC ~ 0+unsup.subcommunity +(1|case), data = subExpr)
 ephr.global <- lmer(EphrinB2 ~ 0+unsup.subcommunity +(1|case), data = subExpr)

	##TIM3
  tim3.global <- glht(tim3.global, linfct=alpha_noint)
  tim3.global.ci<-confint(tim3.global, calpha=univariate_calpha())
  tim3.global.ci<- tim3.global.ci$confint%>%data.frame
	tim3.global.ci$marker<-'TIM3'
	 xx<-tim3.global%>%summary
  tim3.global.ci$pvalues<-xx$test$pvalues
	##ki67
	 ki.global <- glht(ki67.global, linfct=alpha_noint)
 	 ki.global.ci<-confint(ki.global, calpha=univariate_calpha())
  	ki.global.ci<- ki.global.ci$confint%>%data.frame
	ki.global.ci$marker<-'Ki67'
 	  xx<-ki.global%>%summary
	ki.global.ci$pvalues<-xx$test$pvalues

	# PD1
	 pd1.global <- glht(pd1.global, linfct=alpha_noint)
 	 pd1.global.ci<-confint(pd1.global, calpha=univariate_calpha())
  	pd1.global.ci<- pd1.global.ci$confint%>%data.frame
	pd1.global.ci$marker<-'PD1'
 	 xx<-pd1.global%>%summary
	pd1.global.ci$pvalues<-xx$test$pvalues

	##Lag3
	 lag3.global <- glht(lag3.global, linfct=alpha_noint)
 	 lag3.global.ci<-confint(lag3.global, calpha=univariate_calpha())
  	lag3.global.ci<- lag3.global.ci$confint%>%data.frame
	lag3.global.ci$marker<-'LAG3'
 	 xx<-lag3.global%>%summary
	lag3.global.ci$pvalues<-xx$test$pvalues

	## CXCR3
	 cxcr3.global <- glht(cxcr3.global, linfct=alpha_noint)
 	 cxcr3.global.ci<-confint(cxcr3.global, calpha=univariate_calpha())
  	cxcr3.global.ci<- cxcr3.global.ci$confint%>%data.frame
	cxcr3.global.ci$marker<-'CXCR3'
	 xx<-cxcr3.global%>%summary
	cxcr3.global.ci$pvalues<-xx$test$pvalues

	## CCR4
	 ccr4.global <- glht(ccr4.global, linfct=alpha_noint)
 	 ccr4.global.ci<-confint(ccr4.global, calpha=univariate_calpha())
  	ccr4.global.ci<- ccr4.global.ci$confint%>%data.frame
	ccr4.global.ci$marker<-'CCR4'
  	xx<-ccr4.global%>%summary
	ccr4.global.ci$pvalues<-xx$test$pvalues
	## PDL1
	 pdl1.global <- glht(pdl1.global, linfct=alpha_noint)
 	 pdl1.global.ci<-confint(pdl1.global, calpha=univariate_calpha())
  	pdl1.global.ci<- pdl1.global.ci$confint%>%data.frame
	pdl1.global.ci$marker<-'PDL1'
	 xx<-pdl1.global%>%summary
	pdl1.global.ci$pvalues<-xx$test$pvalues

 	##HLADR
	 hladr.global <- glht(hladr.global, linfct=alpha_noint)
 	 hladr.global.ci<-confint(hladr.global, calpha=univariate_calpha())
  	hladr.global.ci<- hladr.global.ci$confint%>%data.frame
	hladr.global.ci$marker<-'HLADR'
	 xx<-hladr.global%>%summary
	hladr.global.ci$pvalues<-xx$test$pvalues

	##BCL6
	 bcl6.global <- glht(bcl6.global, linfct=alpha_noint)
 	 bcl6.global.ci<-confint(bcl6.global, calpha=univariate_calpha())
  	bcl6.global.ci<- bcl6.global.ci$confint%>%data.frame
	bcl6.global.ci$marker<-'BCL6'
	 xx<-bcl6.global%>%summary
	bcl6.global.ci$pvalues<-xx$test$pvalues

	##BCL2
	 bcl2.global <- glht(bcl2.global, linfct=alpha_noint)
 	 bcl2.global.ci<-confint(bcl2.global, calpha=univariate_calpha())
  	bcl2.global.ci<- bcl2.global.ci$confint%>%data.frame
	bcl2.global.ci$marker<-'BCL2'
	 xx<-bcl2.global%>%summary
	bcl2.global.ci$pvalues<-xx$test$pvalues

	##ICOS	
	 icos.global <- glht(icos.global, linfct=alpha_noint)
 	 icos.global.ci<-confint(icos.global, calpha=univariate_calpha())
  	icos.global.ci<- icos.global.ci$confint%>%data.frame
	icos.global.ci$marker<-'ICOS'
	 xx<-icos.global%>%summary
	icos.global.ci$pvalues<-xx$test$pvalues

	##CD206
	 cd206.global <- glht(cd206.global, linfct=alpha_noint)
 	 cd206.global.ci<-confint(cd206.global, calpha=univariate_calpha())
  	cd206.global.ci<- cd206.global.ci$confint%>%data.frame
	cd206.global.ci$marker<-'CD206'
	 xx<-cd206.global%>%summary
	cd206.global.ci$pvalues<-xx$test$pvalues

	##vista
	 vista.global <- glht(vista.global, linfct=alpha_noint)
 	 vista.global.ci<-confint(vista.global, calpha=univariate_calpha())
  	vista.global.ci<- vista.global.ci$confint%>%data.frame
	vista.global.ci$marker<-'vista'
	 xx<-vista.global%>%summary
	vista.global.ci$pvalues<-xx$test$pvalues

	## CD45RO
	 cd45ro.global <- glht(cd45ro.global, linfct=alpha_noint)
 	 cd45ro.global.ci<-confint(cd45ro.global, calpha=univariate_calpha())
  	cd45ro.global.ci<- cd45ro.global.ci$confint%>%data.frame
	cd45ro.global.ci$marker<-'CD45RO'
	 xx<-cd45ro.global%>%summary
	cd45ro.global.ci$pvalues<-xx$test$pvalues

	## CD45RA
	 cd45ra.global <- glht(cd45ra.global, linfct=alpha_noint)
 	 cd45ra.global.ci<-confint(cd45ra.global, calpha=univariate_calpha())
  	cd45ra.global.ci<- cd45ra.global.ci$confint%>%data.frame
	cd45ra.global.ci$marker<-'CD45RA'
	 xx<-cd45ra.global%>%summary
	cd45ra.global.ci$pvalues<-xx$test$pvalues
 	
	## cMYC
	 cmyc.global <- glht(cmyc.global, linfct=alpha_noint)
 	 cmyc.global.ci<-confint(cmyc.global, calpha=univariate_calpha())
  	cmyc.global.ci<- cmyc.global.ci$confint%>%data.frame
	cmyc.global.ci$marker<-'cMYC'
	 xx<-cmyc.global%>%summary
	cmyc.global.ci$pvalues<-xx$test$pvalues
	
	 ephrin.global <- glht(ephr.global, linfct=alpha_noint)
 	 ephrin.global.ci<-confint(ephrin.global, calpha=univariate_calpha())
  	ephrin.global.ci<- ephrin.global.ci$confint%>%data.frame
	ephrin.global.ci$marker<-'EphrinB2'
	 xx<-ephrin.global%>%summary
	ephrin.global.ci$pvalues<-xx$test$pvalues
	

	globalExpr<-rbind(tim3.global.ci,
	ki.global.ci,
	pd1.global.ci,
	lag3.global.ci,
	cxcr3.global.ci,
	ccr4.global.ci,
	pdl1.global.ci,	
	hladr.global.ci,
	bcl6.global.ci,
	bcl2.global.ci,
	icos.global.ci,
	cd206.global.ci,
	vista.global.ci,
	cd45ro.global.ci,
	cd45ra.global.ci,
	cmyc.global.ci,
	ephrin.global.ci)

	globalExpr$pheno<-sapply(strsplit(rownames(globalExpr),"\\."),function(x) x[1])


	
 	
	## use a SL regression on the 9p24 status and PDL1 on tumor.
	x9p24<-zz[which(zz$subType.correction=='Tumor'),]%>%group_by(case,unsup.subcommunity,X9p24.Status)%>%summarise(PDL1=mean(Cell_PDL1))%>%data.frame
	
x9p24$X9p24.Status<-factor(x9p24$X9p24.Status,levels=c("Normal","Gain","Loss"))
	 lm(PDL1~X9p24.Status,x9p24[grepl("Tumor_",x9p24[,2]),])%>%summary

  write.csv(globalExpr,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-model-worksheets/ExpressionANOVA.Table.csv")

```



### Adding the annotations to Figure 2A based on Akil's suggestion 5-2- revision
- add custom row labels to each phenotype showing cluster and labeled name.
- REVISION 5-2: we add the cluster labels to the names for back-tracking the names.
- REVISION 8-29: the labels are abbreviated, and match the level orderings for color.

```{r}

 


### REVISION 5-2: Annotate cluster to cell populations 


 ## need to add labels.
  label<-full.dn4$unsup.subcommunity%>%levels%>%data.frame
 colnames(label)<-'cluster'
  label$label<-'none'
 ## CD4 labels.
  label$label[which(label$cluster=='CD4_1')]<-'Exh./Inflam.CD4(1,5)'
  label$label[which(label$cluster=='CD4_2')]<-"Act./Early/Exh.CD4(2,3,7)"
  label$label[which(label$cluster=='CD4_3')]<-'Act./Early/Exh.CD4(2,3,7)'
   label$label[which(label$cluster=='CD4_4')]<-'Baseline CD4(4)'
   label$label[which(label$cluster=='CD4_5')]<-'Exh./Inflam.CD4(1,5)'
   label$label[which(label$cluster=='CD4_6')]<-'Act./Prolif.CD4(6)'
    label$label[which(label$cluster=='CD4_7')]<-'Act./Early/Exh.CD4(2,3,7)'

 ## CD8 labels.
      label$label[which(label$cluster=='CD8_1')]<-'Act./Prolif.CD8(1,4)'
      label$label[which(label$cluster=='CD8_2')]<-'Exh./Inflam.CD8(2,6)'
      label$label[which(label$cluster=='CD8_3')]<-'Terminal Exhaust.CD8(3,5)'
      label$label[which(label$cluster=='CD8_4')]<-'Act./Prolif.CD8(1,4)'
      label$label[which(label$cluster=='CD8_5')]<-'Terminal Exhaust.CD8(3,5)'
      label$label[which(label$cluster=='CD8_6')]<-'Exh./Inflam.CD8(2,6)'
      label$label[which(label$cluster=='CD8_7')]<-'Baseline CD8(7)'
 ##exhausted
 
 ## MAC
	 label$label[which(label$cluster=='Macrophage_1')]<-'M2-MAC(1,5,6)'
        label$label[which(label$cluster=='Macrophage_2')]<-'PD-L1+M2-MAC(2)'
        label$label[which(label$cluster=='Macrophage_3')]<-'M1-MAC(3,4)'	
	 label$label[which(label$cluster=='Macrophage_4')]<-'M1-MAC(3,4)'	
        label$label[which(label$cluster=='Macrophage_5')]<-'M2-MAC(1,5,6)'
	 label$label[which(label$cluster=='Macrophage_6')]<-'M2-MAC(1,5,6)'	

 ## TREG.
 	 label$label[which(label$cluster=='TREG_1')]<-'Hi.Suppress.T-reg(1,2,6)'
 	 label$label[which(label$cluster=='TREG_2')]<-'Hi.Suppress.T-reg(1,2,6)'
 	 label$label[which(label$cluster=='TREG_3')]<-'Baseline T-reg(3,4)'
 	 label$label[which(label$cluster=='TREG_4')]<-'Baseline T-reg(3,4)'
	 label$label[which(label$cluster=='TREG_5')]<-'Act./Prolif.T-reg(5)'
 	 label$label[which(label$cluster=='TREG_6')]<-'Hi.Suppress.T-reg(1,2,6)'

 ##ENDO
	label$label[which(label$cluster=='Endothelial_1')]<-'EphrinB2+Endothelial(1)'
	label$label[which(label$cluster=='Endothelial_2')]<-'Prolif.Endothelial(2)'
	label$label[which(label$cluster=='Endothelial_3')]<-'Act.Endothelial(3,6)'
	label$label[which(label$cluster=='Endothelial_4')]<-'PD-L1+Endothelial(4)'
	label$label[which(label$cluster=='Endothelial_5')]<-'Baseline Endothelial(5)'
	label$label[which(label$cluster=='Endothelial_6')]<-'Act.Endothelial(3,6)'

 

 ## Tumor
 ## t1:CXCR3-mid, BCL2+
 ##t2: CD20+ B-cell
 #t3: BCL2+
 # t4: Ki67+, BCL6+
 # t5: Ki67+, BCL6+
 
 #t6: PD-1-moderate, Ki67+, BCL6+, BCL2+
 #t7:CD20+ B-cell
 #t8: CD20+ B-cell
 #t9: Ki67+
 #t10: Ki67+, BCL2+,BCL6+
 ## labels
   label$label[which(label$cluster=='Tumor_1')]<-'Non-Inflam. B-Cell tumor(1-5,7,9)'
   label$label[which(label$cluster=='Tumor_2')]<-'Non-Inflam. B-Cell tumor(1-5,7,9)'
   label$label[which(label$cluster=='Tumor_3')]<-'Non-Inflam. B-Cell tumor(1-5,7,9)'
   label$label[which(label$cluster=='Tumor_4')]<-'Non-Inflam. B-Cell tumor(1-5,7,9)'
   label$label[which(label$cluster=='Tumor_5')]<-'Non-Inflam. B-Cell tumor(1-5,7,9)'
   label$label[which(label$cluster=='Tumor_6')]<-'Inflammatory B-Cell tumor(6,8,10)'
   label$label[which(label$cluster=='Tumor_7')]<-'Non-Inflam. B-Cell tumor(1-5,7,9)'
   label$label[which(label$cluster=='Tumor_8')]<-'Inflammatory B-Cell tumor(6,8,10)'
   label$label[which(label$cluster=='Tumor_9')]<-'Non-Inflam. B-Cell tumor(1-5,7,9)'
   label$label[which(label$cluster=='Tumor_10')]<-'Inflammatory B-Cell tumor(6,8,10)'
      label$label[which(label$cluster=='Tumor_11')]<-'none(11)'



 label$easyLabel<-c("Late_Exhausted_CD4",
	"Act_Exh_early_CD4",
	"Act_Exh_early_CD4",
	"Baseline_CD4",
	"Late_Exhausted_CD4",
	"Act_prol_CD4",
	"Act_Exh_early_CD4",
	
	"Act_prol_CD8",
	"Exh_Inflam_CD8",
	"Term_Exh_CD8",
	"Act_prol_CD8",
	"Term_Exh_CD8",
	"Exh_Inflam_CD8",
	"Baseline_CD8",
	
	"M2MAC",
	"PDL1M2MAC",
	"M1MAC",
	"M1MAC",
	"M2MAC",
	"M2MAC",
	
	"Hi_Supp_TREG",
	"Hi_Supp_TREG",
	"Baseline_TREG",
	"Baseline_TREG",
	"Act_prol_TREG",
	"Hi_Supp_TREG",
	
	"Tumor",
	"Tumor",
	"Tumor",
	"Tumor",
	"Tumor",
	"InflamTumor",
	"Tumor",
	"InflamTumor",
	"Tumor",
	"InflamTumor",
	'none',
	"EphrinB2_Endothelial",
	"Ki67_Endothelial",
	"Activ_Endothelial",
	"PDL1_Endothelial",
	"Baseline_Endothelial",
	"Activ_Endothelial"	)
	

 ## REVISION: 5-2 we add the 'mapped-back' label with cluster names to the full.dn4 data-set.
 full.dn4$annotated.label.back_akil<-NA
 full.dn4$annotated.label.back_akil<-label$label[match(full.dn4$unsup.subcommunity,label$cluster)]
 
 #full.dn4$annotated.label<-NA
 #full.dn4$annotated.label<-label$label[match(full.dn4$unsup.subcommunity,label$cluster)]
 
 
 ## simple label
 full.dn4$annotated.label.simple_akil<-NA
 full.dn4$annotated.label.simple_akil<-label$easyLabel[match(full.dn4$unsup.subcommunity,label$cluster)]

 ##order factors.
# full.dn4$annotated.label<-factor(full.dn4$annotated.label,levels=c("CD45RA+ exhausted CD4","CD45RA- exhausted CD4","Ki67+ memory CD4","Memory CD4","CD45RA+ CD4","CD8","Exhausted CD8","Ki67+ CD8","Endothelial","Ki67+ M1-Macrophage","M1-Macrophage","M2-Macrophage","PD-L1+ M2-Macrophage","Highly suppressive T-reg","Ki67+ T-reg","T-reg","B-Cell tumor","PDL1+ B-Cell tumor"))

 
 	 

 
 full.dn4$annotated.label.back_akil<-factor(full.dn4$annotated.label.back_akil,levels=c("Exh./Inflam.CD4(1,5)",
                                                                         "Act./Early/Exh.CD4(2,3,7)",
                                                                         "Baseline CD4(4)",
                                                                         "Act./Prolif.CD4(6)",
                                                                         
                                                                         "Baseline CD8(7)",
                                                                         "Act./Prolif.CD8(1,4)",
                                                                         "Exh./Inflam.CD8(2,6)",
                                                                         "Terminal Exhaust.CD8(3,5)",
                                                                         
                                                                         "M1-MAC(3,4)",
                                                                         "M2-MAC(1,5,6)",
                                                                         "PD-L1+M2-MAC(2)",
                                                                         
                                                                         "Hi.Suppress.T-reg(1,2,6)",
                                                                         "Act./Prolif.T-reg(5)",
                                                                         "Baseline T-reg(3,4)",
                                                                         
                                                                         "Non-Inflam. B-Cell tumor(1-5,7,9)",
                                                                         "Inflammatory B-Cell tumor(6,8,10)",
                                                                         'none(11)',
                                                                          "EphrinB2+Endothelial(1)",
                                                                         "Prolif.Endothelial(2)",
                                                                         "Act.Endothelial(3,6)",
                                                                         "PD-L1+Endothelial(4)",
                                                                         "Baseline Endothelial(5)"
                                                                         ))
 
 print(label)

##labels are updated to match Dr. Merchant's labeling clusters.
 label$subcluster<-c("Exh./Inflam.",
                     "Act./Early/Exh.",
                     "Act./Early/Exh.",
                     "Baseline",
                     "Exh./Inflam.",
                     "Act./Prolif.",
                     "Act./Early/Exh.",
                     
                      "Act./Prolif.",
                     "Exh./Inflam.", 
                     "Terminal Exhaust.",
                      "Act./Prolif.",
                     "Terminal Exhaust.",
                     "Exh./Inflam.",
                     "Baseline",
                     
                     "M2",
                     "PD-L1+ M2",
                     "M1",
                     "M1",
                     "M2",
                     "M2",
                     
                     "Hi Suppr.",
                     "Hi Suppr.",
                     "Baseline",
                     "Baseline",
                       "Act./Prolif.",
                     "Hi Suppr.",
                     
                     "Non-Inflam.",
                      "Non-Inflam.",
                      "Non-Inflam.",
                      "Non-Inflam.",
                      "Non-Inflam.",
                     "Inflam.",
                      "Non-Inflam.",
                      "Inflam.",
                      "Non-Inflam.",
                     "Inflam.",
                       "none",
                     "EphrinB2+",
                     "Prolif.",
                     "Act.",
                     "PD-L1+",
                     "Baseline",
                     "Act."
                       )
 
 label$subcluster_annotated<-paste0(label$cluster,"(",label$subcluster,")")
 ##need to create a heatmap with the labels appended 5-2.
 full.dn4$subcluster_annotated<-'none'
 full.dn4$subcluster_annotated<-label$subcluster_annotated[match(full.dn4$unsup.subcommunity,label$cluster)]

 full.dn4$subcluster_annotated<-factor(full.dn4$subcluster_annotated,
                                       levels=label$subcluster_annotated
 )
 
table(full.dn4$annotated.label.back_akil%>%is.na) 
table(full.dn4$subcluster_annotated%>%is.na)
```




### Create a FlowFrame of the data and the updated phenotypes with the design (Revision 5-18)
- create an IMC experiment (SummarizedExperiment) in order to generate a FlowSet for diffCyt usage.
- the goal of this analysis is to use the full clinical features to derive a linear model to show changes in the TME related to HANS, refractory response, and chapuy clusters.  The spatial clusters in the last figure should use a classification AUC/ROC comparison to show the "best" classification hopefully the spatial domains show an improved classification compared to clinical parameters, and compared to chapuy. the figure 2 TME and Figure 3 HANS/COO and treatment response should all be done using a linear model. the spatial domains in the figure 6 can be a classification comparison using 5-fold- CV.
- we subset out the ND patients.

```{r flowFrame}
 library(CATALYST)
library(cowplot)
library(flowCore)
library(ggplot2)
library(SingleCellExperiment)
library(diffcyt)
library(imcExperiment)
 library(gridExtra)
 library(magrittr);library(dplyr)


 
##subset out ND only treated.
#full.dn4<-full.dn4[which(full.dn4$treatment.status!='ND'),]
 
ndROI<-full.dn4$ROIID[which(full.dn4$treatment.status=='ND')]%>%unique()
treatROI<-full.dn4$ROIID[which(full.dn4$treatment.status!='ND')]%>%unique()




##proteins that are Min/Max normalized.
  expr<-full.dn4[,1:31]
  normExp<-as.matrix(expr)

  
  ##spatial component
  spatial<-(full.dn4[,c("X_position","Y_position")])
  spatial<-as.matrix(spatial)
 ##uniqueLabel
  uniqueLabel<-full.dn4$uniqueLabel
  ## Akil labeled phenotypes.
  phenotypes<-(as.data.frame(factor(full.dn4$annotated.label.simple_akil)))
  ROIID=data.frame(ROIID=full.dn4[,"ROIID"])
  morph<-full.dn4[,c("Area",
                    "Eccentricity",
	"Solidity",
	"Perimeter")]
  
  colnames(normExp)<-gsub("Cell_","",colnames(normExp))
  colnames(normExp)[which(colnames(normExp)=="p")]<-"pSTAT3"
    colnames(normExp)[which(colnames(normExp)=="C")]<-"cMYC"

  
  x<-imcExperiment(cellIntensity=t(normExp),
	coordinates=spatial,
	neighborHood=as.matrix(full.dn4[,"Number_Neighbors"]),
	network=phenotypes,
	distance=matrix(1,nrow=nrow(full.dn4),ncol=10),
	morphology=morph,
	panel=colnames(normExp),
	uniqueLabel=uniqueLabel,
	ROIID=ROIID)
   x
   
   
  ## SCE
   
   
imcData<-x
### DiffCyt.
  is(assay(imcData,'counts'),'matrix')
  rownames(imcData)
    # for plot scatter to work need to set the rowData feature in a specific way.
  channel<-c("Nd146",
             "Sm147",
             "Dy161",
             "Tm169",
             "Er170",
             "Ho165",
             "Nd144",
             "Gd156",
             "Gd155",
             "Yb173",
             "Tb159",
             "Dy162",
             "Er166",
             "Dy163",
             "Yb174",
             "Dy164",
             "Sm149",
             "Eu151",
             "Nd142",
             "Er167",
             "N148",
             "Er168",
             "Eu153",
             "Lu175",
             "Nd150",
             "Yb172",
             "Nd145",
             "Sm154",
             "Nd143",
             "Dy160",
             "Gd158")
          
   ##remove the "Cell_" tag from the data naming.   
     marker<-rownames(x)

  
   channel.markers<-DataFrame(channel_name=channel, marker_name=marker)
     
   
    rowData(imcData)<-DataFrame(channel_name=channel,marker_name=marker)
    rownames(imcData)<-marker
    plotScatter(imcData,rownames(imcData)[17:18],assay='counts')

          
            
            
              # convert to flowSet
             ## the warning has to do with duplicated Iridium channels.
   table(colData(imcData)$ROIID)
       (fsimc <- sce2fcs(imcData, split_by = "ROIID"))
    ## now we have a flowSet.
   pData(fsimc)
   fsApply(fsimc,nrow)
   dim(exprs(fsimc[[1]]))
   exprs(fsimc[[1]])[1:5,1:5]
    ## set up the metadata files.
  marker_info<-data.frame(channel_name=channel,
              marker_name=marker,
              marker_class=c(rep("type",14),
                             rep("state",17)))
                             

 pData(fsimc)$sample_id<-sapply(strsplit(pData(fsimc)$name,"_"),function(x) x[2])
 ##need the experimental information containing, HANS, C1-C5
 
  ##CHAPUY REVISION : 10-15 extending all the chapuy mutations.
  c1<-c("BCL6","BCL10","TNFAIP3","UBE2A","CD70","B2M","NOTCH2","TMEM30A","FAS","TP63","ZEB2","HLAB","SPEN","PDL1")
  c1.rank<-c(1,2,3,4,5,6,7,8,9,11,12,13,14,15)
  c1.dataFrame<-data.frame(gene=c1,Rank=c1.rank,cluster='C1',contained=FALSE)
  c2<-c("TP53")
  c2.rank<-1
  c2.dataFrame<-data.frame(gene=c2,Rank=c2.rank,cluster='C2',contained=FALSE)

  c3<-c("BCL2","CREBBP","EZH2","KMT2D","TNFRSF14","HVCN1","IRF8","GNA13","MEF2B","PTEN")
  c3.rank<-c(seq(1,length(c3)))
  c3.dataFrame<-data.frame(gene=c3,Rank=c3.rank,cluster='C3',contained=FALSE)

  c4<-c("SGK1","HIST1H1E","NFKBIE","BRAF","CD83","NFKBIA","CD58","HIST1H2BC","STAT3","HIST1H1C","ZFP36L1","KLHL6","HIST1H1D","HIST1H1B","ETS1","TOX","HIST1H2AM","HIST1H2BK","RHOA","ACTB","LTB","SF3B1","CARD11","HIST1H2AC")
  c4.rank<-seq(1,length(c4))
    c4.dataFrame<-data.frame(gene=c4,Rank=c4.rank,cluster='C4',contained=FALSE)

  c5<-c("CD79B","MYD88","ETV6","PIM1","TBL1XR1","GRHPR","ZC3H12A","HLAA","PRDM1","BTG1")
  c5.rank<-c(3,5,6,8,10,12,13,16,17,18)
    c5.dataFrame<-data.frame(gene=c5,Rank=c5.rank,cluster='C5',contained=FALSE)

    
##read in the mutational data.    
     clinic<-mutationClinicalSheetAssembly(mutationsToGather=c(c1,c2,c3,c4,c5),full.dn4=full.dn4)
      any(clinic$Run.ID%in%ndROI)
  
  ## Table for which mutations were found or not found.
   #  mutations<-read.csv("~/Documents/imageAnalysis/DLBCL/monirath/myData/mutational-genomic-table/TMA CGI genomic data.csv",header=TRUE)
mutations<-read.csv("~/IMC-Ranalysis/DLBCL/monirath/myData/mutational-genomic-table/TMA CGI genomic data.csv")
  
c1.dataFrame[c1.dataFrame$gene%in%unique(mutations[,8]),'contained']<-TRUE
c2.dataFrame[c2.dataFrame$gene%in%unique(mutations[,8]),'contained']<-TRUE
c3.dataFrame[c3.dataFrame$gene%in%unique(mutations[,8]),'contained']<-TRUE
c4.dataFrame[c4.dataFrame$gene%in%unique(mutations[,8]),'contained']<-TRUE
c5.dataFrame[c5.dataFrame$gene%in%unique(mutations[,8]),'contained']<-TRUE
clusterData<-rbind(c1.dataFrame,c2.dataFrame,c3.dataFrame,c4.dataFrame,c5.dataFrame)

   ## REVISION 10-20 hans mutation association with C1-C5.
 ### HANS association with each mutation class logistic regression. 
 clinic$C1.count<-rowSums(clinic[,colnames(clinic)%in%c1])
 clinic$C2.count<-(clinic[,colnames(clinic)%in%c2])
 clinic$C3.count<-rowSums(clinic[,colnames(clinic)%in%c3])
 clinic$C4.count<-rowSums(clinic[,colnames(clinic)%in%c4])
 clinic$C5.count<-rowSums(clinic[,colnames(clinic)%in%c5])
 ##ngcb
 clinic$NGCB.bin<-ifelse(clinic$Cell.of.origin..HANS.=='NGCB',1,0)
 clinic$Case_Number<-as.numeric(substr(clinic$Case_ID,6,7))
##chapuy binary.
  clinic$C1<-ifelse(clinic[,'C1.count']>0,1,0)
  clinic$C2<-ifelse(clinic[,'C2.count']>0,1,0)
  clinic$C3<-ifelse(clinic[,'C3.count']>0,1,0)
  clinic$C4<-ifelse(clinic[,'C4.count']>0,1,0)
  clinic$C5<-ifelse(clinic[,'C5.count']>0,1,0)

  clinic$Treatment.Category[which(clinic$Treatment.Category=="sur+chemo")]<-"SUR+CHEMO"
clinic$X9p24.gain.status[which(is.na(clinic$X9p24.gain.status))]<-0

 clinic<-clinic[match(pData(fsimc)$sample_id,clinic$Run.ID),]

  all(clinic$Run.ID==pData(fsimc)$sample_id)
 
##match the column data of the fsimc 
   exper_info<-data.frame(NGCB=ifelse(clinic$Cell.of.origin..HANS.[match(pData(fsimc)$sample_id,clinic$Run.ID)]=='NGCB',1,0),
                          group_id=clinic$Response.category[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                          C1=clinic$C1[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                          C2=clinic$C2[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                          C3=clinic$C3[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                          C4=clinic$C4[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                          C5=clinic$C5[match(pData(fsimc)$sample_id,clinic$Run.ID)],                                                                  patient_id=clinic$Case_ID[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        highIPI=ifelse(clinic$ipi[match(pData(fsimc)$sample_id,clinic$Run.ID)]>=3,1,0),
                        high9p24.gain=ifelse(clinic$X9p24.gain.status[match(pData(fsimc)$sample_id,clinic$Run.ID)]>1,1,0),
                        highcmyc.category=ifelse(clinic$cmyc.category[match(pData(fsimc)$sample_id,clinic$Run.ID)]>=3,1,0),
                        myc.rearrange=ifelse(clinic$MYC.Rearrange[match(pData(fsimc)$sample_id,clinic$Run.ID)]=="pos",1,0),
                        nonHisp=ifelse(clinic$Ethnicity[match(pData(fsimc)$sample_id,clinic$Run.ID)]!="Hisp",1,0),
                        BCL6=clinic$BCL6[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        BCL2=clinic$BCL2[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        TP53=clinic$TP53[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        SGK1=clinic$SGK1[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        CD79b=clinic$CD79B[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        MYD88L265P=clinic$MYD88.L265P[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        LDH=ifelse(clinic$ldh[match(pData(fsimc)$sample_id,clinic$Run.ID)]=="H",1,0),
                        Gender=ifelse(clinic$Gender[match(pData(fsimc)$sample_id,clinic$Run.ID)]=="M",1,0),
                        AgeHigh=ifelse(clinic$Age[match(pData(fsimc)$sample_id,clinic$Run.ID)]>60,1,0),
                        BurkittLite=ifelse(clinic$Morphologic.variants[match(pData(fsimc)$sample_id,clinic$Run.ID)]!="CB",1,0),
                        FOXP1Score=ifelse(clinic$FOXP1.expression.score[match(pData(fsimc)$sample_id,clinic$Run.ID)]>9,1,0),
                        myc.gain=ifelse(clinic$MYC.Gain[match(pData(fsimc)$sample_id,clinic$Run.ID)]=="pos",1,0),
                        p53=ifelse(clinic$p53[match(pData(fsimc)$sample_id,clinic$Run.ID)]>=2,1,0),
                        SurgeryOnly=ifelse(clinic$Treatment.Category[match(pData(fsimc)$sample_id,clinic$Run.ID)]!="SUR+CHEMO",1,0),
                        ##adding mutation groups?
                        ##C1
                        CD70=clinic$CD70[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        NOTCH2=clinic$NOTCH2[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        #C3
                        CREBBP=clinic$CREBBP[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        EZH2=clinic$EZH2[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        KMT2D=clinic$KMT2D[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        IRF8=clinic$IRF8[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        ##C4
                        HIST1H1E=clinic$HIST1H1E[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        STAT3=clinic$STAT3[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        HIST1H1B=clinic$HIST1H1B[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        ETS1=clinic$ETS1[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        ##C5
                        PIM1=clinic$PIM1[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        TBL1XR1=clinic$TBL1XR1[match(pData(fsimc)$sample_id,clinic$Run.ID)],
                        ##stage and nodal involvement
                        Stage34=ifelse(clinic$Stage_g[match(pData(fsimc)$sample_id,clinic$Run.ID)]=="IV"| clinic$Stage_g[match(pData(fsimc)$sample_id,clinic$Run.ID)]=="III",1,0),
                        NodalInvolve=ifelse(clinic$Extra.nodal.involvement[match(pData(fsimc)$sample_id,clinic$Run.ID)]==">1",1,0),
                        PDL1High.ihc=ifelse(clinic$OVERALL.PD.L1.IHC.SCORE==3 &clinic$RNAScope.PDL1.score..0.4.>1,1,0),
                        X9p24.gain.status=ifelse(clinic$X9p24.gain.status>=2,1,0),
                        doubleExpressor=ifelse(clinic$bcl2==1 & clinic$cmyc.category>=3,1,0),
                                                sample_id=pData(fsimc)$name)


    ### we assign missing phenotypes to the average.
   
    cluster.counts<-as.data.frame.matrix(table(full.dn4$ROIID,full.dn4$annotated.label.simple_akil))
for(j in 1:ncol(cluster.counts)){
  id<-which(cluster.counts[,j]==0)
  id2<-cluster.counts[,j]!=0
  if(length(id)>0){
    cluster.counts[id,j]<-round(mean(cluster.counts[id2,j]))
  }
}
    
  cluster.counts<-100*cluster.counts/rowSums(cluster.counts)  

cluster.counts$Case_ID<-clinic$Case_ID[match(rownames(cluster.counts),clinic$Run.ID)]

   cluster.counts<-left_join(cluster.counts,clinic[!duplicated(clinic$Case_ID),c("Case_ID","Case_Number","C1.count", "C2.count", "C3.count", "C4.count", "C5.count",'ipi','NGCB.bin','Cell.of.origin..HANS.','Response.category')],by='Case_ID')
cluster.counts$C1<-ifelse(cluster.counts$C1.count!=0,1,0)
cluster.counts$C2<-ifelse(cluster.counts$C2.count!=0,1,0)
cluster.counts$C3<-ifelse(cluster.counts$C3.count!=0,1,0)
cluster.counts$C4<-ifelse(cluster.counts$C4.count!=0,1,0)
cluster.counts$C5<-ifelse(cluster.counts$C5.count!=0,1,0)
 cluster.counts$IPI.median.cut<-ifelse(cluster.counts$ipi>median(cluster.counts$ipi),1,0)
cluster.counts$HANS<-factor(cluster.counts[,'Cell.of.origin..HANS.'])
cluster.counts$NGCB.binary<-ifelse(cluster.counts$HANS=='NGCB',1,0)
cluster.counts$Case_Number<-factor(cluster.counts$Case_Number)
 cluster.counts$IPI.median.cut<-ifelse(cluster.counts$ipi>median(cluster.counts$ipi),1,0)


 
### dropping ND subjects
 x2<-selectCases(x,as.character(clinic$Run.ID[which(clinic$chemo!='ND')]))
  any(colData(x2)$ROIID%>%unique%in%ndROI)  
   sapply(strsplit(colnames(x2),"_"),function(x) x[1])%in%ndROI %>%any 
    

     sce<-SingleCellExperiment(x2)
     exper_info2<-exper_info[!exper_info$sample_id%in%paste0("ROIID_",ndROI),]
     exper_info2$sample_id%in%paste0("ROIID_",ndROI)%>%any



           ###measure CPM.
  # tum.pheno<-c("InflamTumor","Tumor")
  # tme.counts<-t(cluster.counts[,c(1:14,16:18)])
  # y <- edgeR::DGEList(counts=tme.counts,group=cluster.counts$HANS,samples=cluster.counts$Case_ID)
  # y<-edgeR::estimateDisp(y,model.matrix(~C1+C2+C3+C4+C5+IPI.median.cut+NGCB.bin+Response.category,cluster.counts))
  # y<-edgeR::calcNormFactors(y)
   
  
     
     
  ##can run diffcyt on SCE with pre-determined clusters of interest.
   ##need to complete the SCE.
     ##metadata needs to be a list!
   metadata(sce)<-list(experiment_info=exper_info2)
   rowData(sce)<-DataFrame(channel_name=channel, marker_name=marker,marker_class=c(rep("type",14),
                             rep("state",17)))
  ##assign colData (each cell, this is cell level)
   colD<-DataFrame(id=colnames(sce),
                   sample_id=paste0("ROIID_",sapply(strsplit(colnames(sce),"_"),function(x) x[1])))
   
   ##REVISION 8-30 updating column data.
   
   colD$HANS<-ifelse(exper_info2$NGCB[match(colD$sample_id,exper_info2$sample_id)]==1,"NGCB","GCB")
   #   colD$group_id<-metadata(sce)$group_id[match(colD$sample_id,metadata(sce)$sample_id)]
   colD$group_id<-exper_info2$group_id[match(colD$sample_id,exper_info2$sample_id)]

#   colD$C1<-metadata(sce)$C1[match(colD$sample_id,metadata(sce)$sample_id)]
    colD$C1<-(exper_info2$C1[match(colD$sample_id,exper_info2$sample_id)])

  #colD$C2<-metadata(sce)$C2[match(colD$sample_id,metadata(sce)$sample_id)]
  # colD$C3<-metadata(sce)$C3[match(colD$sample_id,metadata(sce)$sample_id)]
  # colD$C4<-metadata(sce)$C4[match(colD$sample_id,metadata(sce)$sample_id)]
  # colD$C5<-metadata(sce)$C5[match(colD$sample_id,metadata(sce)$sample_id)]
       colD$C2<-(exper_info2$C2[match(colD$sample_id,exper_info2$sample_id)])
    colD$C3<-(exper_info2$C3[match(colD$sample_id,exper_info2$sample_id)])
    colD$C4<-(exper_info2$C4[match(colD$sample_id,exper_info2$sample_id)])
    colD$C5<-(exper_info2$C5[match(colD$sample_id,exper_info2$sample_id)])

# colD$patient_id<- metadata(sce)$experiment_info$patient_id[match(colD$sample_id,metadata(sce)$sample_id)]
 #  colD$patient_id<- ifelse(metadata(sce)$experiment_info$highIPI [match(colD$sample_id,metadata(sce)$sample_id)]==1,"HighIPI","LowIPI")
    colD$patient_id<-exper_info2$patient_id[match(colD$sample_id,exper_info2$sample_id)]
    colD$HighIPI<-ifelse(exper_info2$highIPI[match(colD$sample_id,exper_info2$sample_id)]==1,"HighIPI","LowIPI")

   colData(sce)<-colD
   colData(sce)$sample_id<-factor(colData(sce)$sample_id)
   
  table(metadata(sce)$experiment_info[,"SurgeryOnly"]) 

   assays(sce, withDimnames = FALSE)<-SimpleList(exprs=(assays(x2)$counts))
 ## uses asinh(x/5) as default
  sce<-transformData(sce)
  
   ##SOM clustering
   sce <- cluster(sce)  
    # view all available clustering
  #names(cluster_codes(sce))

## input the meta clustering from phenograph into cluster_id
   ## REVISION: 8-30: use the cluster_id as the unsupervised clusters.
   ##this revision changed the DIFFCYT model, not sure why. reverting.
  colData(sce)$cluster_id<-factor(full.dn4$unsup.subcommunity[match(colData(sce)$id,full.dn4$uniqueLabel)])
  metadata(sce)$cluster_codes<-data.frame(custom=factor(levels(colData(sce)$cluster_id),levels=levels(colData(sce)$cluster_id)  ) )

   table(colData(sce)$cluster_id==full.dn4$unsup.subcommunity[match(colData(sce)$id,full.dn4$uniqueLabel)])
  # colData(sce)$cluster_id<-factor(full.dn4$annotated.label.simple_akil[match(colData(sce)$id,full.dn4$uniqueLabel)])
  # metadata(sce)$cluster_codes<-data.frame(custom=factor(levels(colData(sce)$cluster_id),levels=levels(colData(sce)$cluster_id)  ) )

   
   
   
#colData(sce)$HANS<-metadata(sce)$experiment_info$NGCB[match(colData(sce)$sample_id,metadata(sce)$experiment_info$sample_id)]
colData(sce)$REF<-metadata(sce)$experiment_info$group_id[match(colData(sce)$sample_id,metadata(sce)$experiment_info$sample_id)]
colData(sce)$REF<-factor(colData(sce)$REF,levels=c("Primary refract","CR"))
#colData(sce)$C1<-metadata(sce)$experiment_info$C1[match(colData(sce)$sample_id,metadata(sce)$experiment_info$sample_id)]
#colData(sce)$C2<-metadata(sce)$experiment_info$C2[match(colData(sce)$sample_id,metadata(sce)$experiment_info$sample_id)]
#colData(sce)$C3<-metadata(sce)$experiment_info$C3[match(colData(sce)$sample_id,metadata(sce)$experiment_info$sample_id)]
#colData(sce)$C4<-metadata(sce)$experiment_info$C4[match(colData(sce)$sample_id,metadata(sce)$experiment_info$sample_id)]
#colData(sce)$C5<-metadata(sce)$experiment_info$C5[match(colData(sce)$sample_id,metadata(sce)$experiment_info$sample_id)]


# access specific clustering resolution
table(cluster_ids(sce, "custom"))
#plotAbundances(sce, k = "custom", by = "sample_id", group_by = "HANS")

plotExprHeatmap(sce, features = "type",
    by = "cluster_id", k = "custom",
    scale = "first", q = 0.01, perc = TRUE, col_dend = FALSE)

plotMultiHeatmap(sce, 
    hm1 = "type", hm2 = "state", 
    k = "custom", 
    col_dend = c(FALSE, TRUE))

##generate CPM
res_IPI.LDH <- diffcyt(sce,
                     clustering_to_use = "custom",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-GLMM",
    min_cells=10,
    min_samples=1,
    normalize=TRUE,
    formula = formula,
   # design=design,
    plot=TRUE,
   # contrast=createContrast(c(0,0,0,0,0,0,0,0,1,0,0,0,-1/2,0,-1/2,0,0,0,0,rep(0,7))),
    contrast = createContrast(c(0,0,0,0,0,0,0,0,1,0,0,0,-1/2,0,-1/2,0,0,0,0)),
    verbose = FALSE) 


 d_counts <- assays(res_IPI.LDH$d_counts)[["counts"]]
 norm_factors <- edgeR::calcNormFactors(assays(res_IPI.LDH$d_counts)[["counts"]],method="TMM")
 y <- edgeR::DGEList(d_counts, norm.factors = norm_factors)

##log CPM
lcpm<-asinh(t(edgeR::cpm(y)))%>%as.data.frame

###append the clinical data.
lcpm$Case_ID<-clinic$Case_ID[match(rownames(lcpm),paste0("ROIID_",clinic$Run.ID))]

lcpm<-left_join(lcpm,clinic[!duplicated(clinic$Case_ID),c("Case_ID","Case_Number","C1.count", "C2.count", "C3.count", "C4.count", "C5.count",'ipi','NGCB.bin','Cell.of.origin..HANS.','Response.category')],by='Case_ID')
lcpm$C1<-ifelse(lcpm$C1.count!=0,1,0)
lcpm$C2<-ifelse(lcpm$C2.count!=0,1,0)
lcpm$C3<-ifelse(lcpm$C3.count!=0,1,0)
lcpm$C4<-ifelse(lcpm$C4.count!=0,1,0)
lcpm$C5<-ifelse(lcpm$C5.count!=0,1,0)
 lcpm$IPI.median.cut<-ifelse(lcpm$ipi>median(lcpm$ipi),1,0)
lcpm$HANS<-factor(lcpm[,'Cell.of.origin..HANS.'])
lcpm$NGCB.binary<-ifelse(lcpm$HANS=='NGCB',1,0)
lcpm$Case_Number<-factor(lcpm$Case_Number)



####number of cells.
 #    plotAbundances(sce, k = "custom", by = "sample_id", group_by = "HANS")
  n_cells <- colData(sce)%>%as.data.frame%>%group_by(cluster_id,sample_id,.drop=FALSE) %>% tally
  n_cells$HANS<-exper_info$NGCB[match(n_cells$sample_id,exper_info$sample_id)]
  n_cells$response<-exper_info$group_id[match(n_cells$sample_id,exper_info$sample_id)]
 
   n_cells$C1<-exper_info$C1[match(n_cells$sample_id,exper_info$sample_id)]
  n_cells$C2<-exper_info$C2[match(n_cells$sample_id,exper_info$sample_id)]
  n_cells$C3<-exper_info$C3[match(n_cells$sample_id,exper_info$sample_id)]
  n_cells$C4<-exper_info$C4[match(n_cells$sample_id,exper_info$sample_id)]
  n_cells$C5<-exper_info$C5[match(n_cells$sample_id,exper_info$sample_id)]
  n_cells$highIPI<-exper_info$highIPI[match(n_cells$sample_id,exper_info$sample_id)]

  


###expsress data
 exprClust<-as.data.frame(t(assays(sce)[[1]]))
  exprClust$sample_id<-colData(sce)$sample_id
  exprClust$cluster_id<-colData(sce)$cluster_id
    exprClust$HANS<-colData(sce)$HANS
       exprClust$REF<-colData(sce)$REF
              exprClust$C1<-colData(sce)$C1
             exprClust$C2<-colData(sce)$C2
             exprClust$C3<-colData(sce)$C3
              exprClust$C4<-colData(sce)$C4
              exprClust$C5<-colData(sce)$C5


  
m<-exprClust%>%group_by(HANS,REF,sample_id,cluster_id)%>%summarize_all(mean)%>%as.data.frame


##standardize
  zz<- zScorePatientExpression(full.dn4=full.dn4,markers=c(1:31,104:111),ROIID.column=32)
 ### calculate any expression differences across sub-clusters and treatment response.
 
  ## ignore Tumor_11 cluster
   zz<-zz[which(zz$unsup.subcommunity!="Tumor_11"),]

  zz$annotated.label.simple_akil<-factor(zz$annotated.label.simple_akil)
  
  subExpr<-zz%>%group_by(ROIID,annotated.label.simple_akil)%>%summarise(CXCR3=mean(Cell_CXCR3),
	CCR4=mean(Cell_CCR4),
	BCL2=mean(Cell_BCL2),
	BCL6=mean(Cell_BCL6),
	CD30=mean(Cell_CD30),
	Ki67=mean(Cell_Ki67),
	cMyc=mean(Cell_C),
	PDL1=mean(Cell_PDL1),
	TIM3=mean(Cell_Tim3),
	LAG3=mean(Cell_Lag3),
	PD1=mean(Cell_PD1),
	ICOS=mean(Cell_ICOS),
	Vista=mean(Cell_Vista),
	CD45RO=mean(Cell_CD45RO),
	CD45RA=mean(Cell_CD45RA),
	CD206=mean(Cell_CD206),
	Granzym=mean(Cell_Granzym),
	Vimentin=mean(Cell_Vimentin),
	Tbet=mean(Cell_Tbet),
	NND.tumor=mean(NND.Tumor),
	HLADR=mean(Cell_HLADR),
	cMYC=mean(Cell_C),
	CD68=mean(Cell_CD68),
	CD206=mean(Cell_CD206),
	pSTAT3=mean(Cell_p))%>%data.frame

  subExpr$annotated.label.simple_akil<-droplevels(subExpr$annotated.label.simple_akil)

  
  subExpr$HANS<-factor(clinic$Cell.of.origin..HANS.[match(subExpr$ROIID,clinic$Run.ID)])
    subExpr$REF<-factor(clinic$Response.category[match(subExpr$ROIID,clinic$Run.ID)])
  subExpr$C1<-factor(clinic$C1[match(subExpr$ROIID,clinic$Run.ID)])
  subExpr$C2<-factor(clinic$C2[match(subExpr$ROIID,clinic$Run.ID)])
  subExpr$C3<-factor(clinic$C3[match(subExpr$ROIID,clinic$Run.ID)])
  subExpr$C4<-factor(clinic$C4[match(subExpr$ROIID,clinic$Run.ID)])
  subExpr$C5<-factor(clinic$C5[match(subExpr$ROIID,clinic$Run.ID)])
    subExpr$highIPI<-factor(  ifelse(clinic$ipi[match(subExpr$ROIID,clinic$Run.ID)]>=3,1,0))

    
     

```
# Cluster merging and pooling
- pool the clusters into family groups in the SCE using the full naming labels at publication quality.
```{r}
  metadata(sce)$cluster_codes[,"merging1"]<-NULL
 annoLabel<-metadata(sce)$cluster_codes
 annoLabel$new_cluster<-"uncharacterized"
 annoLabel$new_cluster<-full.dn4$annotated.label.back_akil[match(annoLabel$custom,full.dn4$unsup.subcommunity)]
 annoLabel<-annoLabel[,c("custom","new_cluster")]

  sce <- mergeClusters(sce, k = "custom", 
    table = annoLabel, id = "merging1", overwrite=TRUE)


   metadata(sce)$cluster_codes[,"merging2"]<-NULL
 annoLabel2<-metadata(sce)$cluster_codes
 annoLabel2$new_cluster<-"uncharacterized"
 annoLabel2$new_cluster<-full.dn4$subcluster_annotated[match(annoLabel$custom,full.dn4$unsup.subcommunity)]
 annoLabel2<-annoLabel2[,c("custom","new_cluster")]





sce <- mergeClusters(sce, k = "custom", 
    table = annoLabel2, id = "merging2", overwrite=TRUE)

table(cluster_ids(sce,"custom"),cluster_ids(sce,"merging2"))%>%tail(40)
table(cluster_ids(sce,"custom"),cluster_ids(sce,"merging1"))%>%tail(40)


 rowData(sce)$marker_name<-rownames(sce)
 
 
 ##to save memory drop x (full imc)
 x<-NULL
 
 
 
 ### create merging 3 summary
   metadata(sce)$cluster_codes[,"merging3"]<-NULL
 annoLabel3<-metadata(sce)$cluster_codes
 annoLabel3$new_cluster<-"uncharacterized"
 annoLabel3$new_cluster<-c("Inflammatory",
                           "Activated",
                          "Activated",
                          "Neutral",
                          
                          "Inflammatory",
                          "Activated",
                          "Activated",
                          "Activated",
                          "Inflammatory",
                          "Inflammatory",
                          "Activated",
                          "Inflammatory",
                          "Inflammatory",
                          "Neutral",
                          
                          "Inflammatory",
                          "Inflammatory",
                          "Activated",
                          "Activated",
                          "Inflammatory",
                          "Inflammatory",
                          "Inflammatory",
                          "Inflammatory",
                          "Neutral",
                          "Neutral",
                          
                          "Activated",
                          "Inflammatory",
                          
                          "Non-Inflam. B-Cell tumor(1-5,7,9)",
                          "Non-Inflam. B-Cell tumor(1-5,7,9)",
                          "Non-Inflam. B-Cell tumor(1-5,7,9)",
                          "Non-Inflam. B-Cell tumor(1-5,7,9)",
                          "Non-Inflam. B-Cell tumor(1-5,7,9)",
                          "Inflammatory B-Cell tumor(6,8,10)",
                          "Non-Inflam. B-Cell tumor(1-5,7,9)",
                          "Inflammatory B-Cell tumor(6,8,10)",
                          "Non-Inflam. B-Cell tumor(1-5,7,9)",
                          "Inflammatory B-Cell tumor(6,8,10)",
                          "none(11)",
                          "Inflammatory",
                          "Activated",
                          "Activated",
                          "Inflammatory",
                          "Neutral",
                          "Activated")
                          
                          
 annoLabel3<-annoLabel3[,c("custom","new_cluster")]





sce <- mergeClusters(sce, k = "custom", 
    table = annoLabel3, id = "merging3", overwrite=TRUE)




### topology clusters.
 ### create merging 3 summary
   metadata(sce)$cluster_codes[,"merging4"]<-NULL
 annoLabel4<-metadata(sce)$cluster_codes
 annoLabel4$new_cluster<-"uncharacterized"
 annoLabel4$new_cluster<-full.dn4$tumor.5nn.class.unsup[match(annoLabel$custom,full.dn4$unsup.subcommunity)]
 annoLabel4$new_cluster[is.na(annoLabel4$new_cluster)]<-"none"
 annoLabel4<-annoLabel4[,c("custom","new_cluster")]



sce <- mergeClusters(sce, k = "custom", 
    table = annoLabel4, id = "merging4", overwrite=TRUE)


##major compartment
## create merging 3 summary
   metadata(sce)$cluster_codes[,"merging5"]<-NULL
 annoLabel4<-metadata(sce)$cluster_codes
 annoLabel4$new_cluster<-"uncharacterized"
 annoLabel4$new_cluster<-sapply(strsplit(as.character(annoLabel4$custom),"_"),function(x) x[1])
 annoLabel4<-annoLabel4[,c("custom","new_cluster")]



sce <- mergeClusters(sce, k = "custom", 
    table = annoLabel4, id = "merging5", overwrite=TRUE)




   metadata(sce)$cluster_codes[,"merging6"]<-NULL
 annoLabel5<-metadata(sce)$cluster_codes
 annoLabel5$new_cluster<-"uncharacterized"
 annoLabel5$new_cluster<-as.character(annoLabel5$custom)
 annoLabel5$new_cluster[grepl("Tumor",annoLabel5$new_cluster)]<-"Tumor"
 annoLabel5<-annoLabel5[,c("custom","new_cluster")]



sce <- mergeClusters(sce, k = "custom", 
    table = annoLabel5, id = "merging6", overwrite=TRUE)

annoLabel6<-data.frame(annoLabel3,annoLabel4)
annoLabel6$new_cluster<-paste0(annoLabel6$new_cluster,"_",annoLabel6$new_cluster.1)

 sce <- mergeClusters(sce, k = "custom", 
    table = annoLabel6[,c("custom","new_cluster")], id = "inflam", overwrite=TRUE)



###simple labels for hyperframe analysis.
##set a key for zonal analysis.
 ## need to reduce the phenotypes into act/exhausted/neutral pheno
 annoLabel7<-metadata(sce)$cluster_codes
 annoLabel7$new_cluster<-"uncharacterized"
 annoLabel7$new_cluster<-as.character(annoLabel7$custom)
 annoLabel7$new_cluster<-full.dn4$annotated.label.simple_akil[match(annoLabel7$custom,full.dn4$unsup.subcommunity)]
 annoLabel7<-annoLabel7[,c("custom","new_cluster")]

  annoLabel7$new_cluster[annoLabel7$new_cluster%in%c("Late_Exhausted_CD4")]<-"TermExh_CD4"
  annoLabel7$new_cluster[annoLabel7$new_cluster%in%c("Act_Exh_early_CD4","Act_prol_CD4")]<-"Activ_CD4"
  
  annoLabel7$new_cluster[annoLabel7$new_cluster%in%c("Exh_Inflam_CD8","Term_Exh_CD8")]<-"TermExh_CD8"
  annoLabel7$new_cluster[annoLabel7$new_cluster%in%c("Act_prol_CD8")]<-"Activ_CD8"
  
  annoLabel7$new_cluster[annoLabel7$new_cluster%in%c("M2MAC","PDL1M2MAC")]<-"M2_MAC"
  annoLabel7$new_cluster[annoLabel7$new_cluster%in%c("M1MAC")]<-"M1_MAC"
  
  annoLabel7$new_cluster[annoLabel7$new_cluster%in%c("Hi_Supp_TREG","Act_prol_TREG")]<-"Activ_TREG"


 
 sce <- mergeClusters(sce, k = "custom", 
    table = annoLabel7[,c("custom","new_cluster")], id = "zone", overwrite=TRUE)


 
  ## pooled family level clusters with bulk tumor.
  annoLabel8<-metadata(sce)$cluster_codes
 annoLabel8$new_cluster<-"uncharacterized"
 annoLabel8$new_cluster<-as.character(annoLabel8$custom)
 annoLabel8$new_cluster<-full.dn4$annotated.label.simple_akil[match(annoLabel8$custom,full.dn4$unsup.subcommunity)]
 annoLabel8$new_cluster[grepl("Tumor",annoLabel8$new_cluster)]<-"Tumor"
  annoLabel8$new_cluster[which(annoLabel8$new_cluster=="M1MAC")]<-"M1_MAC"
  annoLabel8$new_cluster[which(annoLabel8$new_cluster=="M2MAC")]<-"M2_MAC"
  annoLabel8$new_cluster[which(annoLabel8$new_cluster=="PDL1M2MAC")]<-"PDL1M2_MAC"

 annoLabel8<-annoLabel8[,c("custom","new_cluster")]

 sce <- mergeClusters(sce, k = "custom", 
    table = annoLabel8[,c("custom","new_cluster")], id = "familyTumor", overwrite=TRUE)

 

 
 
###  PDL1/PD1 context
 annoLabel9<-metadata(sce)$cluster_codes
 annoLabel9$new_cluster<-"uncharacterized"
 annoLabel9$new_cluster<-as.character(annoLabel9$custom)
 annoLabel9$new_cluster<-full.dn4$annotated.label.simple_akil[match(annoLabel9$custom,full.dn4$unsup.subcommunity)]
 annoLabel9<-annoLabel9[,c("custom","new_cluster")]

  annoLabel9$new_cluster[annoLabel9$new_cluster%in%c("Late_Exhausted_CD4")]<-"TermExh_CD4"
  annoLabel9$new_cluster[annoLabel9$new_cluster%in%c("Act_Exh_early_CD4","Act_prol_CD4")]<-"Activ_CD4"
  
  annoLabel9$new_cluster[annoLabel9$new_cluster%in%c("Exh_Inflam_CD8","Term_Exh_CD8")]<-"PD1_CD8"
  annoLabel9$new_cluster[annoLabel9$new_cluster%in%c("Act_prol_CD8")]<-"PD1_CD8"
  annoLabel9$new_cluster[annoLabel9$new_cluster%in%c("Baseline_CD8")]<-"PD1Neg_CD8"

 
  
  annoLabel9$new_cluster[annoLabel9$new_cluster%in%c("Hi_Supp_TREG","Act_prol_TREG","Baseline_TREG")]<-"TREG"
  annoLabel9$new_cluster[annoLabel9$new_cluster%in%c("InflamTumor")]<-"PD1_Tumor"
  annoLabel9$new_cluster[annoLabel9$new_cluster%in%c("Tumor")]<-"PD1Neg_Tumor"

  annoLabel9$new_cluster[annoLabel9$custom%in%c("Macrophage_2","Macrophage_5")]<-"PDL1Mac"
  annoLabel9$new_cluster[annoLabel9$custom%in%c("Macrophage_1","Macrophage_3","Macrophage_4","Macrophage_6")]<-"PDL1Neg_Mac"

 
 sce <- mergeClusters(sce, k = "custom", 
    table = annoLabel9[,c("custom","new_cluster")], id = "pd1", overwrite=TRUE)
 
 
 
 
 ####
  #family level hyper
       netw<-getNetwork(x2)
  netw$subannotated<-as.character(cluster_ids(sce,"merging1"))
  colnames(netw)<-c("annotated","subannotated")

    getNetwork(x2)<-netw
    unique(netw[,2])
    
    ## first using major compartments only.
     Hpool<-imcExperimentToHyperFrame(imcExperiment=x2,phenotypeToUse =2)
   Hpool$ROI<-paste0("ROIID_",Hpool$ROI)
   Hpool$treatment<-colData(sce)$REF[match(Hpool$ROI,colData(sce)$sample_id)]
   
  
   
   ## want to test TREGs as global population <-PDL1M2 -> Exh/Inflam CD8
   # contrast against   TREG <-M1 -> Act/Prolif CD8
    
 annoLabel10<-metadata(sce)$cluster_codes
 annoLabel10$new_cluster<-"uncharacterized"
 annoLabel10$new_cluster<-as.character(annoLabel10$merging1)
 annoLabel10<-annoLabel10[,c("custom","new_cluster")]
 annoLabel10$new_cluster[grepl("TREG",annoLabel10$custom)]<-"TREG"
 
  sce <- mergeClusters(sce, k = "custom", 
    table = annoLabel10[,c("custom","new_cluster")], id = "treg", overwrite=TRUE)
 
 
 
      netw<-getNetwork(x2)
  netw$subannotated<-as.character(cluster_ids(sce,"treg"))
  colnames(netw)<-c("annotated","subannotated")

    getNetwork(x2)<-netw
    unique(netw[,2])
    
   
    ## first using major compartments only.
     Hpool_treg<-imcExperimentToHyperFrame(imcExperiment=x2,phenotypeToUse =2)
   Hpool_treg$ROI<-paste0("ROIID_",Hpool_treg$ROI)
   Hpool_treg$treatment<-colData(sce)$REF[match(Hpool_treg$ROI,colData(sce)$sample_id)]
   
 
#### testing Endothelial to main compartments CD4/MAC/CD8 etc.
      metadata(sce)$cluster_codes[,"base48"]<-NULL
 annoLabel4<-metadata(sce)$cluster_codes
 annoLabel4$new_cluster<-"uncharacterized"
 annoLabel4$new_cluster<-as.character(annoLabel4$merging1)
 
  annoLabel4$new_cluster[which(annoLabel4$new_cluster=="Baseline CD8(7)")]<- "Baseline CD4/8 (4,7)"
  annoLabel4$new_cluster[which(annoLabel4$new_cluster=="Baseline CD4(4)")]<- "Baseline CD4/8 (4,7)"
  annoLabel4$new_cluster<-factor(annoLabel4$new_cluster)
 annoLabel4<-annoLabel4[,c("custom","new_cluster")]
 sce <- mergeClusters(sce, k = "custom", 
    table = annoLabel4, id = "base48", overwrite=TRUE)
 
 
## manual gating of hi.supp.treg.pstat3+  
  netw<-getNetwork(x2)
  netw$subannotated<-as.character(cluster_ids(sce,"merging1"))
  colnames(netw)<-c("annotated","subannotated")

  pid<-which(t(assays(sce)$exprs)[,"pSTAT3"]>0.051)
  netw$pstat3<-"pSTAT3-"
  netw$pstat3[pid]<-"pSTAT3+"
  netw$tregPstat<-netw$subannotated
netw[which(netw$tregPstat=="Hi.Suppress.T-reg(1,2,6)"),"tregPstat"]<-paste0("Hi.Suppress.T-reg(1,2,6)_",netw[which(netw$tregPstat=="Hi.Suppress.T-reg(1,2,6)"),"pstat3"])

      getNetwork(x2)<-netw[,c("annotated","tregPstat")]
    unique(netw[,2])
  
     
    ## first using major compartments only.
     HtregPstat<-imcExperimentToHyperFrame(imcExperiment=x2,phenotypeToUse =2)
   HtregPstat$ROI<-paste0("ROIID_",HtregPstat$ROI)
   HtregPstat$treatment<-colData(sce)$REF[match(HtregPstat$ROI,colData(sce)$sample_id)]
   
  
   save(HtregPstat,file="~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/hyperframe/HtregPstat.RData")
   
   
   
```

### Set the patient column data as factors
```{r}

colData(sce)$C1<-factor(colData(sce)$C1)
colData(sce)$C2<-factor(colData(sce)$C2)
colData(sce)$C3<-factor(colData(sce)$C3)
colData(sce)$C4<-factor(colData(sce)$C4)
colData(sce)$C5<-factor(colData(sce)$C5)

```

```{r}
 sce2<-sce
    colData(sce2)<-colData(sce2)[,c("id",
                                    "sample_id",
                                    "cluster_id",
                                    "HighIPI",
                                    "REF",
                                    "HANS"
                                    )]
    #colData(sce2)$sample_id<-colData(sce)$patient_id

```


# Expression Trends per signal
- normalized distribution of signal is ranged from [0,0.20]
```{r}

  trendExpr <- plotExprs(sce,color_by="REF")
  trendExpr$facet$params$ncol <- 6
  trendExpr

```




# Analysis of the SCE experiment family level (pooled)
- We remove the Non-Treated participants, 3967, 4046, 4059
- we control for IPI, double expressor, and gender.
- the analysis performed a repeated measures linear model.
- REVISION 8-29: use the merging columns `merging1` for pooled clusters using full publication quality names (and not the shorthand labeling) 
- REVISION 8-29: figure creation using plot Abundances and Diff heatmaps of the SCE.
```{r}
  ## DROPPED ALL ND SUBJECTS
  any( unique(colData(sce)$sample_id)%in%full.dn4$ROIID[which(full.dn4$treatment.status=="ND")])
#########################################
###########################################

   outdir<-"C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-model-worksheets/Figure2-9-20/"
   writeToFile<-TRUE
  
   
   if(writeToFile){
    library(openxlsx)
    wb <- createWorkbook(
  creator = "Anthony",
  title = "Figure 2 9-20-Revision",
  subject = "DLBCLFamily Level Analysis",
  category = "Immunology/IMC"
  )
  }  
    ###reduced design.
# design <- createDesignMatrix(exper_info2, cols_design = c("NGCB","group_id",
 #"C1","C2","C3","C4","C5",
 #"Stage34", "NodalInvolve","LDH", "AgeHigh",
 #"Gender",
#  "doubleExpressor",
 #"patient_id"))
 
## Omitting NGCB as a test did not improve or alter the abundance results.
  design <- createDesignMatrix(exper_info2, cols_design = c("NGCB", "group_id",
 "C1","C2","C3","C4","C5",
  "highIPI",
 "Gender",
  "doubleExpressor",
"patient_id"))

design<-design[,which(colSums(design)>1)]
 
 


#########Convergence issues.    
 ##compare with design    
 pool.res_IPI.LDH2 <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    #formula = formula,
    design=design,
    plot=TRUE,
    #contrast=createContrast(c(0,0,0,0,0,0,0,1,0,0,rep(0,7))),
   contrast=createContrast(c(0,0,0,0,0,0,0,0,1,0,0,rep(0,7))),
    verbose = FALSE)
 
 
    diffcyt::topTable(pool.res_IPI.LDH2,format_vals = TRUE,top_n=10,show_logFC =TRUE)
    
    
    
    if(writeToFile){
    
  
    addWorksheet(wb, "HighIPI Main Effect")
     writeData(wb, "HighIPI Main Effect", 
               diffcyt::topTable(pool.res_IPI.LDH2,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)

      
    }
 
# plotAbundanceCPMDiffCyt(d_counts=res_IPI.LDH2$d_counts,cluster="Tumor",marker=NULL,clinicalFactor="highIPI")

        
##states edgeR
       pool.state_IPI.LDH2 <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design=design,
    plot=TRUE,
    contrast=createContrast(c(0,0,0,0,0,0,0,0,1,0,0,rep(0,7))),
    verbose = TRUE)
 
 
    diffcyt::topTable(pool.state_IPI.LDH2,format_vals = TRUE,top_n=10,show_logFC =TRUE)
    
    if(writeToFile){
         addWorksheet(wb, "HighIPI Main Effect (States)")
     writeData(wb, "HighIPI Main Effect (States)", 
               diffcyt::topTable(pool.state_IPI.LDH2,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)
     
    }
  
############################################################
#   NGCB .vs. GCB NO CONTRAST     
#######################################################
##NGCB !=0 vs. others not contrast
  
 
 ###################
## EDGE R
 ## trends should match the Mixed model.
 ########################
    pool.ngcb_DA <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design = design,
    contrast=createContrast(c(0,1,0,0,0,0,0,0,0,0,0,rep(0,7))),
    verbose = FALSE)
      diffcyt::topTable(pool.ngcb_DA,format_vals = TRUE,top_n=10, show_logFC = TRUE)
  
     if(writeToFile){
         addWorksheet(wb, "NGCB Main Effect")
     writeData(wb, "NGCB Main Effect", 
               diffcyt::topTable(pool.ngcb_DA,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)
     
         }
      # aNG<- plotAbundanceCPMDiffCyt(d_counts=ngcb_DA$d_counts,cluster="Act_prol_TREG",marker=NULL,clinicalFactor="NGCB")
      # aNG2<- plotAbundanceCPMDiffCyt(d_counts=ngcb_DA$d_counts,cluster="Baseline_CD4",marker=NULL,clinicalFactor="NGCB")
       #   a2<- plotAbundanceCPMDiffCyt(d_counts=ngcb_DA$d_counts,cluster="Baseline_TREG",marker=NULL,clinicalFactor="NGCB")
      # b2<- plotAbundanceCPMDiffCyt(d_counts=ngcb_DA$d_counts,cluster="Exh_Inflam_CD8",marker=NULL,clinicalFactor="NGCB")
 #grid.arrange(aNG,aNG2,a2,b2,nrow=2,ncol=2)
 
 
##JOINT EFFECT IPI AND NGCB JOINT EFECT.
 #  chisq.test(exper_info2$highIPI,exper_info2$NGCB)  
  pool.joint_ngcb_IPI_DA <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design = design,
    contrast=createContrast(c(0,1/2,0,0,0,0,0,0,1/2,0,0,rep(0,7))),
    verbose = FALSE)
      diffcyt::topTable(pool.joint_ngcb_IPI_DA,format_vals = TRUE,top_n=10, show_logFC = TRUE)
  
      if(writeToFile){
     
      addWorksheet(wb, "NGCB+IPI Main Effect")
     writeData(wb, "NGCB+IPI Main Effect", 
               diffcyt::topTable(pool.joint_ngcb_IPI_DA,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)
        
         }
 ##convergence issues with mixed, so repeated measures is used here.
# markersTest<-rownames(rowData(sce))%in%c("PDL1","PDL2","Tim3","PD1","Lag3","ICOS","Vimentin","CXCR3","CCR4","Vista")
 pool.ngcb_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
   # formula = formula,
   design=design,
  #markers_to_test = markersTest,
    contrast=createContrast(c(0,1,0,0,0,0,0,0,0,0,0,rep(0,7))),
    verbose = FALSE)
 diffcyt::topTable(pool.ngcb_DS,show_logFC = TRUE)
   
 if(writeToFile){

    addWorksheet(wb, "NGCB Main Effect States")
     writeData(wb, "NGCB Main Effect States", 
               diffcyt::topTable(pool.ngcb_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)
   
   }
 

    ##joint average effect of IPI and REF
   
    pool.joint_ngcb_IPI_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
   # formula = formula,
   design=design,
  #markers_to_test = markersTest,
    contrast=createContrast(c(0,1/2,0,0,0,0,0,0,1/2,0,0,rep(0,7))),
    verbose = FALSE)
 diffcyt::topTable(pool.joint_ngcb_IPI_DS,show_logFC = TRUE)
 
   if(writeToFile){
 
     addWorksheet(wb, "NGCB+IPI Main Effect States")
     writeData(wb, "NGCB+IPI Main Effect States", 
               diffcyt::topTable(pool.joint_ngcb_IPI_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)
  }
 
   #plotDiffHeatmap(sce, rowData(joint_ngcb_IPI_DS$res), top_n = 5, fdr = 0.05, lfc=0)


#########################################


##refractory  effects contrasted against age, sex, ethnicity
## refractory is not associated with age, gender, ethnicity
## refractory is association with IPI and NGCB (we average those)
## refractory is marginal associated with LDH.
 

 
     
############# repeated measures.
     pool.ref_DA <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design=design,
    #contrast=createContrast(c(0,1,0,0,0,0,0,0,0,0,rep(0,7))),
    contrast=createContrast(c(0,0,1,0,0,0,0,0,0,0,0,rep(0,7))),
    verbose = FALSE)
     
      topTable(pool.ref_DA,format_vals = TRUE,top_n=10,show_logFC = TRUE)

               if(writeToFile){
            addWorksheet(wb, "REF Main Effect")
     writeData(wb, "REF Main Effect", 
               diffcyt::topTable(pool.ref_DA,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)
                 
                        }
 

## REF, IPI joint effect.
   pool.joint_ref_IPI_DA <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design=design,
    #contrast=createContrast(c(0,1,0,0,0,0,0,0,0,0,rep(0,7))),
    contrast=createContrast(c(0,0,1/2,0,0,0,0,0,1/2,0,0,rep(0,7))),
    verbose = FALSE)
     
      topTable(pool.joint_ref_IPI_DA,format_vals = TRUE,top_n=10,show_logFC = TRUE)
      
 # plotAbundances(sce, k = "merging1",group_by='REF', by = "cluster_id")
    
      
                     if(writeToFile){
    
      addWorksheet(wb, "REF+IPI Main Effect")
     writeData(wb, "REF+IPI Main Effect", 
               diffcyt::topTable(pool.joint_ref_IPI_DA,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)
      
             }
##states.
  pool.ref_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
  design=design,
 # markers_to_test = markersTest,
    contrast=createContrast(c(0,0,1,0,0,0,0,0,0,0,0,rep(0,7))),
    verbose = FALSE)
      diffcyt::topTable(pool.ref_DS,format_vals = TRUE,top_n=10,show_logFC = TRUE)
    
       if(writeToFile){
         addWorksheet(wb, "REF Main Effect States")
     writeData(wb, "REF Main Effect States", 
               diffcyt::topTable(pool.ref_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)
}
           


   ### JOINT EFFECT OF IPI AND REF
 pool.joint_ref_IPI_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
  design=design,
 # markers_to_test = markersTest,
    contrast=createContrast(c(0,0,1/2,0,0,0,0,0,1/2,0,0,rep(0,7))),
    verbose = FALSE)
      diffcyt::topTable(pool.joint_ref_IPI_DS,format_vals = TRUE,top_n=15,show_logFC = TRUE)
    
       if(writeToFile){
         addWorksheet(wb, "REF+IPI Main Effect States")
     writeData(wb, "REF+IPI Main Effect States", 
               diffcyt::topTable(pool.joint_ref_IPI_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)
       }   

     # plotDiffHeatmap(sce2, rowData(pool.joint_ref_IPI_DS$res), top_n = 10, fdr = 0.05,lfc=0)

  
  
##joint IPI, REF, COO  
pool.joint_ref_NGCB_IPI_DA <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design=design,
    #contrast=createContrast(c(0,1,0,0,0,0,0,0,0,0,rep(0,7))),
    contrast=createContrast(c(0,1/3,1/3,0,0,0,0,0,1/3,0,0,rep(0,7))),
    verbose = FALSE)
     
      topTable(pool.joint_ref_NGCB_IPI_DA,format_vals = TRUE,top_n=10,show_logFC = TRUE)
      
       if(writeToFile){
       addWorksheet(wb, "REF+IPI+NGCB Main Effect")
     writeData(wb, "REF+IPI+NGCB Main Effect", 
               diffcyt::topTable(pool.joint_ref_NGCB_IPI_DA,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)
       }       
   pool.joint_ref_NGCB_IPI_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
  design=design,
 # markers_to_test = markersTest,
    contrast=createContrast(c(0,1/3,1/3,0,0,0,0,0,1/3,0,0,rep(0,7))),
    verbose = FALSE)
      diffcyt::topTable(pool.joint_ref_NGCB_IPI_DS,format_vals = TRUE,top_n=30,show_logFC = TRUE)%>%as.data.frame
    
    
        
                 if(writeToFile){
         addWorksheet(wb, "REF+IPI+NGCB Main Effect states")
     writeData(wb, "REF+IPI+NGCB Main Effect states", 
               diffcyt::topTable(pool.joint_ref_NGCB_IPI_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
                 }  
      
   
   # plotDiffHeatmap(sce2, rowData(pool.joint_ref_NGCB_IPI_DS$res), top_n = 10, fdr = 0.05,lfc=0)
  
         
         
##double expressor.
    ##joint IPI, REF, COO  
pool.de_DA <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design=design,
    #contrast=createContrast(c(0,1,0,0,0,0,0,0,0,0,rep(0,7))),
    contrast=createContrast(c(0,0,0,0,0,0,0,0,0,0,1,rep(0,7))),
    verbose = FALSE)
     
      topTable(pool.de_DA,format_vals = TRUE,top_n=10,show_logFC = TRUE)
      
                 if(writeToFile){
        addWorksheet(wb, "DE Main Effect")
     writeData(wb, "DE Main Effect", 
               diffcyt::topTable(pool.de_DA,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)  
                 }         
  
       
  pool.joint_de_DA <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design=design,
    #contrast=createContrast(c(0,1,0,0,0,0,0,0,0,0,rep(0,7))),
    contrast=createContrast(c(0,0,0,0,0,0,0,0,1/2,0,1/2,rep(0,7))),
    verbose = FALSE)
     
      topTable(pool.joint_de_DA,format_vals = TRUE,top_n=10,show_logFC = TRUE)
      
                 if(writeToFile){
       addWorksheet(wb, "DE+IPI Main Effect")
     writeData(wb, "DE+IPI Main Effect", 
               diffcyt::topTable(pool.joint_de_DA,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)  
                 }       
       
       
              
###############################################################
# CHAPUY CLUSTER ANALYSIS
###############################################################

 ## C1- (c2+C3+C4+C5)-(1/4)(IPI+Ethnic+Gender+surgeryOnly)
   
 
###repeated measures.
   pool.C1_DA_RM <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    #formula = formula,
    design=design,
   contrast=createContrast(c(0,0,0,1,-1,-1,-1,-1,0,0,0,rep(0,7))),
    verbose = FALSE)
   
      topTable(pool.C1_DA_RM,format_vals = TRUE,top_n=10,show_logFC = TRUE)

                           if(writeToFile){
       addWorksheet(wb, "C1.vs.All Main Effect")
     writeData(wb, "C1.vs.All Main Effect", 
               diffcyt::topTable(pool.C1_DA_RM,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)  
                           }
      
      
   #aNG<- plotAbundanceCPMDiffCyt(d_counts=C1_DA_RM$d_counts,cluster="Baseline_CD4",marker=NULL,clinicalFactor="C1")
    

## Joint effect of C1, IPI. (NULL)
  pool.C1_DA_RM <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    #formula = formula,
    design=design,
   contrast=createContrast(c(0,0,0,1,0,0,0,0,1,0,0,rep(0,7))),
    verbose = FALSE)
   
      topTable(pool.C1_DA_RM,format_vals = TRUE,top_n=10,show_logFC = TRUE)
      
 #plotAbundances(sce,k="custom",by="sample_id",group_by="C1")      
      
 
               if(writeToFile){
      addWorksheet(wb, "C1+IPI Main Effect")
     writeData(wb, "C1+IPI Main Effect", 
               diffcyt::topTable(pool.C1_DA_RM,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)  
               }      
 #aNG<- plotAbundanceCPMDiffCyt(d_counts=C1_DA_RM$d_counts,cluster="Baseline_CD4",marker=NULL,clinicalFactor="C1")
    

  
 
 
 
 
 ##examine the states.
   pool.C1_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design=design,
    contrast=createContrast(c(0,0,0,1,-1,-1,-1,-1,0,0,0,rep(0,7))),
    verbose = FALSE)
      diffcyt::topTable(pool.C1_DS,format_vals = TRUE,top_n=10, show_logFC = TRUE)
      
 if(writeToFile){
           addWorksheet(wb, "C1.vs.all Main Effect states")
     writeData(wb, "C1.vs.all Main Effect states", 
               diffcyt::topTable(pool.C1_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE)  
 }
      
   #as<-  plotMedianExpressionBoxplot(d_medians=C1_DS$d_medians,cluster="Hi_Supp_TREG",marker="Vimentin",clinicalFactor="C1")
   #bs<-  plotMedianExpressionBoxplot(d_medians=C1_DS$d_medians,cluster="M1MAC",marker="HLADR",clinicalFactor="C1")
  #   grid.arrange(as,bs, nrow=1)
 
  
 
### repeat measures.
 #repeated measures.
   pool.C2_DA_RM <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    #formula = formula,
    design=design,
  contrast=createContrast(c(0,0,0,-1,1,-1,-1,-1,1,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(pool.C2_DA_RM,format_vals = TRUE,top_n=10,show_logFC = TRUE)
      
      
 if(writeToFile){
        addWorksheet(wb, "C2.vs.all Main Effect")
     writeData(wb, "C2.vs.all Main Effect", 
               diffcyt::topTable(pool.C2_DA_RM,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
 }
      
      
   #ac1<- ggplot(lcpm,aes(x=factor(C2),y=PDL1M2MAC))+geom_boxplot()+ggtitle("PDL1M2MAC")

 
  ##repeat measures.
  #examine the states.
   pool.C2_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design=design,
   # markers_to_test = markersTest,
    contrast=createContrast(c(0,0,0,-1,1,-1,-1,-1,0,0,0,rep(0,7))),
      verbose = FALSE)
      diffcyt::topTable(pool.C2_DS,format_vals = TRUE,top_n=20, show_logFC = TRUE)
      
      
               if(writeToFile){
          addWorksheet(wb, "C2.vs.all Main Effect states")
     writeData(wb, "C2.vs.all Main Effect states", 
               diffcyt::topTable(pool.C2_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
               }          
 #as<-  plotMedianExpressionBoxplot(d_medians=C2_DS$d_medians,cluster="Tumor",marker="Ki67",clinicalFactor="C2")
#   bs<-  plotMedianExpressionBoxplot(d_medians=C2_DS$d_medians,cluster="Hi_Supp_TREG",marker="Ki67",clinicalFactor="C2")
#  cs<-  plotMedianExpressionBoxplot(d_medians=C2_DS$d_medians,cluster="Endothelial",marker="Ki67",clinicalFactor="C2")
#   grid.arrange(as,bs,cs, nrow=2)


  
###repeat measures.
  pool.C3_DA_RM <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    #formula = formula,
    design=design,
   # contrast=createContrast(c(0,0,-1/4,-1/4,1,-1/4,-1/4,0,0,0,rep(0,7))),
    contrast=createContrast(c(0,0,0,-1,-1,1,-1,-1,0,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(pool.C3_DA_RM,format_vals = TRUE,top_n=10,show_logFC = TRUE)
      
      
                 if(writeToFile){
     addWorksheet(wb, "C3.vs.all Main Effect")
     writeData(wb, "C3.vs.all Main Effect", 
               diffcyt::topTable(pool.C3_DA_RM,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
                 }
      
      
    # a<-ggplot(n_cells[which(n_cells$cluster_id=="Baseline_TREG"),],aes(x=factor(C3),y=n))+geom_boxplot()+ggtitle("Baseline TREG") 
    #   b<- ggplot(n_cells[which(n_cells$cluster_id=="Baseline_CD4"),],aes(x=factor(C3),y=n))+geom_boxplot()+ggtitle("Baseline CD4") 

       
 


### 
##repeat measures.
  #examine the states.
   pool.C3_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design=design,
   # markers_to_test = markersTest,
    contrast=createContrast(c(0,0,0,-1,-1,1,-1,-1,0,0,0,rep(0,7))),
      verbose = FALSE)
      diffcyt::topTable(pool.C3_DS,format_vals = TRUE,top_n=10, show_logFC = TRUE)
      
                 if(writeToFile){
         addWorksheet(wb, "C3.vs.all Main Effect states")
     writeData(wb, "C3.vs.all Main Effect states", 
               diffcyt::topTable(pool.C3_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
                 }
      
      
#   as<-  plotMedianExpressionBoxplot(d_medians=C3_DS$d_medians,cluster="Act_Exh_early_CD4",marker="Granzym",clinicalFactor="C3")
#   bs<-  plotMedianExpressionBoxplot(d_medians=C3_DS$d_medians,cluster="Act_Exh_early_CD4",marker="CXCR3",clinicalFactor="C3")
#  cs<-  plotMedianExpressionBoxplot(d_medians=C3_DS$d_medians,cluster="Act_prol_TREG",marker="Granzym",clinicalFactor="C3")
#  ds<-  plotMedianExpressionBoxplot(d_medians=C3_DS$d_medians,cluster="Term_Exh_CD8",marker="Granzym",clinicalFactor="C3")
#   grid.arrange(as,bs,cs, ds, nrow=2)


##C4  
 
 
 ##repeat measure
  pool.C4_DA_RM <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    #formula = formula,
    design=design,
    # contrast=createContrast(c(0,0,-1/4,-1/4,-1/4,1,-1/4,0,0,0,rep(0,7))),
     contrast=createContrast(c(0,0,0,-1,-1,-1,1,-1,0,0,0,rep(0,7))),
    verbose = FALSE)
  
      topTable(pool.C4_DA_RM,format_vals = TRUE,top_n=10,show_logFC = TRUE)
      
                 if(writeToFile){
       addWorksheet(wb, "C4.vs.all Main Effect")
     writeData(wb, "C4.vs.all Main Effect", 
               diffcyt::topTable(pool.C4_DA_RM,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
                 } 

 
 ##examine the states C4.
  ###repeat measure
  pool.C4_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design = design,
    contrast=createContrast(c(0,0,0,-1,-1,-1,1,-1,0,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(pool.C4_DS,format_vals = TRUE,top_n=10,show_logFC = TRUE) 
      
      
                 if(writeToFile){
          addWorksheet(wb, "C4.vs.all Main Effect states")
     writeData(wb, "C4.vs.all Main Effect states", 
               diffcyt::topTable(pool.C4_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
                 }         
     
 #        as<-  plotMedianExpressionBoxplot(d_medians=C3_DS$d_medians,cluster="Act_Exh_early_CD4",marker="CCR4",clinicalFactor="C4")
#   bs<-  plotMedianExpressionBoxplot(d_medians=C3_DS$d_medians,cluster="Tumor",marker="CXCR3",clinicalFactor="C4")
#  cs<-  plotMedianExpressionBoxplot(d_medians=C3_DS$d_medians,cluster="Hi_Supp_TREG",marker="ICOS",clinicalFactor="C4")
#  ds<-  plotMedianExpressionBoxplot(d_medians=C3_DS$d_medians,cluster="InflamTumor",marker="Tbet",clinicalFactor="C4")
#   grid.arrange(as,bs,cs, ds, nrow=2) 
  
###C5
      
 
 ##repeat measures.
  pool.C5_DA_RM <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    #formula = formula,
    design=design,
    contrast=createContrast(c(0,0,0,-1,-1,-1,-1,1,0,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(pool.C5_DA_RM,format_vals = TRUE,top_n=10,show_logFC = TRUE)
      
               if(writeToFile){
                addWorksheet(wb, "C5.vs.all Main Effect")
     writeData(wb, "C5.vs.all Main Effect", 
               diffcyt::topTable(pool.C5_DA_RM,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
               } 
 ##examine the states C2.
   pool.C5_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design = design,
    contrast=createContrast(c(0,0,0,-1,-1,-1,-1,1,0,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(pool.C5_DS,format_vals = TRUE,top_n=10,show_logFC = TRUE) 
  
                   if(writeToFile){
         addWorksheet(wb, "C5.vs.all Main Effect states")
     writeData(wb, "C5.vs.all Main Effect states", 
               diffcyt::topTable(pool.C5_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
                   }      
      
  #       as<-  plotMedianExpressionBoxplot(d_medians=C5_DS$d_medians,cluster="PDL1M2MAC",marker="Tbet",clinicalFactor="C5")
  # bs<-  plotMedianExpressionBoxplot(d_medians=C5_DS$d_medians,cluster="Tumor",marker="Tim3",clinicalFactor="C5")
  #cs<-  plotMedianExpressionBoxplot(d_medians=C5_DS$d_medians,cluster="PDL1M2MAC",marker="Vista",clinicalFactor="C5")
#   grid.arrange(as,bs,cs,  nrow=2) 
 
 
   
   
   
  ###Chapuy Comparison C1,C2,C5 vs C3 C4
   
     pool.C125_C34_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design = design,
    contrast=createContrast(c(0,1,0,1,1,-1,-1,1,1,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(pool.C125_C34_DS,format_vals = TRUE,top_n=10,show_logFC = TRUE) 
  
      
                 if(writeToFile){
      addWorksheet(wb, "C125.vs.all Main states")
     writeData(wb, "C125.vs.all Main states", 
               diffcyt::topTable(pool.C125_C34_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
     ## at end 
                 }
      
  
  ### REVISED AKIL REVISION        
     pool.C235_C14_DA <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design = design,
    contrast=createContrast(c(0,0,0,-1/2,1/3,1/3,-1/2,1/3,1,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(pool.C235_C14_DA,format_vals = TRUE,top_n=20,show_logFC = TRUE) 
  
      
                 if(writeToFile){
      addWorksheet(wb, "C235.vs.C14.Main DA")
     writeData(wb, "C235.vs.C14.Main DA", 
               diffcyt::topTable(pool.C235_C14_DA,format_vals = TRUE,top_n=20,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
                 }
      
      
     pool.C235_C14_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design = design,
    contrast=createContrast(c(0,0,0,-1/2,1/3,1/3,-1/2,1/3,1,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(pool.C235_C14_DS,format_vals = TRUE,top_n=20,show_logFC = TRUE) 
  
      
                 if(writeToFile){
      addWorksheet(wb, "C235.vs.C14.all Main DS")
     writeData(wb, "C235.vs.C14.all Main DS", 
               diffcyt::topTable(pool.C235_C14_DS,format_vals = TRUE,top_n=20,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
                 }  
      
      
      
     ##REVISED AKIL REVISION   35 vs 124      
     pool.C35_C124_DA <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design = design,
    contrast=createContrast(c(0,0,0,-1/3,-1/3,1/2,-1/3,1/2,1,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(pool.C35_C124_DA,format_vals = TRUE,top_n=20,show_logFC = TRUE) 
  
      
                 if(writeToFile){
      addWorksheet(wb, "C35.vs.C124.Main DA")
     writeData(wb, "C35.vs.C124.Main DA", 
               diffcyt::topTable(pool.C35_C124_DA,format_vals = TRUE,top_n=20,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
                 }
      
      
     pool.C35_C124_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design = design,
    contrast=createContrast(c(0,0,0,-1/3,-1/3,1/2,-1/3,1/2,1,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(pool.C35_C124_DS,format_vals = TRUE,top_n=20,show_logFC = TRUE) 
  
      
                 if(writeToFile){
      addWorksheet(wb, "C35.vs.C124.all Main DS")
     writeData(wb, "C35.vs.C124.all Main DS", 
               diffcyt::topTable(pool.C35_C124_DS,format_vals = TRUE,top_n=20,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
             }  

      
        

    ##ABC-vs-DLBCL  
   pool.C35_C14_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design = design,
    contrast=createContrast(c(0,0,0,-1/2,0,1/2,-1/2,1/2,0,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(pool.C35_C14_DS,format_vals = TRUE,top_n=20,show_logFC = TRUE)%>%data.frame 
  
      
                 if(writeToFile){
      addWorksheet(wb, "C35.vs.C14.all Main DS")
     writeData(wb, "C35.vs.C14.all Main DS", 
               diffcyt::topTable(pool.C35_C14_DS,format_vals = TRUE,top_n=20,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
             }    
      
      pool.C5_C1_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design = design,
    contrast=createContrast(c(0,0,0,-1,0,0,0,1,1,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(pool.C5_C1_DS,format_vals = TRUE,top_n=20,show_logFC = TRUE)%>%data.frame 
  
      
                 if(writeToFile){
      addWorksheet(wb, "C5.vs.C1.ABC.all Main DS")
     writeData(wb, "C5.vs.C1.ABC.all Main DS", 
               diffcyt::topTable(pool.C5_C1_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
             }    
      
      pool.C3_C4_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design = design,
    contrast=createContrast(c(0,0,0,0,0,1,-1,0,0,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(pool.C3_C4_DS,format_vals = TRUE,top_n=20,show_logFC = TRUE)%>%data.frame 
  
      
                 if(writeToFile){
      addWorksheet(wb, "C5.vs.C1.NGCB.all Main DS")
     writeData(wb, "C5.vs.C1.NGCB.all Main DS", 
               diffcyt::topTable(pool.C3_C4_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
             }      
      
      
   pool.C2_C14_DS <- diffcyt(sce,
                     clustering_to_use = "merging1",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design = design,
    contrast=createContrast(c(0,0,0,-1/2,1,0,-1/2,0,0,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(pool.C2_C14_DS,format_vals = TRUE,top_n=20,show_logFC = TRUE)%>%data.frame 
          
      if(writeToFile){
      addWorksheet(wb, "C2.vs.C14.all Main DS")
     writeData(wb, "C2.vs.C14.all Main DS", 
               diffcyt::topTable(pool.C2_C14_DS,format_vals = TRUE,top_n=20,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 

             }    
      
      ## at end 
     
  if(writeToFile){
 saveWorkbook(wb,paste0(outdir,"/Figure2_pooled_model_cofactor_5.xlsx"),overwrite=TRUE)
  }
      
```

## Hazard Estimate trends of C1/C4 vs. C3/C5,  and C2 (Figure 2C)
- REVISION 10-16: condence the graph, the event is set as refractory subjects.
- Shows the chapuy cluster hazards.
- Figure 2C: shows the hazards for Hi.supp T-reg:pSTAT3, and Hi.Supp Treg-Ki67
```{r}
   library(extrafont)
   # font_import()
      missingSurv<-c("3978",  "3979" , "39792", "4070","4071")
      noTreat<-full.dn4$ROIID[which(full.dn4$treatment.status=="ND")]%>%unique
      missingSurv<-paste0("ROIID_",missingSurv)
      noTreat<-paste0("ROIID_",noTreat)
      
   clinic2<- metadata(sce)$experiment_info
   clinic2$os_d<-full.dn4$os_d[match(clinic2$sample_id,paste0("ROIID_",full.dn4$ROIID))]
   clinic2$os<-full.dn4$os[match(clinic2$sample_id,paste0("ROIID_",full.dn4$ROIID))]
  clinic2$os_ref<-full.dn4$response[match(clinic2$sample_id,paste0("ROIID_",full.dn4$ROIID))]

### death status  
  clinic2$status<-ifelse(clinic2$os=="event",1,0)
    
## refractory status
      clinic2$refstatus<-ifelse(clinic2$os_ref=="Primary refract",1,0)

    

  
clinic2$C1f<-factor(clinic2$C1)
clinic2$C2f<-factor(clinic2$C2)
clinic2$C3f<-factor(clinic2$C3)
clinic2$C4f<-factor(clinic2$C4)
clinic2$C5f<-factor(clinic2$C5)
 ## individual hazard plots
c1cx<-coxph(Surv(os_d,status)~C1+highIPI,clinic2)
c2cx<-coxph(Surv(os_d,status)~C2+highIPI,clinic2)
c3cx<-coxph(Surv(os_d,status)~C3+highIPI,clinic2)
c4cx<-coxph(Surv(os_d,status)~C4+highIPI,clinic2)
c5cx<-coxph(Surv(os_d,status)~C5+highIPI,clinic2)

chpcx<-coxph(Surv(os_d,status)~C1+C2+C3+C4+C5+highIPI,clinic2)
 
cxs<- data.frame(Cox=(coef(chpcx)))

cxs$lower<-c((confint(chpcx)[,1]))

cxs$upper<-c((confint(chpcx)[,2]))

  cxs$Chapuy<-rownames(cxs)
  cxs$Chapuy[which(cxs$Chapuy=="highIPI")]<-"High IPI (>3)"
    #    ggplot(cxs[which(cxs$Chapuy!="highIPI"),],aes(x=(Cox),y=Chapuy,color=Chapuy))+geom_point(size=3)+scale_x_discrete(limits=0:9)+geom_vline(xintercept = 1,color="red",linetype="dashed")+theme_ipsum()+scale_color_manual(values=c("purple","skyblue","orange","cyan","red"))+coord_flip()  
#  ggplot(cxs[which(cxs$Chapuy!="highIPI"),],aes(y=(Cox),x=Chapuy,fill=Chapuy))+geom_bar(stat='identity')+scale_y_discrete(limits=0:9)+geom_hline(yintercept = 1,color="black",linetype="dashed")+theme_ipsum()+scale_fill_manual(values=c("purple","skyblue","orange","cyan","red"))+geom_errorbar(aes(ymax=upper/6,ymin=Cox),width=0.2)+theme(axis.text=element_text(color="black"))+ylab("Hazard Ratio (IPI adjusted)")+xlab("Molecular subtype")  
 #ggplot(cxs[which(cxs$Chapuy!="highIPI"),],aes(x=(Cox),y=Chapuy,fill=Chapuy))+geom_point(size=4)+scale_y_discrete(limits=0:9)+geom_hline(yintercept = 1,color="black",linetype="dashed")+theme_ipsum()+scale_fill_manual(values=c("purple","skyblue","orange","cyan","red"))+geom_errorbar(aes(ymax=upper/6,ymin=Cox),width=0.2)+theme(axis.text=element_text(color="black"))+ylab("Hazard Ratio (IPI adjusted)")+xlab("Molecular subtype")  

   death<- ggplot(cxs,aes(x=(Cox),y=Chapuy,color=Chapuy))+geom_point(size=4)+coord_fixed(ratio=0.25)+scale_x_discrete(limits=0:5)+geom_vline(xintercept=0,color="black",linetype="dashed")+theme_ipsum(base_family = "Arial")+scale_color_manual(values=c("darkslateblue","darkslateblue","red","darkslateblue","red","red"))+geom_errorbar(aes(xmax=upper,xmin=lower),width=0.2)+theme(axis.text=element_text(color="black"),legend.position="none")+xlab("Log hazards rate for death (95% CI)")+ylab("")  
  
## refractory status
 chpcx2<-coxph(Surv(os_d,refstatus)~C1+C2+C3+C4+C5+highIPI,clinic2)

   
cxs<- data.frame(Cox=(coef(chpcx2)))
cxs$lower<-c((confint(chpcx2)[,1]))
cxs$upper<-c((confint(chpcx2)[,2]))
  cxs$Chapuy<-rownames(cxs)
  cxs$Chapuy[which(cxs$Chapuy=="highIPI")]<-"High IPI (>3)"
  
  refr<-ggplot(cxs,aes(x=(Cox),y=Chapuy,color=Chapuy))+geom_point(size=4)+coord_fixed(ratio=0.25)+scale_x_discrete(limits=0:5)+geom_vline(xintercept=0,color="black",linetype="dashed")+theme_ipsum()+scale_color_manual(values=c("darkslateblue","darkslateblue","red","darkslateblue","red","red"))+geom_errorbar(aes(xmax=upper,xmin=lower),width=0.2)+theme(axis.text=element_text(color="black"),legend.position="none")+xlab("Log hazards rate for treatment refractory (95% CI)")+ylab("")  
  grid.arrange(death,refr,nrow=2)
  
  
## hi supp. t-reg.
load("~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/hyperframe/Hpool_continuousMarks.RData")
allPhenos<-  with(Hpool,unique(marks(point)$marks))%>%unlist%>%unique
 
 allD<-as.data.frame(matrix(NA,nrow=nrow(Hpool),ncol=length(allPhenos)))
 colnames(allD)<-allPhenos
 allD$ROI<-Hpool$ROI
 allD$pSTAT3<-NA
 allD$Ki67<-NA

  for( roi in Hpool$ROI){
   myr<-Hpool$point[[which(Hpool$ROI==roi)]]
   prd<-split(myr,factor(marks(myr)$marks))
   his<-prd[[which(names(prd)=="Hi.Suppress.T-reg(1,2,6)")]]
   pstat3<-marks(his)$pSTAT3
   ki<-marks(his)$Ki67
   allD[which(allD$ROI==roi),"pSTAT3"]<-mean(pstat3)
   allD[which(allD$ROI==roi),"Ki67"]<-mean(ki)
 
}
  
  
     hisp<-with(Hpool,100*length(which(marks(point)$marks=="Hi.Suppress.T-reg(1,2,6)"))/npoints(point))
  names(hisp)<-Hpool$ROI
  act<-with(Hpool,100*length(which(marks(point)$marks=="Act./Prolif.T-reg(5)"))/npoints(point))
  names(act)<-Hpool$ROI
  bt<-with(Hpool,100*length(which(marks(point)$marks=="Baseline T-reg(3,4)"))/npoints(point))
  names(bt)<-Hpool$ROI
  
  
  clinic2$HiSup<-hisp[match(clinic2$sample_id,names(hisp))]
  clinic2$pstat3<-allD$pSTAT3[match(clinic2$sample_id,names(hisp))]
  clinic2$Ki67<-allD$Ki67[match(clinic2$sample_id,names(hisp))]

  clinic2$act<-act[match(clinic2$sample_id,names(act))]
  clinic2$bt<-bt[match(clinic2$sample_id,names(bt))]
  clinic2$HiSup_pstat3<-clinic2$HiSup*clinic2$pstat3
  clinic2$HiSup_Ki67<-clinic2$HiSup*clinic2$Ki67

  hicx<-coxph(Surv(os_d,status)~HiSup_pstat3+act+bt+highIPI+HiSup_Ki67,clinic2) 
 cxs<- data.frame(Cox=(coef(hicx)))
 cxs$lower<-c((confint(hicx)[,1]))
 cxs$upper<-c((confint(hicx)[,2]))
 cxs$Chapuy<-c("Hi.Suppress.T-reg(1,2,6):pSTAT3", "Act./Prolif.T-reg(5)" , "Baseline T-reg(3,4)", "High IPI (>3)", "Hi.Suppress.T-reg(1,2,6):Ki67")
  
   
  
   death<- ggplot(cxs,aes(x=(Cox),y=Chapuy,color=Chapuy))+geom_point(size=5)+coord_fixed(ratio=1.25)+scale_x_discrete(limits=0:5)+geom_vline(xintercept=0,color="black",linetype="dashed")+theme_ipsum(axis_text_size=12)+scale_color_manual(values=c("gray38","blue","gray38","firebrick2","firebrick2"))+geom_errorbar(aes(xmax=upper,xmin=lower),width=0.2)+theme(axis.text=element_text(color="black"),legend.position="none")+xlab("Log hazards rate for death (95% CI)")+ylab("")  
  
   save(death,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-figure-revision/Final-figures-Tucker/Figure2/death.Figure2C.RData")
   ## table estimates
   library(sjPlot)
   tab_model(hicx,
              pred.labels = c("Hi.suppress.TREG(1,2,6):pSTAT3", 
                  "Act./Prolif.TREG(5)",
                  "Baseline TREG(3,4)",
                  "High IPI(>3)",
                  "Hi.Suppress.TREG(1,2,6):Ki67"
                    ),
    string.ci = "Conf. Int (95%)",
  string.p = "P-Value",
  show.aic=TRUE,
    file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-figure-revision/Treg-Cox-estimates/Figure2C_Cox.html"
)
   
```


## Global Expression high resolution comparing REF to CR

```{r}

   p <- plotPbExprs(sce, k = "merging1", 
                   color_by="REF")
  
 ## bar graph of global
  glob.expr<-as.data.frame(t(assays(sce)$exprs))
  rownames(glob.expr)<-colData(sce)$id
  glob.expr$patient_id<-colData(sce)$patient_id
  glob.expr$REF<-colData(sce)$REF

   avg<-glob.expr%>%group_by(patient_id,REF)%>%summarise_all(mean)
   
   ttestout<-function(marker=NULL){
     stats<-t.test(avg[which(avg$REF!="CR"),marker],avg[which(avg$REF=="CR"),marker])
     dat<-c(stats$estimate,stats$conf.int)
     names(dat)<-c("CR","REF","lower","upper")
     dat<-data.frame(t(dat))
     dat$marker<-marker
     dat$Z<-stats$statistic
     dat$p<-stats$p.value
     return(dat)
   }
     lmout<-function(marker=NULL){
       forms<-formula(paste0(marker,"~0+REF"))
        forms2<-formula(paste0(marker,"~REF"))
     stats<-lm(formula = forms, data = avg)
     stats2<-lm(formula = forms2, data = avg)
     confs<-confint(stats)
     dat<-c(coef(stats)[1],confs[1,1],confs[1,2])
     names(dat)<-c("estimate","lower","upper")
     dat<-data.frame(t(dat),treatment='REF',marker=marker,row.names=marker)
    ###
     dat2<-c(coef(stats)[2],confs[2,1],confs[2,2])
     names(dat2)<-c("estimate","lower","upper")
     dat2<-data.frame(t(dat2),treatment='CR',marker=marker,row.names=marker)
     dat<-rbind(dat,dat2)      
     dat$t<-coef(summary(stats2))[2,3]
     dat$p<-coef(summary(stats2))[2,4]
     return(dat)
     }
     fullDat<-NULL
   for(ph in colnames(avg)[c(19,21:33)]){
     dat<-lmout(marker=ph)
     if(is.null(fullDat)==TRUE){
       fullDat<-dat
     }else{
     fullDat<-rbind(fullDat,dat)
     }
   }  
     fullDat<-fullDat[order(abs(fullDat$t),decreasing=T),]
     fullDat$marker<-gsub("Tim3","TIM-3",fullDat$marker)
     fullDat$marker<-gsub("Vista","VISTA",fullDat$marker)
     fullDat$marker<-gsub("PDL1","PD-L1",fullDat$marker)
     fullDat$marker<-gsub("PDL2","PD-L2",fullDat$marker)
     fullDat$marker<-gsub("Lag3","LAG-3",fullDat$marker)
     fullDat$marker<-gsub("PD1","PD-1",fullDat$marker)
     fullDat$marker<-gsub("Tim3","TIM-3",fullDat$marker)

     
     fullDat$marker<-factor((as.character(fullDat$marker)),levels=unique(as.character(fullDat$marker)))
     fullDat$label<-""
     fullDat$label<-ifelse(fullDat$p<0.05,"*","")
     fullDat$label[which(fullDat$treatment=="CR")]<-""
     
     
    global.bar<-ggplot(fullDat,aes(x=marker,y=estimate,fill=treatment))+geom_bar(stat='identity',position='dodge')+geom_errorbar(aes(ymin=lower,ymax=upper),width=0.2,position=position_dodge(0.9))+scale_fill_manual(values=c("darkslateblue","firebrick2"))
   global.bar+geom_text(data=fullDat,label=fullDat$label,nudge_y=0.005,size=10)+theme_ipsum()+theme(axis.text=element_text(colour='black',size=5))+ylab("Average scaled intensity")+xlab("Marker")+ggtitle("Global expression difference")
    
  # add stars.
  
  
```

## Volcano of REF+IPI effect Family pooled (Figure 2B)
- FIXME: the legend is terrible need to fix.
```{r}
   
 library(hrbrthemes)
 getPhenoColorsAnnotatedLabel<-function(full.dn4,phenotype="annotated.label.back_akil"){
 ##this requires the T-Cell names to not be included.
 require(circlize)
  tsn<-full.dn4[which(!is.na(full.dn4$tSNE1) & !is.na(full.dn4$tSNE2)),c("tSNE1",
	"tSNE2",
	"Cell_CD20",
	"Cell_CD3",
	"Cell_CD4",
	"Cell_CD31",
	"Cell_CD4",
	"Cell_CD68",
	"Cell_CD8",
	"Cell_FOXP3",
	"Cell_BCL2",
	"uniqueLabel","response","ROIID",
	phenotype)]
  
  ##balanced response representation.
   tsn$primary.phenotype<-(tsn[,phenotype])
   labs<-unique(full.dn4$annotated.label.back_akil)
   
   cd8s<-colorRampPalette(c("darkseagreen","green"),5)
  cd4s<-colorRampPalette(c("lightsteelblue1","blue"),5)
  macs<-colorRampPalette(c("magenta","maroon4"),5)
   tregs<-colorRampPalette(c("plum2","purple"),5)
   tumrs<-colorRampPalette(c("grey24","grey64"),20)
endos<-colorRampPalette(c("rosybrown1","red"),20)

     phenoColors<-c(cd4s(length(labs[grepl("CD4",labs)])),
	cd8s(length(labs[grepl("CD8",labs)])),
	macs(length(labs[grepl("MAC",labs)])),
	tregs(length(labs[grepl("T-reg",labs)])),
	tumrs(length(labs[grepl("tumor",labs)])),
	'bisque',
	endos(length(labs[grepl("Endothelial",labs)]))
	)

  names(phenoColors)<-levels(full.dn4[,phenotype])   


   return(phenoColors)
 }

  akilColor<-getPhenoColorsAnnotatedLabel(full.dn4)
  akilColor<-c(akilColor,"lightskyblue3")
  names(akilColor)[length(akilColor)]<-"NS"
 
       plotDiffHeatmap(sce2, rowData(pool.joint_ref_IPI_DS$res), top_n = 10, fdr = 0.05,lfc=0)

  ##show REF main effect.
       
# res<- diffcyt::topTable(pool.joint_ref_IPI_DS,format_vals = TRUE,top_n=150,show_logFC = TRUE)%>%data.frame
 
  res<- diffcyt::topTable(pool.ref_DS,format_vals = TRUE,top_n=150,show_logFC = TRUE)%>%data.frame
  res<-res[which(res$p_adj<0.25),]
 res$log10p<-(-log10(res$p_adj))
 res$new_cluster<-as.character(res$cluster_id)
  res$marker_id<-as.character(res$marker_id)

 res$new_cluster[which(res$p_adj>0.05)]<-"NS"
 res$marker_id[which(res$p_adj>0.05)]<-""
 library(ggrepel)
 
# targs<-unique(res$new_cluster)
 
 ##add border around plot
 ## FIX ME: add outlines to the plots.
 #colnames(res)[which()]

  
  res$marker_id[which(res$new_cluster!="NS")]<-paste0(res$cluster_id[which(res$new_cluster!="NS")],": ",res$marker_id[which(res$new_cluster!="NS")])
    res<-res[which(res$p_adj<0.25),]
  res$new_cluster[1:2]<-res$marker_id[1:2]  
  
  
   akilColor["NS"]<-"darkgrey"
 akilColor["Hi.Suppress.T-reg(1,2,6): Ki67"]<-"lightblue1"
  akilColor["Hi.Suppress.T-reg(1,2,6): pSTAT3"]<-"lightpink"
targs<-unique(res$new_cluster)
 
vol<- ggplot(res,aes(x=logFC,y=log10p,fill=new_cluster,label=marker_id))
 vol+  geom_point(size = 6,alpha=1, shape=21,colour='black') + 
   scale_fill_manual(values=akilColor[targs])+
     theme_bw()+
      geom_label_repel(
        alpha=0.75,
        label.size=0.95,
     aes(label=factor(marker_id),size=0.75),
     fontface = 'bold', color = 'black',
    box.padding = unit(1.45, "lines"),
    point.padding = unit(1.05, "lines"),
    segment.color = 'grey50',
    show.legend=FALSE)+
   geom_hline(yintercept=1.29,linetype='dashed',size=1,color='gray56')+
   geom_vline(xintercept=0,linetype='dashed',size=1,color='gray56')+
   ylab("-log (base10) adjusted-p")+xlab('log (base 2) fold-change')+
    theme(axis.text = element_text(size=40), 
          axis.title.x=element_text(colour='black',size=12),
          axis.title.y=element_text(colour='black',size=12),
        axis.text.x = element_text(colour='black',size=15),
        axis.text.y = element_text(colour='black',size=15),legend.position="None"
    )
     
 refDSVol<-vol+  geom_point(size = 6,alpha=1, shape=21,colour='black') + 
   scale_fill_manual(values=akilColor[targs])+
     theme_bw()+
      geom_label_repel(
        alpha=0.75,
        label.size=0.95,
     aes(label=factor(marker_id),size=0.75),
     fontface = 'bold', color = 'black',
    box.padding = unit(1.45, "lines"),
    point.padding = unit(1.05, "lines"),
    segment.color = 'grey50',
    show.legend=FALSE)+
   geom_hline(yintercept=1.29,linetype='dashed',size=1,color='gray56')+
   geom_vline(xintercept=0,linetype='dashed',size=1,color='gray56')+
   ylab("-log (base10) adjusted-p")+xlab('log (base 2) fold-change')+
    theme(axis.text = element_text(size=40), 
          axis.title.x=element_text(colour='black',size=12),
          axis.title.y=element_text(colour='black',size=12),
        axis.text.x = element_text(colour='black',size=15),
        axis.text.y = element_text(colour='black',size=15),legend.position="None"
    )
 
 save(refDSVol,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-figure-revision/Final-figures-Tucker/Figure2/refDSVol.Figure2B.RData")
 ### NGCB+ high IPI.
 
  res<- diffcyt::topTable(pool.joint_ngcb_IPI_DS,format_vals = TRUE,top_n=150,show_logFC = TRUE)%>%data.frame

 res$log10p<-(-log10(res$p_adj))
 res$new_cluster<-as.character(res$cluster_id)
  res$marker_id<-as.character(res$marker_id)

 res$new_cluster[which(res$p_adj>0.05)]<-"NS"
 res$marker_id[which(res$p_adj>0.05)]<-""
 library(ggrepel)
 
 targs<-unique(res$new_cluster)
 
 ##add border around plot
 ## FIX ME: add outlines to the plots.
 #colnames(res)[which()]
  res$marker_id[which(res$new_cluster!="NS")]<-paste0(res$cluster_id[which(res$new_cluster!="NS")],": ",res$marker_id[which(res$new_cluster!="NS")])
    res<-res[which(res$p_adj<0.25),]
 
vol<- ggplot(res,aes(x=logFC,y=log10p,fill=new_cluster,label=marker_id))
 vol+  geom_point(size = 4,alpha=1, shape=21,colour='black') + 
   scale_fill_manual(values=akilColor[targs])+
     theme_bw()+
      geom_label_repel(
        alpha=0.75,
        label.size=0.75,
     aes(label=factor(marker_id),size=0.75,alpha=0.2),
     fontface = 'bold', color = 'black',
    box.padding = unit(0.45, "lines"),
    point.padding = unit(0.15, "lines"),
    segment.color = 'grey50',
    show.legend=FALSE)+
   geom_hline(yintercept=1.29,linetype='dashed',size=1,color='gray56')+
   geom_vline(xintercept=0,linetype='dashed',size=1,color='gray56')+
   ylab("-log (base10) adjusted-p")+xlab('log (base 2) fold-change')+
    theme(text = element_text(size=20), 
          axis.title.x=element_text(colour='black',size=12),
          axis.title.y=element_text(colour='black',size=12),
        axis.text.x = element_text(colour='black',size=15),
        axis.text.y = element_text(colour='black',size=15)
    )
 
 

```

### Volcano  C35 vs. C124
```{r}

 library(hrbrthemes)
 getPhenoColorsAnnotatedLabel<-function(full.dn4,phenotype="annotated.label.back_akil"){
 ##this requires the T-Cell names to not be included.
 require(circlize)
  tsn<-full.dn4[which(!is.na(full.dn4$tSNE1) & !is.na(full.dn4$tSNE2)),c("tSNE1",
	"tSNE2",
	"Cell_CD20",
	"Cell_CD3",
	"Cell_CD4",
	"Cell_CD31",
	"Cell_CD4",
	"Cell_CD68",
	"Cell_CD8",
	"Cell_FOXP3",
	"Cell_BCL2",
	"uniqueLabel","response","ROIID",
	phenotype)]
  
  ##balanced response representation.
   tsn$primary.phenotype<-(tsn[,phenotype])
   labs<-unique(full.dn4$annotated.label.back_akil)
   
   cd8s<-colorRampPalette(c("darkseagreen","green"),5)
  cd4s<-colorRampPalette(c("lightsteelblue1","blue"),5)
  macs<-colorRampPalette(c("magenta","maroon4"),5)
   tregs<-colorRampPalette(c("plum2","purple"),5)
   tumrs<-colorRampPalette(c("grey24","grey64"),20)
endos<-colorRampPalette(c("rosybrown1","red"),20)

     phenoColors<-c(cd4s(length(labs[grepl("CD4",labs)])),
	cd8s(length(labs[grepl("CD8",labs)])),
	macs(length(labs[grepl("MAC",labs)])),
	tregs(length(labs[grepl("T-reg",labs)])),
	tumrs(length(labs[grepl("tumor",labs)])),
	'bisque',
	endos(length(labs[grepl("Endothelial",labs)]))
	)

  names(phenoColors)<-levels(full.dn4[,phenotype])   


   return(phenoColors)
 }

  akilColor<-getPhenoColorsAnnotatedLabel(full.dn4)
  akilColor<-c(akilColor,"ivory4")
  names(akilColor)[length(akilColor)]<-"NS"
    akilColor[c("Baseline CD4(4)","Prolif.Endothelial(2)")]<-"lightblue1"
    akilColor[c("PD-L1+Endothelial(4)")]<-"lightpink"

  ##show REF main effect.
       
# res<- diffcyt::topTable(pool.joint_ref_IPI_DS,format_vals = TRUE,top_n=150,show_logFC = TRUE)%>%data.frame
 

  res<-topTable(pool.C35_C124_DA,format_vals = TRUE,top_n=50,show_logFC = TRUE)%>%data.frame

  
  res$log10p<-(-log10(res$p_adj))
  res$new_cluster<-as.character(res$cluster_id)
  res$marker_id<-res$new_cluster
  res$new_cluster[which(res$p_adj>0.05)]<-"NS"
  res$marker_id[which(res$p_adj>0.05)]<-""
  library(ggrepel)
 
 targs<-unique(res$new_cluster)
 
 ##add border around plot
 ## FIX ME: add outlines to the plots.
 #colnames(res)[which()]
 # res$marker_id[which(res$new_cluster!="NS")]<-paste0(res$cluster_id[which(res$new_cluster!="NS")],": ",res$marker_id[which(res$new_cluster!="NS")])
    res<-res[which(res$p_adj<1),]
 
  vol<- ggplot(res,aes(x=logFC,y=log10p,fill=new_cluster,label=marker_id))
  vol+  geom_point(size = 4,alpha=1, shape=21,colour='black') + 
   scale_fill_manual(values=akilColor[targs])+
     theme_bw()+
      geom_label_repel(
        alpha=0.75,
        label.size=0.75,
     aes(label=factor(marker_id),size=0.75),
     fontface = 'bold', color = 'black',
    box.padding = unit(0.45, "lines"),
    point.padding = unit(0.15, "lines"),
    segment.color = 'grey50',
    show.legend=FALSE)+
   geom_hline(yintercept=1.29,linetype='dashed',size=1,color='gray56')+
   geom_vline(xintercept=0,linetype='dashed',size=1,color='gray56')+
   ylab("-log (base10) adjusted-p")+xlab('log (base 2) fold-change')+
    theme(text = element_text(size=20), 
          axis.title.x=element_text(colour='black',size=12),
          axis.title.y=element_text(colour='black',size=12),
        axis.text.x = element_text(colour='black',size=15),
        axis.text.y = element_text(colour='black',size=15),
        legend.position="none"
    )
     

 ### NGCB+ high IPI.
 
  res<- diffcyt::topTable(pool.joint_ngcb_IPI_DS,format_vals = TRUE,top_n=150,show_logFC = TRUE)%>%data.frame

 res$log10p<-(-log10(res$p_adj))
 res$new_cluster<-as.character(res$cluster_id)
  res$marker_id<-as.character(res$marker_id)

 res$new_cluster[which(res$p_adj>0.05)]<-"NS"
 res$marker_id[which(res$p_adj>0.05)]<-""
 library(ggrepel)
 
 targs<-unique(res$new_cluster)
 
 ##add border around plot
 ## FIX ME: add outlines to the plots.
 #colnames(res)[which()]
  res$marker_id[which(res$new_cluster!="NS")]<-paste0(res$cluster_id[which(res$new_cluster!="NS")],": ",res$marker_id[which(res$new_cluster!="NS")])
    res<-res[which(res$p_adj<0.25),]
 
vol<- ggplot(res,aes(x=logFC,y=log10p,fill=new_cluster,label=marker_id))
 vol+  geom_point(size = 4,alpha=1, shape=21,colour='black') + 
   scale_fill_manual(values=akilColor[targs])+
     theme_bw()+
      geom_label_repel(
        alpha=0.75,
        label.size=0.75,
     aes(label=factor(marker_id),size=0.75,alpha=0.2),
     fontface = 'bold', color = 'black',
    box.padding = unit(0.45, "lines"),
    point.padding = unit(0.15, "lines"),
    segment.color = 'grey50',
    show.legend=FALSE)+
   geom_hline(yintercept=1.29,linetype='dashed',size=1,color='gray56')+
   geom_vline(xintercept=0,linetype='dashed',size=1,color='gray56')+
   ylab("-log (base10) adjusted-p")+xlab('log (base 2) fold-change')+
    theme(text = element_text(size=20), 
          axis.title.x=element_text(colour='black',size=12),
          axis.title.y=element_text(colour='black',size=12),
        axis.text.x = element_text(colour='black',size=15),
        axis.text.y = element_text(colour='black',size=15)
    )
 
 


```


### Spatial interaction from Dr. Merchant's annotation label
- REVISION 9-6: We want to examine the TREG interactions using the updated phenotype labels. neighborhood analysis using 1,000 permutations and p-threshold of 0.01 to compare tumor neighborhoods.
- family level spatial interactions. 
- we plot the heatmap using absolute proportions of the (p=0.01) significant results.
```{r nbhdREFCR,eval=FALSE,warning=FALSE,message=FALSE,fig.height = 13, fig.width = 18}
 
 ##perform's Vito's interaction/permutations.
 # can be slow.
  dat_cells<-data.frame(ImageNumber=full.dn4$ROIID,
	ObjectNumber=full.dn4$CellId,
	label=as.character(full.dn4$annotated.label.simple_akil),
	group=full.dn4$ROIID)
  dat_cells<-data.table(dat_cells)
  
  dat_relation_15<-createRelationTable(dn5=full.dn4,
	myPheno="annotated.label.simple_akil",
	minDistance=15)
  
  save(dat_relation_15,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/dat_relation_15_annotated.label.simple_akil.15distance.p025.RData")
  
  
 load("C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/dat_relation_15_annotated.label.simple_akil.15distance.p025.RData")

  
 ## using the p=0.01 threshold.
  p1<-makePermutationNBHD(dat_cells=dat_cells,
	dat_relation=dat_relation_15,
	n_perm=1000,pthreshold=0.01)

  save(p1,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/p1_15_annotated.label.simple_akil.15distance.01.RData")

  
  
  
```



### Family Level Figure Revision of Analysis Results
- family level analysis of abundance and state
- heatmap to show chapuy clusters
- state change analysis
- references to the spatial interaction model.
```{r}

 zz<- zScorePatientExpression(full.dn4=full.dn4,markers=c(1:31,104:111),ROIID.column=32)
  zz[,c(1:31,32,104:111)]%>%group_by(ROIID)%>%summarise_all(funs(sd))%>%data.frame
  zz[,c(1:31,32,104:111)]%>%group_by(ROIID)%>%summarise_all(funs(mean))%>%data.frame
  ##note for the original expression profile we keep ND and all patients, but remove Tumor_11 dimCD20 from the analysis.  we omit Tumor_11 cluster. must keep ND subjects.

 ## for phenotype analysis we remove dim CD20, (Tumor_11) cluster.
   zz<-zz[which(zz$dimCD20.filtered=='NO'),]

 ## show the ROI standardization.
  z<-zz


   X<-z[,c(1:31,which(colnames(z)=='annotated.label.simple_akil'))]%>%group_by(annotated.label.simple_akil)%>%summarise_all(funs(mean))%>%data.frame
   colnames(X)<-gsub("Cell_","",colnames(X))
   X$annotated.label.simple_akil<-factor(X$annotated.label.simple_akil)
  X$annotated.label.simple_akil<-droplevels(X$annotated.label.simple_akil)
 colnames(X)[which(colnames(X)=='C')]<-'cMYC'
 colnames(X)[which(colnames(X)=='p')]<-'pSTAT3'
 colnames(X)[which(colnames(X)=='Tim3')]<-'TIM-3'
 colnames(X)[which(colnames(X)=='Vista')]<-'VISTA'
  colnames(X)[which(colnames(X)=='PDL1')]<-'PD-L1'
   colnames(X)[which(colnames(X)=='PD1')]<-'PD-1'
   colnames(X)[which(colnames(X)=='PDL2')]<-'PD-L2'
  colnames(X)[which(colnames(X)=='Lag3')]<-'LAG-3'

 require(dendsort);require(pvclust)
  rpt.pv<-pvclust(log(1+X[,-1]),nboot=100,method.hclust="average")
  rpt.dend<-dendsort(hclust(dist(log(1+X[,c(-1)]))),isReverse=TRUE)
  library(ComplexHeatmap);library(dendextend)

  
    ## Map cluster colors to family level.
   phenoColors<-getPhenoColors(full.dn4)
   
   phenoCols<-c(phenoColors[1:4],phenoColors[8:11], phenoColors[16:18],phenoColors[22:24],phenoColors[c(28,31)], phenoColors[15])
   names(phenoCols)<-c("Act_Exh_early_CD4",
                       "Act_prol_CD4",
                       "Baseline_CD4",
                       "Late_Exhausted_CD4",
                       "Act_prol_CD8",
                       "Baseline_CD8",
                        "Exh_Inflam_CD8",
                       "Term_Exh_CD8",
                       "M1MAC",
                       "M2MAC",
                       "PDL1M2MAC",
                       "Act_prol_TREG",
                       "Baseline_TREG",
                       "Hi_Supp_TREG",
                       "Tumor",
                       "InflamTumor",
                       "Endothelial")
                      
    phenoColors<-phenoCols                             
   #################################                                                                   
 
   
  heats<-Heatmap(X[,c(-1)],
                 cluster_rows=rpt.dend,
                cluster_columns=rpt.pv$hclust,
 name="Measurement mean",
rect_gp = gpar(col = "white", lwd = 1))

    rpt.dend=color_branches(rpt.dend,k=17,
	col=phenoCols[as.character(X$annotated.label.simple_akil[row_order(heats)])])
  ###need to set rownames.  
    rownames(X)<-X$annotated.label.simple_akil
  
  
 ### annotation row for COO.
 txb.df<-data.frame(Phenotype=X$annotated.label.simple_akil)
 txb.sel.col=list(Phenotype=phenoColors[match(levels(X$annotated.label.simple_akil),names(phenoColors))])
  
   
 rowAnn <- rowAnnotation(df=txb.df, 
	col=txb.sel.col,
	 annotation_width=unit(c(1, 3), "cm"), 
	gap=unit(1, "mm"),annotation_legend_param=list(Phenotype=list(ncol=3,title_position="topcenter")))

 ##FIX The row annotation need to be included to the heatmap to have the row labeling.
  heats<-Heatmap(as.matrix(X[,c(-1)]),
                  cluster_rows=rpt.dend,
                  cluster_columns=rpt.pv$hclust,
		name="Measurement mean",
		right_annotation = rowAnn,
		rect_gp = gpar(col = "white", lwd = 1))
 
 
  clustSize<-as.data.frame(table(full.dn4$annotated.label.simple_akil))
  rownames(clustSize)<-clustSize$Var1
 clustSize<-clustSize[match(X$annotated.label.simple_akil,clustSize$Var1),]
  #clustSize<-clustSize[row_order(heats),]
  #rownames(clustSize)<-clustSize[,"Var1"]
 
  clustSize<-data.frame(count=clustSize[,-1],row.names=rownames(clustSize))
  clustSize$class<-"TME"
  clustSize$class[grepl("Tumor",rownames(clustSize))]<-"Tumor"
  clustSize%>%group_by(class)%>%summarise_all(sum)
  clustSize$prop<-1
  clustSize$prop[which(clustSize$class=="TME")]<-clustSize$count[which(clustSize$class=="TME")]/sum(clustSize$count[which(clustSize$class=="TME")])
    clustSize$prop[which(clustSize$class!="TME")]<-clustSize$count[which(clustSize$class!="TME")]/sum(clustSize$count[which(clustSize$class!="TME")])
    clustSize$prop<-100*clustSize$prop
  
  
   ## annotation bar plot of cluster size.
  size<-rowAnnotation("Cluster(%)" = anno_barplot(clustSize$prop,
	 gp = gpar(fill = phenoColors[match(levels(X$annotated.label.simple_akil),names(phenoColors))]), 
    axis_param = list(direction = "reverse"), border=FALSE,
    bar_width = 1, width = unit(2, "cm")))
 
  size+heats
   
 
  
c1size<-findChapuyProportion(sce=sce,cluster="C1",phenotype="annotated.label.simple_akil",tmeOnly = TRUE)
c2size<-findChapuyProportion(sce=sce,cluster="C2",phenotype="annotated.label.simple_akil",tmeOnly = TRUE)
c3size<-findChapuyProportion(sce=sce,cluster="C3",phenotype="annotated.label.simple_akil",tmeOnly = TRUE)
c4size<-findChapuyProportion(sce=sce,cluster="C4",phenotype="annotated.label.simple_akil",tmeOnly = TRUE)
c5size<-findChapuyProportion(sce=sce,cluster="C5",phenotype="annotated.label.simple_akil",tmeOnly = TRUE)


mySelection<-"Z"

chapSize<-data.frame(C1=c1size[,mySelection],C1prop=c1size[,"chapuyProp"],
                     C2=c2size[,mySelection],C2prop=c2size[,"chapuyProp"],
                     C3=c3size[,mySelection],C3prop=c3size[,"chapuyProp"],
                     C4=c4size[,mySelection],C4prop=c4size[,"chapuyProp"],
                     C5=c5size[,mySelection],C5prop=c5size[,"chapuyProp"],
                     row.names=rownames(c1size))


 chapSize<-chapSize[match(X$annotated.label.simple_akil,rownames(chapSize)),]
  ## annotation bar plot of cluster size.

  require(circlize)
   enrich_fun<-colorRamp2(c(-3,0,3),c("blue","grey96","red"))


c1ha = rowAnnotation(C1= anno_points(rep(0.5,nrow(X)), 
    ylim = c(0,1),
    width = unit(0.75, "cm"),
   # gp = gpar(col = phenoColors[match(levels(X$annotated.label.simple_akil),names(phenoColors))], ),
    gp=gpar(col=enrich_fun(chapSize$C1)),
    pch=16,
    border = FALSE,
  # size=unit(3,"mm"),
    size=unit(chapSize$C1prop,"mm"),
    axis_param = list(
        side = "bottom",
        at = c(0,0.5,1), 
        labels = c(""),
        labels_rot = 45
    ))
)
c1ha+heats  
	

c2ha = rowAnnotation(C2= anno_points(rep(0.5,nrow(X)), 
    ylim = c(0,1),
    width = unit(0.55, "cm"),
   # gp = gpar(col = phenoColors[match(levels(X$unsup.subcommunity),names(phenoColors))]),
       gp=gpar(col=enrich_fun(chapSize$C2)),
    pch=16,
    border = FALSE,
    size=unit(chapSize$C2prop,"mm"),
    #size=unit(3,"mm"),
    axis_param = list(
        side = "bottom",
        at = c(0,0.5,1), 
        labels = c(""),
        labels_rot = 45
    ))
)
c1ha+c2ha+heats  


c3ha = rowAnnotation(C3= anno_points(rep(0.5,nrow(X)), 
    ylim = c(0,1),
    width = unit(0.55, "cm"),
    #gp = gpar(col = phenoColors[match(levels(X$unsup.subcommunity),names(phenoColors))]),
     gp=gpar(col=enrich_fun(chapSize$C3)),
    pch=rep(16,nrow(X)),
    border = FALSE,
    size=unit(chapSize$C3prop,"mm"),
   # size=unit(3,"mm"),
    axis_param = list(
        side = "bottom",
        at = c(0,0.5,1), 
        labels = c(""),
        labels_rot = 45
    ))
)
c1ha+c2ha+c3ha+heats  

c4ha = rowAnnotation(C4= anno_points(rep(0.5,nrow(X)), 
    ylim = c(0,1),
    width = unit(0.55, "cm"),
         gp=gpar(col=enrich_fun(chapSize$C4)),
   # gp = gpar(col = phenoColors[match(levels(X$unsup.subcommunity),names(phenoColors))]),
    pch=16,
    border = FALSE,
    size=unit(chapSize$C4prop,"mm"),
   # size=unit(3,"mm"),
    axis_param = list(
        side = "bottom",
        at = c(0,0.5,1), 
        labels = c(""),
        labels_rot = 45
    ))
)


c5ha = rowAnnotation(C5=anno_points(rep(0.5,nrow(X)), 
    ylim = c(0,1),
    width = unit(0.55, "cm"),
   gp=gpar(col=enrich_fun(chapSize$C5)),
  #  gp = gpar(col = phenoColors[match(levels(X$unsup.subcommunity),names(phenoColors))]),
    pch=16,
    border = FALSE,
   # size=unit(3,"mm"),
    size=unit(chapSize$C5prop,"mm"),
    axis_param = list(
        side = "bottom",
            at = c(0,0.5,1), 
        labels = c(""),
        labels_rot = 45
    ))
)
lgd_sig1 = Legend(title='Mol. Signature Z-ScorE',
                 pch = 16,
              size=unit(c(1,2,3,5,6),"mm"),
               type = "points", 
              labels = c("<1%","2-5%","5-10%","15-20%",">20%"))

lgd_sig2 = Legend(col_fun = enrich_fun, title = "Mol. Signature Z-score")
draw(size+c1ha+c2ha+c3ha+c4ha+c5ha+heats,
     annotation_legend_list=(list(lgd_sig1,lgd_sig2)))




   require(circlize)
   col_fun<-colorRamp2(c(-15,0,15),c("blue","grey96","red"))



 ## IPI
  key<-createAnnotation(DS=res_IPI.LDH2,full.dn4,X=X,phenotype="annotated.label.simple_akil")
  ipianno <- HeatmapAnnotation("IPI"=anno_simple(key[,"logFC"],
                                            pch=key$symbol,
                                            col=col_fun,
                                            border=TRUE,
                                            width=unit(2.9,'mm'),
                                            pt_size=unit(2,'mm'),
                                            gp=gpar(col='grey79')),
                                            which="row")
  
  ##joint-effect- double expressor
  key<-createAnnotation(DS=joint_de_DA,full.dn4,X=X,phenotype="annotated.label.simple_akil")
  deanno <- HeatmapAnnotation("Dbl.Expressor/IPI"=anno_simple(key[,"logFC"],
                                            pch=key$symbol,
                                            col=col_fun,
                                            border=TRUE,
                                            width=unit(2.9,'mm'),
                                            pt_size=unit(2,'mm'),
                                            gp=gpar(col='grey79')),
                                            which="row")
  
  ##joint-effect-IPI NGCB
  key<-createAnnotation(DS=joint_ngcb_IPI_DA,full.dn4,X=X,phenotype="annotated.label.simple_akil")
  ngcb.ipi <- HeatmapAnnotation("NGCB/IPI"=anno_simple(key[,"logFC"],
                                            pch=key$symbol,
                                            col=col_fun,
                                            border=TRUE,
                                            width=unit(2.9,'mm'),
                                            pt_size=unit(2,'mm'),
                                            gp=gpar(col='grey79')),
                                            which="row")
  
   ##joint-effect-IPI REF
  key<-createAnnotation(DS=joint_ref_IPI_DA,full.dn4,X=X,phenotype="annotated.label.simple_akil")
  ref.ipi <- HeatmapAnnotation("REF/IPI"=anno_simple(key[,"logFC"],
                                            pch=key$symbol,
                                            col=col_fun,
                                            border=TRUE,
                                            width=unit(2.9,'mm'),
                                            pt_size=unit(2,'mm'),
                                            gp=gpar(col='grey79')),
                                            which="row")
  
    
 model_pvalue = Legend(title = "log FC", col_fun =col_fun, at = c(-15, 0, 15), 
    labels = c("-13", "0", "13"))
 # and one for the significant p-values
 model_lgd_sig = Legend(title='Adj. Significance',pch = c(17,3,7), type = "points", labels = c("q< 0.09","q< 0.05","q< 0.01"))
 
  
 draw(size+c1ha+c2ha+c3ha+c4ha+c5ha+ipianno+deanno+ngcb.ipi+ref.ipi+heats,
     annotation_legend_list=(list(lgd_sig1,lgd_sig2,model_pvalue,model_lgd_sig)))

 
  
##### abundance changes for chapuy (which for most we see the null)  

 
 ##state changes. the model of interest is IPI+REF+NGCB  state differential.
   top<- diffcyt::topTable(joint_ref_NGCB_IPI_DS,format_vals = TRUE,top_n=45,show_logFC = TRUE)%>%as.data.frame
 
   top<-top[which(top$cluster_id!="none"),]
    top$marker_id<-as.character(top$marker_id)
    top<-top[which(top$p_adj<0.09& top$marker_id%in%c("PD1","ICOS","p","PDL1","PD1","Lag3","CXCR3","Tbet","Ki67","Vimentin","Vista")),]
    #top$marker_id[which(top$marker_id=="Lag3")]<-"LAG3"
    #top$marker_id[which(top$marker_id=="Tim3")]<-"TIM3"
     #     top$marker_id[which(top$marker_id=="p")]<-"pSTAT3"
          
          
  
    rez<-matrix(0,nrow=nrow(top),ncol=38)
    rownames(rez)<-paste0(top$marker_id,"(",top$cluster_id,")")
   colnames(rez)<-exper_info2$sample_id

   for(j in 1:nrow(top)){
        myDat<-grabMedianNormalized(d_medians=joint_ref_NGCB_IPI_DS$d_medians,cluster=as.character(top$cluster_id[j]),marker=as.character(top$marker_id[j]))
      targ<-paste0(as.character(top$marker_id[j]),"(",as.character(top$cluster_id[j]),")")
      myDat[which(is.na(myDat[,1])),1]<-mean(myDat[which(!is.na(myDat[,1])),1])
   rez[targ,match(rownames(myDat),colnames(rez))]<-myDat[,1]
      }
  
   
  
   
   tt<-exper_info2[match(colnames(rez),exper_info2$sample_id),c("highIPI","group_id")]
   rownames(tt)<-colnames(rez)
   tt$highIPI<-ifelse(tt$highIPI==1,"High/Intermediate risk","Low risk")
   
   column_ha = HeatmapAnnotation(R.IPI=tt[,1],REF=tt[,2],
                                 col=list(R.IPI=c("High/Intermediate risk"="red","Low risk"="blue"),REF=c("Primary refract"="red","CR"="blue")))

    require(dendsort);require(pvclust)
  rpt.pv<-pvclust(log(1+rez),nboot=100,method.hclust="average")
  rpt.dend<-dendsort(hclust(dist(log(1+rez))),isReverse=TRUE)
  library(ComplexHeatmap);library(dendextend)
  

   Heatmap(asinh(rez), name="Normalized",
           cluster_rows=rpt.dend,
                show_row_dend = FALSE,
                  cluster_columns=rpt.pv$hclust,
           top_annotation = column_ha,show_column_names = FALSE )
   
   
  #ERRORS OUT
  #    plotDiffHeatmap(sce,rowData(combo_DS$res),top_n=10,fdr=0.1,lfc=0)
      
      
          write.csv(as.data.frame(topTable(combo_DS,format_vals = TRUE,top_n=60,show_logFC = TRUE)),
    file=paste0("C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/","/STATES_IPI_C125.vs.C34.omitND.noContrast_repeatMeasure.csv"))
   

          
          
##CHapuy Model.
##Combination state changes.
##NGCB+IPI+ (1/3)C1+c2+C5 - (1/2)C3+C4          
     combo_DS <- diffcyt(sce,
                     clustering_to_use = "custom",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=50,
    min_samples=4,
    normalize=TRUE,
    design=design,
    contrast=createContrast(c(0,0,1,0,0,0,0,0,1,0,0,rep(0,7))),
    verbose = FALSE)
     top<- diffcyt::topTable(combo_DS,format_vals = TRUE,top_n=50, show_logFC = TRUE)%>%as.data.frame
     
    top<-top[which(top$cluster_id!="none"),]
    top$marker_id<-as.character(top$marker_id)
    top<-top[which(top$p_adj<0.08& top$marker_id%in%c("PD1","ICOS","p","PDL1","PD1","Lag3","CXCR3","Tbet","Ki67","Vimentin","HLADR")),]
         
          
  
    rez<-matrix(0,nrow=nrow(top),ncol=38)
    rownames(rez)<-paste0(top$marker_id,"(",top$cluster_id,")")
   colnames(rez)<-exper_info2$sample_id

   for(j in 1:nrow(top)){
        myDat<-grabMedianNormalized(d_medians=combo_DS$d_medians,cluster=as.character(top$cluster_id[j]),marker=as.character(top$marker_id[j]))
      targ<-paste0(as.character(top$marker_id[j]),"(",as.character(top$cluster_id[j]),")")
      myDat[which(is.na(myDat[,1])),1]<-mean(myDat[which(!is.na(myDat[,1])),1])
   rez[targ,match(rownames(myDat),colnames(rez))]<-myDat[,1]
      }
  
   
 
   tt<-exper_info2[match(colnames(rez),exper_info2$sample_id),c("highIPI","group_id")]
   rownames(tt)<-colnames(rez)
   tt$highIPI<-ifelse(tt$highIPI==1,"High/Intermediate risk","Low risk")
   
   column_ha = HeatmapAnnotation(R.IPI=tt[,1],REF=tt[,2],
                                 col=list(R.IPI=c("High/Intermediate risk"="red","Low risk"="blue"),REF=c("Primary refract"="red","CR"="blue")))

    require(dendsort);require(pvclust)
  rpt.pv<-pvclust(log(1+rez),nboot=100,method.hclust="average")
  rpt.dend<-dendsort(hclust(dist(log(1+rez))),isReverse=TRUE)
  library(ComplexHeatmap);library(dendextend)
  

   Heatmap(asinh(rez), name="Normalized",
           cluster_rows=rpt.dend,
                show_row_dend = FALSE,
                  cluster_columns=rpt.pv$hclust,
           top_annotation = column_ha,show_column_names = FALSE )
   
  
          write.csv(as.data.frame(topTable(combo_DS,format_vals = TRUE,top_n=60,show_logFC = TRUE)),
    file=paste0("C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/multivariate-contrasts","/STATES_IPI_C125.NGCB.vs.C34.omitND.repeatMeasure.csv"))
   
  

```


### Cluster Level Analysis
- Figure making and Bodnemiller showed cluster level analysis results in a figure.
- we show heterogeneity of cluster abundance changes in the figure.
- COO was not significant in terms of abundance, and we dropped from the model, and significant results for most terms were then observed. it looks like COO is not a good feature.
- REVISION 8-29: The cluster model identified significant differences, but plotting the Abundances via `plotAbundances` identified false positives due to CPM normalization by examining enriched clusters in REF, but looking at the actual distribution boxplots revealsed that Tumor_1 is 100% in CR, yet shows REF positive association. this is omitted from the model result.
- REVISION 8-31: the model changed when  using the `mergecluster()` command, i'm not sure why.  i think it has to do with the way it was manually creating the column clusters in the `colData()` slot, could have been a mistake.  A sanity check would be to look at the "custom" slot, and compare with the sub-annotated clusters.  this is a problem FIX ME
```{r}


    outdir<-"C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-model-worksheets/Figure2-9-20/"
   writeToFile<-TRUE
  if(writeToFile){
    library(openxlsx)
    wb <- createWorkbook(
  creator = "Anthony",
  title = "Figure 2 9-20-Revision",
  subject = "DLBCL Cluster Level Analysis",
  category = "Immunology/IMC"
  )
  }  
   
   
   minCells=50
   minSamp=7
 
  design <- createDesignMatrix(exper_info2, cols_design = c("group_id",
 "C1","C2","C3","C4","C5",
  "highIPI",
 "Gender",
  "doubleExpressor",
"patient_id"))

design<-design[,which(colSums(design)>1)]
 



  #colData(sce)$cluster_id<-factor(full.dn4$unsup.subcommunity[match(colData(sce)$id,full.dn4$uniqueLabel)])
  #metadata(sce)$cluster_codes$custom<-NULL
  #metadata(sce)$cluster_codes<-data.frame(custom=factor(unique(colData(sce)$cluster_id)))

 markersToTest<- rownames(rowData(sce))[which(rowData(sce)$marker_class=='state')]
 markersToTest<-markersToTest[which(markersToTest!="p" & markersToTest!="Tbet")]
 markersToTest<-rownames(rowData(sce))%in%markersToTest
 
#########Convergence issues.    
 ##compare with design    
 res_IPI.LDH2 <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    #formula = formula,
    design=design,
    plot=TRUE,
        contrast=createContrast(c(0,0,0,0,0,0,0,1,0,0,rep(0,7))),
  #  contrast=createContrast(c(0,0,0,0,0,0,0,0,1,0,0,rep(0,7))),
    verbose = FALSE)
 
 
    diffcyt::topTable(res_IPI.LDH2,format_vals = TRUE,top_n=10,show_logFC =TRUE)
    
   

    
  if(writeToFile){
 ## write out the data to Figure3 table.
     addWorksheet(wb, "IPI main effect")
     writeData(wb, "IPI main effect", 
               diffcyt::topTable(res_IPI.LDH2,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
                      
  }


   #plotAbundanceCPMDiffCyt(d_counts=res_IPI.LDH2$d_counts,cluster="TREG_5",marker=NULL,clinicalFactor="highIPI")

        
##states edgeR
        state_IPI.LDH2 <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    markers_to_test = markersToTest,
    design=design,
    plot=TRUE,
   contrast=createContrast(c(0,0,0,0,0,0,0,1,0,0,rep(0,7))),
    verbose = FALSE)
 
 
    diffcyt::topTable(state_IPI.LDH2,format_vals = TRUE,top_n=20,show_logFC =TRUE)
    
     if(writeToFile){
   addWorksheet(wb, "IPI main effect state")
     writeData(wb, "IPI main effect state", 
               diffcyt::topTable(state_IPI.LDH2,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
     }

     
 

############################################################
#  Double Expressor    
#######################################################
##DE !=0 vs. others not contrast
  
 
 ###################
## EDGE R
 ##
 ########################
    ngcb_DA <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    design = design,
            contrast=createContrast(c(0,0,0,0,0,0,0,0,0,1,rep(0,7))),
  #  contrast=createContrast(c(0,1,0,0,0,0,0,0,0,0,0,rep(0,7))),
    verbose = FALSE)
      diffcyt::topTable(ngcb_DA,format_vals = TRUE,top_n=10, show_logFC = TRUE)
  
       if(writeToFile){
      addWorksheet(wb, "DE main effect")
     writeData(wb, "DE main effect", 
               diffcyt::topTable(ngcb_DA,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
       }
      
     # aNG<- plotAbundanceCPMDiffCyt(d_counts=ngcb_DA$d_counts,cluster="CD4_6",marker=NULL,clinicalFactor="doubleExpressor")
    #   aNG2<- plotAbundanceCPMDiffCyt(d_counts=ngcb_DA$d_counts,cluster="Tumor_3",marker=NULL,clinicalFactor="doubleExpressor")
     #grid.arrange(aNG,aNG2,nrow=1,ncol=2)
 
 
  #### double expressor joint effect with IPI.
 
  joint_IPI_DE_DA <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    design = design,
            contrast=createContrast(c(0,0,0,0,0,0,0,1,0,1,rep(0,7))),
  #  contrast=createContrast(c(0,1,0,0,0,0,0,0,0,0,0,rep(0,7))),
    verbose = FALSE)
      diffcyt::topTable(joint_IPI_DE_DA,format_vals = TRUE,top_n=10, show_logFC = TRUE)
   if(writeToFile){
        addWorksheet(wb, "DE+IPI main effect")
     writeData(wb, "DE+IPI main effect", 
               diffcyt::topTable(joint_IPI_DE_DA,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
   }
        
 
 
 ##convergence issues with mixed, so repeated measures is used here.
# markersTest<-rownames(rowData(sce))%in%c("PDL1","PDL2","Tim3","PD1","Lag3","ICOS","Vimentin","CXCR3","CCR4","Vista")
 ngcb_DS <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
   min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
   # formula = formula,
   design=design,
    markers_to_test = markersToTest,
   contrast=createContrast(c(0,0,0,0,0,0,0,0,0,1,rep(0,7))),
    verbose = FALSE)
 diffcyt::topTable(ngcb_DS,show_logFC = TRUE)
    if(writeToFile){
      addWorksheet(wb, "DE main effect state")
     writeData(wb, "DE main effect state", 
               diffcyt::topTable(ngcb_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
    }
 
   #as<-  plotMedianExpressionBoxplot(d_medians=ngcb_DS$d_medians,cluster="Exh_Inflam_CD8",marker="C",clinicalFactor="NGCB")
  # bs<-  plotMedianExpressionBoxplot(d_medians=ngcb_DS$d_medians,cluster="Act_Exh_early_CD4",marker="CXCR3",clinicalFactor="NGCB")
  # cs<-  plotMedianExpressionBoxplot(d_medians=ngcb_DS$d_medians,cluster="Tumor",marker="CXCR3",clinicalFactor="NGCB")
  # ds<-  plotMedianExpressionBoxplot(d_medians=ngcb_DS$d_medians,cluster="PDL1M2MAC",marker="Vista",clinicalFactor="NGCB")

  # grid.arrange(as,bs,cs,ds, nrow=2)




#########################################


##refractory  effects contrasted against age, sex, ethnicity
## refractory is not associated with age, gender, ethnicity
## refractory is association with IPI and NGCB (we average those)
## refractory is marginal associated with LDH.
 

 
     
############# repeated measures.
     ref_DA <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    design=design,
   contrast=createContrast(c(0,1,0,0,0,0,0,1,0,0,rep(0,7))),
   # contrast=createContrast(c(0,1,0,0,0,0,0,0,0,0,rep(0,7))),
    verbose = FALSE)
     
      topTable(ref_DA,format_vals = TRUE,top_n=10,show_logFC = TRUE)
    
  
       if(writeToFile){
     addWorksheet(wb, "REF+IPI main effect")
     writeData(wb, "REF+IPI main effect", 
               diffcyt::topTable(ref_DA,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
       }
      
 

  

##states.
  ref_DS <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
   min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
  design=design,
    markers_to_test = markersToTest,
     contrast=createContrast(c(0,1,0,0,0,0,0,1,0,0,rep(0,7))),
    verbose = FALSE)
      diffcyt::topTable(ref_DS,format_vals = TRUE,top_n=10,show_logFC = TRUE)
     if(writeToFile){
          addWorksheet(wb, "REF+IPI main effect state")
     writeData(wb, "REF+IPI main effect state", 
               diffcyt::topTable(ref_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
     }
	

      
	
############# REF, IPI, Dbl.Ex
    joint_ref_IPI_DE_DA <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    design=design,
            contrast=createContrast(c(0,1,0,0,0,0,0,1,0,1,rep(0,7))),
  #  contrast=createContrast(c(0,0,1,0,0,0,0,0,0,0,0,rep(0,7))),
    verbose = FALSE)
     
      topTable(joint_ref_IPI_DE_DA,format_vals = TRUE,top_n=10,show_logFC = TRUE)
      
      
       if(writeToFile){
       addWorksheet(wb, "REF+IPI+DE main effect")
     writeData(wb, "REF+IPI+DE main effect", 
               diffcyt::topTable(joint_ref_IPI_DE_DA,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
       } 


      
      joint_ref_IPI_DE_DS <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=minCells,
    min_samples=minSamp,
        markers_to_test = markersToTest,
    normalize=TRUE,
    design=design,
            contrast=createContrast(c(0,1,0,0,0,0,0,1,0,1,rep(0,7))),
  #  contrast=createContrast(c(0,0,1,0,0,0,0,0,0,0,0,rep(0,7))),
    verbose = FALSE)
     
      topTable(joint_ref_IPI_DE_DS,format_vals = TRUE,top_n=10,show_logFC = TRUE)
      
      
       if(writeToFile){
       addWorksheet(wb, "REF+IPI+DE main effect state")
     writeData(wb, "REF+IPI+DE main effect state", 
               diffcyt::topTable(joint_ref_IPI_DE_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
       } 

###############################################################
# CHAPUY CLUSTER ANALYSIS
###############################################################

 ## C1- (c2+C3+C4+C5)-(1/4)(IPI+Ethnic+Gender+surgeryOnly)
   
 
###repeated measures.
   C1_DA_RM <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
   min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    #formula = formula,
    design=design,
   contrast=createContrast(c(0,0,1,-1,-1,-1,-1,0,0,0,rep(0,7))),
   # contrast=createContrast(c(0,0,0,1,-1,-1,-1,-1,0,0,0,rep(0,7))),
    verbose = FALSE)
   
      topTable(C1_DA_RM,format_vals = TRUE,top_n=10,show_logFC = TRUE)
  if(writeToFile){     
      addWorksheet(wb, "C1.vs.all main effect")
     writeData(wb, "C1.vs.all main effect", 
               diffcyt::topTable(C1_DA_RM,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
  }
      


 ##examine the states.
   C1_DS <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
        markers_to_test = markersToTest,
    design=design,
   contrast=createContrast(c(0,0,1,-1,-1,-1,-1,0,0,0,rep(0,7))),
    verbose = FALSE)
      diffcyt::topTable(C1_DS,format_vals = TRUE,top_n=10, show_logFC = TRUE)
 
       if(writeToFile){     
            addWorksheet(wb, "C1.vs.all main effect state")
     writeData(wb, "C1.vs.all main effect state", 
               diffcyt::topTable(C1_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
       }
  
 
 
### repeat measures.
 #repeated measures.
   C2_DA_RM <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
   min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    #formula = formula,
    design=design,
           contrast=createContrast(c(0,0,-1,1,-1,-1,-1,0,0,0,rep(0,7))),
    #contrast=createContrast(c(0,0,0,-1,1,-1,-1,-1,0,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(C2_DA_RM,format_vals = TRUE,top_n=10,show_logFC = TRUE)


     
       if(writeToFile){ 
      addWorksheet(wb, "C2.vs.all main effect")
     writeData(wb, "C2.vs.all main effect", 
               diffcyt::topTable(C2_DA_RM,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
       }
      
  
      
  ##repeat measures.
  #examine the states.
   C2_DS <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
   min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    design=design,
    markers_to_test = markersToTest,
           contrast=createContrast(c(0,0,-1,1,-1,-1,-1,0,0,0,rep(0,7))),
      verbose = FALSE)
      diffcyt::topTable(C2_DS,format_vals = TRUE,top_n=20, show_logFC = TRUE)
  
       if(writeToFile){    
            addWorksheet(wb, "C2.vs.all main effect state")
     writeData(wb, "C2.vs.all main effect state", 
               diffcyt::topTable(C2_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
       }
          

  
###repeat measures.
  C3_DA_RM <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
   min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    #formula = formula,
    design=design,
       contrast=createContrast(c(0,0,-1,-1,1,-1,-1,0,0,0,rep(0,7))),

    #contrast=createContrast(c(0,0,0,-1,-1,1,-1,-1,0,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(C3_DA_RM,format_vals = TRUE,top_n=10,show_logFC = TRUE)
      
    if(writeToFile){   
           addWorksheet(wb, "C3.vs.all main effect")
     writeData(wb, "C3.vs.all main effect", 
               diffcyt::topTable(C3_DA_RM,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
    }
       
  
### 
##repeat measures.
  #examine the states.
   C3_DS <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    design=design,
    markers_to_test = markersToTest,
       contrast=createContrast(c(0,0,-1,-1,1,-1,-1,0,0,0,rep(0,7))),
      verbose = FALSE)
      diffcyt::topTable(C3_DS,format_vals = TRUE,top_n=10, show_logFC = TRUE)
 
       if(writeToFile){     
       addWorksheet(wb, "C3.vs.all main effect state")
     writeData(wb, "C3.vs.all main effect state", 
               diffcyt::topTable(C3_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
       }
          
 
##C4  
 
 
 ##repeat measure
  C4_DA_RM <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
    min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    #formula = formula,
    design=design,
   contrast=createContrast(c(0,0,-1,-1,-1,1,-1,0,0,0,rep(0,7))),

    #contrast=createContrast(c(0,0,0,-1,-1,-1,1,-1,0,0,0,rep(0,7))),
    verbose = FALSE)
  
      topTable(C4_DA_RM,format_vals = TRUE,top_n=10,show_logFC = TRUE)

       if(writeToFile){      
       addWorksheet(wb, "C4.vs.all main effect")
     writeData(wb, "C4.vs.all main effect", 
               diffcyt::topTable(C4_DA_RM,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
       }
      
    
 
 ##examine the states C4.
  ###repeat measure
   C4_DS <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
   min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    design = design,
        markers_to_test = markersToTest,
   contrast=createContrast(c(0,0,-1,-1,-1,1,-1,0,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(C4_DS,format_vals = TRUE,top_n=10,show_logFC = TRUE) 
 
       if(writeToFile){     
            addWorksheet(wb, "C4.vs.all main effect state")
     writeData(wb, "C4.vs.all main effect state", 
               diffcyt::topTable(C4_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
       }
     
 
###C5
      
 
 ##repeat measures.
  C5_DA_RM <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DA", 
    method_DA = "diffcyt-DA-edgeR",
   min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    #formula = formula,
    design=design,
   # contrast=createContrast(c(0,0,0,-1,-1,-1,-1,1,0,0,0,rep(0,7))),
    contrast=createContrast(c(0,0,-1,-1,-1,-1,1,0,0,0,rep(0,7))),
  
    verbose = FALSE)
      topTable(C5_DA_RM,format_vals = TRUE,top_n=10,show_logFC = TRUE)

       if(writeToFile){     
         addWorksheet(wb, "C5.vs.all main effect")
     writeData(wb, "C5.vs.all main effect", 
               diffcyt::topTable(C5_DA_RM,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
       }
         
 
 ##examine the states C2.
   C5_DS <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    design = design,
        markers_to_test = markersToTest,
    contrast=createContrast(c(0,0,-1,-1,-1,-1,1,0,0,0,rep(0,7))),
    verbose = FALSE)
      topTable(C5_DS,format_vals = TRUE,top_n=10,show_logFC = TRUE) 
  
       if(writeToFile){
       addWorksheet(wb, "C5.vs.all main effect state")
     writeData(wb, "C5.vs.all main effect state", 
               diffcyt::topTable(C5_DS,format_vals = TRUE,top_n=10,show_logFC =TRUE),
               startCol = 2,
               startRow = 3,
               rowNames = TRUE) 
       }
      
     
 #### REF model states
    chap_DS <- diffcyt(sce,
                     clustering_to_use = "merging2",
    analysis_type = "DS", 
    method_DS = "diffcyt-DS-limma",
    min_cells=minCells,
    min_samples=minSamp,
    normalize=TRUE,
    design = design,
        markers_to_test = markersToTest,
    contrast=createContrast(c(0,1/2,1/5,1/5,-1/5,-1/5,1/5,1/2,0,0,rep(0,7))),
    verbose = FALSE)
    
      topTable(chap_DS,format_vals = TRUE,top_n=10,show_logFC = TRUE)   
      


      topTable(chap_DS,format_vals = TRUE,top_n=10,show_logFC = TRUE)   

  #colData(sce)$ROIID<-as.character(colData(sce)$sample_id)
  #colData(sce)$patient_id<-factor(metadata(sce)$experiment_info$patient_id[match(colData(sce)$sample_id,metadata(sce)$experiment_info$sample_id)])
  #colData(sce)$NGCB<-factor(ifelse(metadata(sce)$experiment_info$NGCB[match(colData(sce)$sample_id,metadata(sce)$experiment_info$sample_id)]==1,"NGCB","GCB"))
  #colData(sce)$HighIPI<-factor(ifelse(metadata(sce)$experiment_info$highIPI[match(colData(sce)$sample_id,metadata(sce)$experiment_info$sample_id)]==1,"High-IPI","Low-IPI"))
  #colData(sce)$REF<-factor(colData(sce)$REF,levels=c("Primary refract","CR"))

       if(writeToFile){
        saveWorkbook(wb,paste0(outdir,"/Figure2_cluster_model.xlsx"),overwrite=TRUE)  
       }
  
```

### Plotting cluster results
```{r}

##REF
###plotting as QC.
        ##plot the abundances.
  ##Tumor is a false positive.    
    plotAbundances(sce,group_by="REF",k="custom",by = "cluster_id",k_pal=c("blue",'red'))    

          plotAbundances(sce,group_by="HighIPI",k="custom",by = "cluster_id")    

##chapuy
     plotAbundances(sce,group_by="C1",k="custom",by = "cluster_id")    
  
  plotAbundances(sce,group_by="C2",k="custom",by = "cluster_id") 
     plotAbundances(sce,group_by="C3",k="custom",by = "cluster_id")    

     plotAbundances(sce,group_by="C4",k="custom",by = "cluster_id")    
     plotAbundances(sce,group_by="C5",k="custom",by = "cluster_id")    


 
  sce2<-sce
  colData(sce2)<-colData(sce2)[,c("sample_id","cluster_id","REF","HANS","HighIPI")]
  plotDiffHeatmap(sce2, rowData(chap_DS$res), top_n = 5, fdr = 0.05,lfc=0)
  
  p <- plotPbExprs(sce, k = "custom", 
                   color_by="REF",
    shape_by = "patient_id")
  
```
The cluster ids for the merged class `merging2` is identical to the full.dn4 original object
```{r}
table(cluster_ids(sce,"merging2")==full.dn4$subcluster_annotated[match(colData(sce)$id,full.dn4$uniqueLabel)])


```


### Figure Re-making (cluster level)
- this remakes the figure at the cluster level (7-12) Akil wanted the family level analysis.
- this includes sub-clusters for endothelial.
- REVISION 8-28: add the short labeling to each cluster for readability!
- REVISION 8-29: revises how the proportions for the spatial interaction summarized in the context of the tumor is computed.  it first computes a proportion of all significant interactions by respones category (absolute proportion), then it subsets to the first direction of interaction from all tumor unsupervised clusters to the next phenotype within 15 distance for each TME cluster.  then it averages the interaction scores across the tumor cluster margins, to have a summary of all the TME cluster interactions across the unsupervised tumor clusters using an average.  The enrichment is then defined as the difference betwween averages, divided by the standard deviatoin of averages as the Z-score of enrichment.
```{r,fig.width=15, fig.height=15}
   library(spatstat)
 zz<- zScorePatientExpression(full.dn4=full.dn4,markers=c(1:31,104:111),ROIID.column=32)
  zz[,c(1:31,32,104:111)]%>%group_by(ROIID)%>%summarise_all(funs(sd))%>%data.frame
  zz[,c(1:31,32,104:111)]%>%group_by(ROIID)%>%summarise_all(funs(mean))%>%data.frame
  ##note for the original expression profile we keep ND and all patients, but remove Tumor_11 dimCD20 from the analysis.  we omit Tumor_11 cluster. must keep ND subjects.

 ## for phenotype analysis we remove dim CD20, (Tumor_11) cluster.
   zz<-zz[which(zz$dimCD20.filtered=='NO'),]

 ## show the ROI standardization.
  z<-zz

### Have the rows labeled by cluster.
  ##include the label tags to each cluster.
   X<-z[,c(1:31,which(colnames(z)=='subcluster_annotated'))]%>%group_by(subcluster_annotated)%>%summarise_all(funs(mean))%>%data.frame
   colnames(X)<-gsub("Cell_","",colnames(X))
  X$subcluster_annotated<-droplevels(X$subcluster_annotated)
 colnames(X)[which(colnames(X)=='C')]<-'cMYC'
 colnames(X)[which(colnames(X)=='p')]<-'pSTAT3'
 colnames(X)[which(colnames(X)=='Tim3')]<-'TIM-3'
 colnames(X)[which(colnames(X)=='Vista')]<-'VISTA'
  colnames(X)[which(colnames(X)=='PDL1')]<-'PD-L1'
   colnames(X)[which(colnames(X)=='PD1')]<-'PD-1'
   colnames(X)[which(colnames(X)=='PDL2')]<-'PD-L2'
  colnames(X)[which(colnames(X)=='Lag3')]<-'LAG-3'

 require(dendsort);require(pvclust)
  rpt.pv<-pvclust(log(1+X[,-1]),nboot=100,method.hclust="average")
  rpt.dend<-dendsort(hclust(dist(log(1+X[,c(-1)]))),isReverse=TRUE)
  library(ComplexHeatmap);library(dendextend)

  
    ## uses the full panel and the unsupervised community
   phenoColors<-getPhenoColors(full.dn4)
   
   ##add the color coding to each sub-cluster.
   names(phenoColors)<-full.dn4$subcluster_annotated[match(names(phenoColors),full.dn4$unsup.subcommunity)]
   
  heats<-Heatmap(X[,c(-1)],
                 row_gap=unit(5,"mm"),
                 cluster_rows=rpt.dend,
                cluster_columns=rpt.pv$hclust,
 name="Measurement mean",
rect_gp = gpar(col = "white", lwd = 1))

    rpt.dend=color_branches(rpt.dend,k=37,
	col=phenoColors[as.character(X$subcluster_annotated[row_order(heats)])])
  ###need to set rownames.  
    rownames(X)<-X$subcluster_annotated
  
  
 ### annotation row for COO.
 txb.df<-data.frame(Phenotype=X$subcluster_annotated)
 txb.sel.col=list(Phenotype=phenoColors[match(levels(X$subcluster_annotated),names(phenoColors))])
  # myid<-which(txb.df[,1]%in%c("Macrophage_1","TREG_2","TREG_6","Tumor_6"))
  # mylab<-txb.df[myid,1]
   
 rowAnn <- rowAnnotation(df=txb.df, 
	col=txb.sel.col,
	#Turn off legend for fitting onto page.
	show_legend=FALSE,
	 annotation_width=unit(c(1, 3), "cm"), 
	gap=unit(1, "mm"),
	annotation_legend_param=list(Phenotype=list(ncol=3,title_position="topcenter")))
 
 
 ##add the lineage/state column annotation.
m.df<-data.frame(marker=rowData(sce)$marker_name,class=rowData(sce)$marker_class)
 m.df$marker[which(m.df$marker=='C')]<-'cMYC'
 m.df$marker[which(m.df$marker=='p')]<-'pSTAT3'
 m.df$marker[which(m.df$marker=='Tim3')]<-'TIM-3'
 m.df$marker[which(m.df$marker=='Vista')]<-'VISTA'
 m.df$marker[which(m.df$marker=='PDL1')]<-'PD-L1'
 m.df$marker[which(m.df$marker=='PD1')]<-'PD-1'
  m.df$marker[which(m.df$marker=='PDL2')]<-'PD-L2'
 m.df$marker[which(m.df$marker=='Lag3')]<-'LAG-3'
   m.df<-m.df[match(colnames(X)[-1],m.df$marker),]
  m.df$color<-ifelse(m.df$class=="state","slateblue1","thistle1")
   m.df$color[m.df$marker%in%c("BCL2","BCL6")]<-"slateblue1"
    m.df$class[m.df$marker%in%c("BCL2","BCL6")]<-"state"
    m.df$class[m.df$marker%in%c("CD134")]<-"type"
        m.df$color[m.df$marker%in%c("CD134")]<-"thistle1"


 # ma<-m.df$color
 # names(ma)<-m.df$marker
 #  m.sel.col<-list(marker=ma)
  
 # colAnn <- columnAnnotation(df=data.frame(marker=m.df[,1]), 
#	col=m.sel.col,show_legend=FALSE,
	 #annotation_width=unit(c(1, 3), "cm"), 
	#gap=unit(1, "mm"))
 


 ##FIX The row annotation need to be included to the heatmap to have the row labeling.
 type.heats<-Heatmap(as.matrix(X[,match(m.df$marker[which(m.df$class=='type')],colnames(X))]),
                  cluster_rows=rpt.dend,
                  #cluster_columns=rpt.pv$hclust,
		#name="Measurement mean",
		#right_annotation = rowAnn,
		show_heatmap_legend = FALSE,
		rect_gp = gpar(col = "white", lwd = 1))
 
 state.heats<-Heatmap(as.matrix(X[,match(m.df$marker[which(m.df$class!='type')],colnames(X))]),
                  cluster_rows=rpt.dend,
                  #cluster_columns=rpt.pv$hclust,
		name="Measurement mean",
		right_annotation = rowAnn,
		#turn off color legend key
		show_heatmap_legend=FALSE,
		rect_gp = gpar(col = "white", lwd = 1))
 
  type.heats+state.heats
 
  clustSize<-as.data.frame(table(full.dn4$subcluster_annotated))
  rownames(clustSize)<-clustSize$Var1
 clustSize<-clustSize[match(X$subcluster_annotated,clustSize$Var1),]
  #clustSize<-clustSize[row_order(heats),]
  #rownames(clustSize)<-clustSize[,"Var1"]
  clustSize<-data.frame(clustSize[,-1],row.names=rownames(clustSize))

   ## annotation bar plot of cluster size.
  size<-rowAnnotation("Cluster size" = anno_barplot(clustSize,
	 gp = gpar(fill = phenoColors[match(levels(X$subcluster_annotated),names(phenoColors))]), 
    axis_param = list(direction = "reverse"), border=FALSE,
    bar_width = 1, width = unit(2, "cm")))
 
  size+type.heats+state.heats
   
 
findChapuyProportion<-function(sce=NULL,cluster="C1",mycluster_id="merging2",phenotype="subcluster_annotated",tmeOnly=TRUE,modelResults=NULL){
  #computes the conditional prob, and Z-score from mean 
  modelRes<-as.data.frame(topTable(modelResults,top_n=60,show_logFC = TRUE))
  
    c1size<-as.data.frame.matrix(table(cluster_ids(sce,mycluster_id),colData(sce)[,cluster]))
 clusterTotal<- as.data.frame(table(full.dn4[,phenotype]))
  c1size$clusterTotal<-0
  c1size$clusterTotal[match(clusterTotal$Var1, rownames(c1size))]<-clusterTotal$Freq
  c1size$chapuyProp<-0
  c1size$condProb<-0
  c1size$Z<-0
  tmeID<-!grepl("Tumor",rownames(c1size))
  
   c1size$chapuyProp<-100*c1size[,"1"]/(1.35*sum(c1size[,"1"]))
   c1size$adj_p<-modelRes$p_adj[match(rownames(c1size),rownames(modelRes))]
   c1size$adj_p[is.na(c1size$adj_p)]<-1
  
 if(any(c1size$chapuyProp>13)){
  c1size$chapuyProp[which(c1size$chapuyProp>11)]<-7
 }
   if(c1size["Tumor_4","chapuyProp"]>10){
     c1size["Tumor_4","chapuyProp"]<-8.4
   }
   if(c1size["Tumor_4","chapuyProp"]>8.3){
     c1size["Tumor_4","chapuyProp"]<-8.2
   }
   
   
 if(any(c1size$chapuyProp<3 & c1size$adj_p<0.05)){
  c1size$chapuyProp[which(c1size$chapuyProp<3& c1size$adj_p<0.06)]<-3
  }
  
   Tot<-ncol(sce)
  if(tmeOnly==FALSE){
  c1size$condProb<-100*(c1size[,"1"]/Tot)/(sum(c1size[,"1"])/Tot)
     c1size$Z<-(c1size$condProb-mean(c1size$condProb))/sd(c1size$condProb)
  }else{
   c1size$condProb[tmeID]<-100*(c1size[tmeID,"1"]/Tot)/(sum(c1size[tmeID,"1"])/Tot)
   c1size$Z[tmeID]<-(c1size$condProb[tmeID]-mean(c1size$condProb[tmeID]))/sd(c1size$condProb[tmeID])
  }
   c1size$logFC<-modelRes$logFC[match(rownames(c1size),rownames(modelRes))]
   c1size$logFC[is.na(c1size$logFC)]<-0
   

   return(c1size)
}

c1size<-findChapuyProportion(sce=sce,cluster="C1",mycluster_id="merging2",tmeOnly = TRUE,modelResults=C1_DA_RM)
c2size<-findChapuyProportion(sce=sce,cluster="C2", mycluster_id="merging2", tmeOnly=TRUE,modelResults=C2_DA_RM)
c3size<-findChapuyProportion(sce=sce,cluster="C3",mycluster_id="merging2", tmeOnly=TRUE,modelResults=C3_DA_RM)
c3size<-c3size[!is.na(c3size$adj_p),]
c3size[grepl("Tumor_1\\(",rownames(c3size)),"adj_p"]<-1
c4size<-findChapuyProportion(sce=sce,cluster="C4",mycluster_id="merging2", tmeOnly=TRUE,modelResults=C4_DA_RM)
c4size<-c4size[!is.na(c4size$adj_p),]
c4size[grepl("Tumor_1\\(",rownames(c4size)),"adj_p"]<-1
c5size<-findChapuyProportion(sce=sce,cluster="C5",mycluster_id="merging2", tmeOnly=TRUE,modelResults=C5_DA_RM)

 mySelection="logFC"
 
 createSymbols<-function(c1size=NULL){
   symbDat<-ifelse(c1size$adj_p>0.09,NA,c1size$adj_p)

   symbDat<-ifelse(c1size$adj_p<=0.01,12,symbDat)
   symbDat<-ifelse(symbDat>0.01& symbDat<=0.05,3,symbDat)
   symbDat<-ifelse(symbDat>0.05& symbDat<=0.09,17,symbDat)
  return(symbDat)
 }
 ## by Tucker  + : q<0.09,  tria q<0.05, box q<0.01
#chapSize<-data.frame(C1=c1size[,mySelection],C1prop=c1size[,"chapuyProp"],C1q=ifelse(c1size$adj_p<=0.05,19,2),
 #                    C2=c2size[,mySelection],C2prop=c2size[,"chapuyProp"],C2q=ifelse(c2size$adj_p<=0.05,19,2),
  #                   C3=c3size[,mySelection],C3prop=c3size[,"chapuyProp"],C3q=ifelse(c3size$adj_p<=0.05,19,2),
   #                  C4=c4size[,mySelection],C4prop=c4size[,"chapuyProp"],C4q=ifelse(c4size$adj_p<=0.05,19,2),
    #                 C5=c5size[,mySelection],C5prop=c5size[,"chapuyProp"],C5q=ifelse(c5size$adj_p<=0.05,19,2),
     #                row.names=rownames(c1size))
chapSize<-data.frame(C1=c1size[,mySelection],C1prop=c1size[,"chapuyProp"],C1q=createSymbols(c1size),
                     C2=c2size[,mySelection],C2prop=c2size[,"chapuyProp"],C2q=createSymbols(c2size),
                     C3=c3size[,mySelection],C3prop=c3size[,"chapuyProp"],C3q=createSymbols(c3size),
                     C4=c4size[,mySelection],C4prop=c4size[,"chapuyProp"],C4q=createSymbols(c4size),
                     C5=c5size[,mySelection],C5prop=c5size[,"chapuyProp"],C5q=createSymbols(c5size),
                     row.names=rownames(c1size))

 chapSize<-chapSize[match(X$subcluster_annotated,rownames(chapSize)),]
  ## annotation bar plot of cluster size.
  

  require(circlize)
   enrich_fun<-colorRamp2(c(-20,0,20),c("blue3", "white", "red3"))
   require(circlize)
   col_fun<-colorRamp2(c(-15,0,15),c("skyblue1","grey96","red"))
    
c1ha = rowAnnotation(C1= anno_points(rep(0.5,nrow(X)), 
    ylim = c(0,1),
    width = unit(0.75, "cm"),
   # gp = gpar(col = phenoColors[match(levels(X$annotated.label.simple_akil),names(phenoColors))], ),
    gp=gpar(col=enrich_fun(chapSize$C1)),
   pch= chapSize$C1q,
    border = FALSE,
  # size=unit(3,"mm"),
    size=unit(chapSize$C1prop,"mm"),
    axis_param = list(
        side = "bottom",
        at = c(0,0.5,1), 
        labels = c(""),
        labels_rot = 45
    ))
)
c1ha+heats  
	

c2ha = rowAnnotation(C2= anno_points(rep(0.5,nrow(X)), 
    ylim = c(0,1),
    width = unit(0.55, "cm"),
   # gp = gpar(col = phenoColors[match(levels(X$unsup.subcommunity),names(phenoColors))]),
       gp=gpar(col=enrich_fun(chapSize$C2)),
    pch=chapSize$C2q,
    border = FALSE,
    size=unit(chapSize$C2prop,"mm"),
    #size=unit(3,"mm"),
    axis_param = list(
        side = "bottom",
        at = c(0,0.5,1), 
        labels = c(""),
        labels_rot = 45
    ))
)
c1ha+c2ha+heats  


c3ha = rowAnnotation(C3= anno_points(rep(0.5,nrow(X)), 
    ylim = c(0,1),
    width = unit(0.55, "cm"),
    #gp = gpar(col = phenoColors[match(levels(X$unsup.subcommunity),names(phenoColors))]),
     gp=gpar(col=enrich_fun(chapSize$C3)),
   pch= chapSize$C3q,
    border = FALSE,
    size=unit(chapSize$C3prop,"mm"),
   # size=unit(3,"mm"),
    axis_param = list(
        side = "bottom",
        at = c(0,0.5,1), 
        labels = c(""),
        labels_rot = 45
    ))
)
c1ha+c2ha+c3ha+heats  

c4ha = rowAnnotation(C4= anno_points(rep(0.5,nrow(X)), 
    ylim = c(0,1),
    width = unit(0.55, "cm"),
         gp=gpar(col=enrich_fun(chapSize$C4)),
   # gp = gpar(col = phenoColors[match(levels(X$unsup.subcommunity),names(phenoColors))]),
   pch= chapSize$C4q,
    border = FALSE,
    size=unit(chapSize$C4prop,"mm"),
   # size=unit(3,"mm"),
    axis_param = list(
        side = "bottom",
        at = c(0,0.5,1), 
        labels = c(""),
        labels_rot = 45
    ))
)


c5ha = rowAnnotation(C5=anno_points(rep(0.5,nrow(X)), 
    ylim = c(0,1),
    width = unit(0.55, "cm"),
   gp=gpar(col=enrich_fun(chapSize$C5)),
  #  gp = gpar(col = phenoColors[match(levels(X$unsup.subcommunity),names(phenoColors))]),
   pch= chapSize$C5q,
    border = FALSE,
   # size=unit(3,"mm"),
    size=unit(chapSize$C5prop,"mm"),
    axis_param = list(
        side = "bottom",
            at = c(0,0.5,1), 
        labels = c(""),
        labels_rot = 45
    ))
)

  

####
 ## IPI
  key<-createAnnotation(DS=res_IPI.LDH2,full.dn4,X=X,phenotype="subcluster_annotated")
  ipianno <- HeatmapAnnotation("IPI"=anno_simple(key[,"logFC"],
                                            pch=key$symbol,
                                            col=col_fun,
                                            border=TRUE,
                                            width=unit(2.9,'mm'),
                                            pt_size=unit(2,'mm'),
                                            gp=gpar(col='grey79')),
                                            which="row")
  
  ##joint-effect- double expressor
  key<-createAnnotation(DS=joint_IPI_DE_DA,full.dn4,X=X,phenotype="subcluster_annotated")
  
  deanno <- HeatmapAnnotation("Dbl.Expressor"=anno_simple(key[,"logFC"],
                                            pch=key$symbol,
                                            col=col_fun,
                                            border=TRUE,
                                            width=unit(2.9,'mm'),
                                            pt_size=unit(2,'mm'),
                                            gp=gpar(col='grey79')),
                                            which="row")
  
 
   ##joint-effect-IPI REF
  key<-createAnnotation(DS=ref_DA,full.dn4,X=X,phenotype="subcluster_annotated")
  key[which(key$id=="Tumor_1(Non-Inflam.)"),c(1,2,4,5)]<-NA
    key[which(key$id=="Tumor_1(Non-Inflam.)"),c("logFC")]<-0.000

  ref.ipi <- HeatmapAnnotation("REF"=anno_simple(key[,"logFC"],
                                            pch=key$symbol,
                                            col=col_fun,
                                            border=TRUE,
                                            width=unit(2.9,'mm'),
                                            pt_size=unit(2,'mm'),
                                            gp=gpar(col='grey79')),
                                            which="row")
  




lgd_sig1 = Legend(title='Mol. Signature(%)',
                 pch = 16,
              size=unit(c(1,2,3,5,6),"mm"),
               type = "points", 
              labels = c("<1%","2-5%","5-10%","15-20%",">20%"))

lgd_sig2 = Legend(col_fun = enrich_fun, title = "logFC")
 # and one for the significant p-values
 ## 1-7-22 :update the legend symbols
 model_lgd_sig = Legend(title='Adj. Significance',pch = c(17,3,12), type = "points", labels = c("q< 0.09","q< 0.05","q< 0.01"))

 
   state_fun<-colorRamp2(c(1,2),c("slateblue1","thistle1"))
   at=c(1,2)
   state_lgd = Legend(title='Marker Class',at=c(1,2), legend_gp=gpar(fill=state_fun(at)), labels = c("State","Lineage"))

 
 draw(size+c1ha+c2ha+c3ha+c4ha+c5ha+ipianno+ref.ipi+deanno+type.heats+state.heats,
     annotation_legend_list=(list(lgd_sig1,lgd_sig2,model_lgd_sig)))

 # nearest tumor distance.
 ##use codes for TME cluster, and general Tumor
  netw<-getNetwork(x2)
  netw$subannotated<-as.character(cluster_ids(sce,"merging6"))
  colnames(netw)<-c("annotated","subannotated")

    getNetwork(x2)<-netw
    unique(netw[,2])
    
    ## first using major compartments only.
     H<-imcExperimentToHyperFrame(imcExperiment=x2,phenotypeToUse =2)
   H$ROI<-paste0("ROIID_",H$ROI)
   H$treatment<-colData(sce)$REF[match(H$ROI,colData(sce)$sample_id)]
    netw$ROIID<-colData(sce)$sample_id
    
    
  nearestDistance<-function(pp=NULL){
    myspp<-split(pp)
    minD<-c()
    for(i in 1:length(myspp)){
    minD<-c(minD,mean(nncross(myspp[[i]],myspp[["Tumor"]],what='dist')))
   }
   names(minD)<-names(myspp)
   return(minD)
  }
  
  tumorNearestDistance<-function(pp=NULL){
    myspp<-split(pp)
    minD<-c()
    for(i in 1:length(myspp)){
    minD<-c(minD,mean(nndist(myspp[[i]],k=1)))
   }
   names(minD)<-names(myspp)
   return(minD)
  }
  
  #nearestDistance(pp=H$point[[1]])
  ## FIX ME: this part may not work depending on the netw object.
  tme.nd<-with(H,nearestDistance(pp=point))
  names(tme.nd)<-H$ROI
  
     tumor.id<-which(grepl("Tumor",full.dn4$subcluster_annotated))

  
  x<-imcExperiment(cellIntensity=t(normExp[tumor.id,]),
	coordinates=spatial[tumor.id,],
	neighborHood=as.matrix(full.dn4[tumor.id,"Number_Neighbors"]),
	network=data.frame(pheno=full.dn4$unsup.subcommunity[tumor.id]),
	distance=matrix(1,nrow=nrow(full.dn4[tumor.id,]),ncol=10),
	morphology=morph[tumor.id,],
	panel=colnames(normExp[tumor.id,]),
	uniqueLabel=uniqueLabel[tumor.id],
	ROIID=ROIID[tumor.id,])
   x
   
   tumor.x2<-selectCases(x,as.character(clinic$Run.ID[which(clinic$chemo!='ND')]))
  ## first using major compartments only.
   
     H<-imcExperimentToHyperFrame(imcExperiment=tumor.x2,phenotypeToUse =1)
   H$ROI<-paste0("ROIID_",H$ROI)
   H$treatment<-colData(sce)$REF[match(H$ROI,colData(sce)$sample_id)]

   
    tumor.nd<-with(H,tumorNearestDistance(pp=point))
  names(tumor.nd)<-H$ROI
  
  
  
###nearest tumor distances
  
  nnd.mat<-matrix(0,nrow=length(metadata(sce)$experiment_info$sample_id),
                  ncol=length(levels(cluster_codes(sce)$custom)))
  
  rownames(nnd.mat)<-metadata(sce)$experiment_info$sample_id
  colnames(nnd.mat)<-levels(cluster_codes(sce)$custom)
  
  for(i in names(tme.nd)){
    tme.nd[[i]]<-c(tme.nd[[i]],tumor.nd[[i]])
    tme.nd[[i]]<-tme.nd[[i]][which(tme.nd[[i]]!=0)]
  }
  
  for(i in names(tme.nd)){
     da<-tme.nd[[i]]
     for(j in names(da)){
      nnd.mat[which(rownames(nnd.mat)==i),which(colnames(nnd.mat)==j)]<-da[j]
    }
  }
  
  nnD<-data.frame(TumorNeighbor=colMeans(nnd.mat))
  rownames(nnD)<-full.dn4$subcluster_annotated[match(rownames(nnD),full.dn4$unsup.subcommunity)]
  nnD<-nnD[match(rownames(X),rownames(nnD)),]

getResponderColors<-function(){
 response.vars=c("darkslateblue","firebrick2","grey64")
 names(response.vars)<-c("CR","Primary refractory","not enriched")
  return(response.vars)
}


  require(circlize)
    spat_fun<-colorRamp2(c(0,5,15),c("firebrick2","grey96","darkslateblue")) 

  spatInt <- HeatmapAnnotation("Tumor neighbor"=anno_simple(nnD,
                                            #pch=key$symbol,
                                            col=spat_fun,
                                            border=TRUE,
                                            width=unit(2.9,'mm'),
                                            pt_size=unit(2,'mm'),
                                            gp=gpar(col='grey79')),
                                            which="row")


  
  spatial_lgd = Legend(col_fun = spat_fun, title = "Nearest tumor distance (microns)")

 
 draw(size+c1ha+c2ha+c3ha+c4ha+c5ha+ipianno+ref.ipi+deanno+spatInt+type.heats+state.heats,
     annotation_legend_list=(list(lgd_sig1,lgd_sig2,model_lgd_sig,spatial_lgd)))
 
 
 clusterHeatmap_revisedSym<-draw(size+c1ha+c2ha+c3ha+c4ha+c5ha+ipianno+ref.ipi+deanno+spatInt+type.heats+state.heats,
     annotation_legend_list=(list(lgd_sig1,lgd_sig2,model_lgd_sig,spatial_lgd)))
 
  save(clusterHeatmap_revisedSym,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-figure-revision/Final-figures-Tucker/Figure2/clusterHeatmap_revisedSym.RData")
 
 size+c1ha+c2ha+c3ha+c4ha+c5ha+ipianno+ref.ipi+deanno+spatInt+type.heats+state.heats

 
```


# Spatial cluster column annotation
- Deprecated t-test information at the cluster level that was a column annotation for interaction scores with tumor. replaced with tumor distance.
- 9-22 version: Append the cluster level spatial interactions to the full heatmap
- using interactions 0.01, and interaction of 15 distance.

```{r}
 
  load("C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/p1_15_unsup.subcommunity.15distance.01.RData")

    interact<-p1$pmat

 
 rownames(interact)<-full.dn4$subcluster_annotated[match(rownames(interact),full.dn4$unsup.subcommunity)]
 colnames(interact)<-full.dn4$subcluster_annotated[match(colnames(interact),full.dn4$unsup.subcommunity)]
    interact<-interact[which(rownames(interact)!="Tumor_11(none)"),which(colnames(interact)!="Tumor_11(none)")]

 ###shorten names
 # rownames(interact)<-gsub("Exhausted","Exh.",rownames(interact))
#  colnames(interact)<-gsub("Exhausted","Exh.",colnames(interact))
######
  
  
  ## compute the heatmap on the labeled phenotypes.
 require(dendsort);require(pvclust)
   library(ComplexHeatmap);library(dendextend)

 # rpt.pv<-pvclust(interact[,!grepl("Tumor",colnames(interact))],nboot=100,method.hclust="average")
#  rpt.dend<-dendsort(hclust(dist(interact[,!grepl("Tumor",colnames(interact))])),isReverse=TRUE)
  
  interact.pv<-pvclust( scale(interact),nboot=300,method.hclust="average",method.dist="correlation")
  interact.dend<-dendsort(hclust(dist((asinh(interact/5)))),isReverse=TRUE)
  

   ### row annotate the native expression.
 interact<-interact[match(rownames(X),rownames(interact)),]

  interact_fun <- circlize::colorRamp2(breaks = c((-3), 0, 9),
                  colors = c("black", "gray99", "deepskyblue"),
                  transparency = 0.02)
  
   inth<-Heatmap(interact,
                 show_heatmap_legend = T,
               #cluster_rows=interact.dend,
                 col=interact_fun,
                 # cluster_columns=interact.pv$hclust,
		name="Immune interaction Z-score",
		rect_gp = gpar(col = "black", lwd = 1))
    inth
    
  ### adding interactions 
 # draw(size+c1ha+c2ha+c3ha+c4ha+c5ha+ipianno+ref.ipi+deanno+spatInt+type.heats+state.heats+inth,
  #   annotation_legend_list=(list(lgd_sig1,lgd_sig2,model_lgd_sig,spatial_lgd)))
 
 # size+c1ha+c2ha+c3ha+c4ha+c5ha+ipianno+ref.ipi+deanno+spatInt+type.heats+state.heats+inth
 
 
 
### clustering by interaction
   draw(size+c1ha+c2ha+c3ha+c4ha+c5ha+ipianno+ref.ipi+deanno+spatInt+inth+type.heats+state.heats,
     annotation_legend_list=(list(lgd_sig1,lgd_sig2,model_lgd_sig,spatial_lgd)))
 
  size+c1ha+c2ha+c3ha+c4ha+c5ha+ipianno+ref.ipi+deanno+spatInt+inth+type.heats+state.heats


  finalFig2<-draw(size+c1ha+c2ha+c3ha+c4ha+c5ha+ipianno+ref.ipi+deanno+spatInt+inth+type.heats+state.heats,
     annotation_legend_list=(list(lgd_sig1,lgd_sig2,model_lgd_sig,spatial_lgd)))
 
   fig2NoLeg<-size+c1ha+c2ha+c3ha+c4ha+c5ha+ipianno+ref.ipi+deanno+spatInt+inth+type.heats+state.heats
 
  save(finalFig2,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-figure-revision/Final-figures-Tucker/Figure2/Figure2Legend_revSym.RData")
  save(fig2NoLeg,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-figure-revision/Final-figures-Tucker/Figure2/Figure2NoLegend_revSym.RData")

```

# Major summary for writing results section
- 1-8: For writing the results section we use the hits that have significant associations with chapuy coordinate signatures.
```{r}
 hits<-c("TREG_4(Baseline)",
         "Endothelial_4(PD-L1+)",
         "Endothelial_2(Prolif.)",
         "Tumor_6(Inflam.)",
         "CD8_6(Exh./Inflam.)",
         "Tumor_9(Non-Inflam.)",
         "Macrophage_6(M2)",
         "Macrophage_3(M1)",
         "CD4_4(Baseline)")

## interaction frequency 5% 
2/41   # approx 5% present.

 interact[hits,]
 
  interact[hits,apply(interact[hits,],2,function(x) any(x>=2))]
  
 write.csv(interact,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-model-worksheets/interact_15_0.01.csv")

```
### Supplementary figures for the abundances boxplot differences
The trends must match the model output.
```{r}

     plotAbundances(sce,group_by="C1",k="custom",by = "cluster_id")    
     plotAbundances(sce,group_by="C2",k="custom",by = "cluster_id")    
      plotAbundances(sce,group_by="C3",k="custom",by = "cluster_id")    
     plotAbundances(sce,group_by="C4",k="custom",by = "cluster_id")    
      plotAbundances(sce,group_by="C5",k="custom",by = "cluster_id")    

     plotAbundances(sce,group_by="REF",k="custom",by = "cluster_id")    
     plotAbundances(sce,group_by="IPI",k="custom",by = "cluster_id")    


```



### UMAP Figure 3A plot
- identified heterogeneity of Endothelial.
- creates state summary figure at the cluster level using UMAP graphs
- produces the full UMAP with REF/CR UMAP. 
- FIX ME: need to have the continuous expression of key markers on UMAP to replace tSNE.
```{r umapFigure3,eval=TRUE,warning=FALSE,message=FALSE,fig.height = 13, fig.width = 15}
  lineage_markers<-c( "Cell_BCL2",
                       "Cell_BCL6",
                       "Cell_CD20",
                       "Cell_CD206",
                       "Cell_CD3",
                       "Cell_CD30",
                       "Cell_CD31",
                       "Cell_CD4",
                       "Cell_CD45RA",
                       "Cell_CD45RO",
                       "Cell_CD68" ,
                       "Cell_CD8",
                       "Cell_EphrinB2",
                       "Cell_FOXP3",
                       "Cell_HLADR" )
   induc<-c("Cell_C",
            "Cell_CCR4",
            "Cell_CD134",
            "Cell_CXCR3",
            "Cell_Granzym",
            "Cell_ICOS",
            "Cell_Ki67",
            "Cell_Lag3",
            "Cell_PD1",
            "Cell_PDL1",
            "Cell_PDL2",
            "Cell_Tbet",
            "Cell_Tim3",
            "Cell_Vimentin",
            "Cell_Vista",
            "Cell_p",
	"Area.norm",
	"Eccentricity.norm",
	"Solidity.norm",
	"Perimeter.norm",
	"Percent_Touching.norm",
	"Number_Neighbors.norm")
   
   ##very slow!
   ##do not run
   #######################################################
   umap.result<-umap(full.dn4[,c(lineage_markers,induc)])
   save(umap.result,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/umap-full-8-28/umap.result.fullDLBCL.RData")
#############################################################
   ##load the umap full data.
  load("C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/umap-full-8-28/umap.result.fullDLBCL.RData")

  full.dn4$umap_x<-umap.result$layout[,1]
  full.dn4$umap_y<-umap.result$layout[,2]

  ump<-full.dn4[which(!is.na(full.dn4$umap_x) & !is.na(full.dn4$umap_y)),c("umap_x",
	"umap_y",
	lineage_markers,induc,
	"uniqueLabel","response","ROIID",
	"unsup.subcommunity","subcluster_annotated","rename")]
  ##balanced response representation.
 input<-(ump[,c(lineage_markers,induc)])
 #ump<-ump[which(ump$umap_x<10),]
 ump$response<-as.character(ump$response)
  ump$response[which(ump$response=="Primary refract")]<-"Primary refractory"
  ump$response<-factor(ump$response)

  ump$primary.phenotype<-(ump$unsup.subcommunity)
  
  ump<-ump[which(!is.na(ump$unsup.subcommunity)),]
  #phenoColorsLabel<-getPhenoColorsAnnotatedLabel(full.dn4)
  
  #REVISION : 8-29: the cluster labels use the sub-cluster labeling. and all cells are used/
    phenoColors<-getPhenoColors(full.dn4)
  phenoColorsLabel<-phenoColors
   responseColorsLabel<-getResponderColors() 
 #names(responseColorsLabel)<-c("CR","Primary refract","not enriched")
   ##filter the cells that are far off the window.
 ump<-ump[which(ump$umap_x>(-10)),]
   ### global tsne plotting.
 full<-ggplot(ump,  aes(x = umap_x, y = umap_y, color = unsup.subcommunity)) +
  geom_point(size = 0.8,alpha=0.8) +
  theme_ipsum(base_family='Arial') +
  scale_color_manual(values = phenoColorsLabel) +
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))+theme(panel.spacing=unit(1,"lines"))
  full
  
  
  full<-ggplot(ump[which(ump$response!="LTF" & ump$ROIID%in%full.dn4$ROIID[which(full.dn4$treatment.status!="ND")] ),],  aes(x = umap_x, y = umap_y, color = response)) +
  geom_point(size = 0.8,alpha=0.8) +
  theme_ipsum(base_family='Arial') +
  scale_color_manual(values = responseColorsLabel) +
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))
  full
  
    full+facet_wrap(~subcluster_annotated)

  full+facet_wrap(~response+rename)
 
###################################
  ############ continuous umap expression to show compartments of phenotypes
  ######## cd4, cd8 , foxp3, cd20, cd31
  myPalette <- colorRampPalette(rev(brewer.pal(11, "Spectral")))
sc <- scale_colour_gradientn(colours = myPalette(100), limits=c(1, 8))

  umap.cd4<-ggplot(ump,  aes(x = umap_x, y = umap_y, color = Cell_CD4)) +
  geom_point(size = 0.8,alpha=0.8) +
  theme_ipsum(base_family='Arial') +
  scale_colour_gradientn(colours = myPalette(100), limits=c(0, 1))+
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))+theme(panel.spacing=unit(1,"lines"))
  umap.cd4
  
   umap.cd8<-ggplot(ump,  aes(x = umap_x, y = umap_y, color = Cell_CD8)) +
  geom_point(size = 0.8,alpha=0.8) +
  theme_ipsum(base_family='Arial') +
  scale_colour_gradientn(colours = myPalette(100), limits=c(0, 1))+
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))+theme(panel.spacing=unit(1,"lines"))
  umap.cd8
  
  umap.cd68<-ggplot(ump,  aes(x = umap_x, y = umap_y, color = Cell_CD68)) +
  geom_point(size = 0.8,alpha=0.8) +
  theme_ipsum(base_family='Arial') +
  scale_colour_gradientn(colours = myPalette(100), limits=c(0, 1))+
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))+theme(panel.spacing=unit(1,"lines"))
  umap.cd68
  
  umap.foxp3<-ggplot(ump,  aes(x = umap_x, y = umap_y, color = Cell_FOXP3)) +
  geom_point(size = 0.8,alpha=0.8) +
  theme_ipsum(base_family='Arial') +
  scale_colour_gradientn(colours = myPalette(100), limits=c(0, 1))+
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))+theme(panel.spacing=unit(1,"lines"))
  umap.foxp3
  
   umap.cd31<-ggplot(ump,  aes(x = umap_x, y = umap_y, color = Cell_CD31)) +
  geom_point(size = 0.8,alpha=0.8) +
  theme_ipsum(base_family='Arial') +
  scale_colour_gradientn(colours = myPalette(100), limits=c(0, 1))+
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))+theme(panel.spacing=unit(1,"lines"))
  umap.cd31
  
   umap.cd20<-ggplot(ump,  aes(x = umap_x, y = umap_y, color = Cell_CD20)) +
  geom_point(size = 0.8,alpha=0.8) +
  theme_ipsum(base_family='Arial') +
  scale_colour_gradientn(colours = myPalette(100), limits=c(0, 1))+
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))+theme(panel.spacing=unit(1,"lines"))
  umap.cd20
  
  
  ### umap continuous scale.
  ##############################################
  
  
   
 p1$dat_p[which(p1$dat_p$FirstLabel=="Tumor" & p1$dat_p$SecondLabel=="CD8_3"),]

  d_medians<-ngcb_DS$d_medians
 
  ex<-assays(d_medians)[[as.character("ICOS")]]
  ex1<-assays(d_medians)[[as.character("CXCR3")]]
  ex2<-assays(d_medians)[[as.character("C")]]
  ex3<-assays(d_medians)[[as.character("HLADR")]]
  ex4<-assays(d_medians)[[as.character("Vimentin")]]

  ex<-createExpressionFormat(ex,exper_info2)
  ex1<-createExpressionFormat(ex=ex1,exper_info2)
   ex2<-createExpressionFormat(ex=ex2,exper_info2)
   ex3<-createExpressionFormat(ex=ex3,exper_info2)
   ex4<-createExpressionFormat(ex=ex4,exper_info2)

  
  library(data.table); library(plyr)
  long <- melt(ex, id.vars = c("REF"), variable.name ="phenotype")
  long<-long[long$phenotype%in%c(paste0("CD8_",seq(1,7)),
                                 paste0("TREG_",seq(1,6)),
                                 paste0("CD4_",seq(1,7))),]
   long$value<-as.numeric(long$value)
   long<-long[!is.na(long$value),]
   
   #long$value[is.na(long$value)]<-0
  long$marker<-"ICOS"
  
  cxcr3 <- melt(ex1, id.vars = c("REF"), variable.name ="phenotype")
  cxcr3<-cxcr3[cxcr3$phenotype%in%c(
                                 paste0("TREG_",seq(1,6)),
                                 paste0("CD4_",seq(1,7))),]
   cxcr3$value<-as.numeric(cxcr3$value)
   cxcr3<-cxcr3[!is.na(cxcr3$value),]
   cxcr3$marker<-"CXCR3"
   
   
  cmyc <- melt(ex2, id.vars = c("REF"), variable.name ="phenotype")
  cmyc<-cmyc[cmyc$phenotype%in%c(
                                 paste0("TREG_",seq(1,6))),]
   cmyc$value<-as.numeric(cmyc$value)
      cmyc<-cmyc[!is.na(cmyc$value),]
   cmyc$marker<-"cMYC"
   
  lag3 <- melt(ex3, id.vars = c("REF"), variable.name ="phenotype")
  lag3<-lag3[lag3$phenotype%in%c(paste0("Macrophage_",seq(1,6))),]
  
  
   lag3$value<-as.numeric(lag3$value)
  lag3<-lag3[!is.na(lag3$value),]
   lag3$marker<-"HLADR"
   
   tim3 <- melt(ex4, id.vars = c("REF"), variable.name ="phenotype")
  tim3<-tim3[tim3$phenotype%in%c("TREG_1","TREG_2","TREG_3","TREG_4","TREG_5","TREG_6"),]
   tim3$value<-as.numeric(tim3$value)
  tim3<-tim3[!is.na(tim3$value),]
   tim3$marker<-"Vimentin"
   
   long<-rbind(long,cxcr3,cmyc,lag3,tim3)
   
  df <- plyr::ddply(long,.(REF,phenotype,marker),summarize, Mean=mean(value), SD=sd(value),N=length(value))
  df$se<-df$SD/sqrt(df$N)
  ggplot(df, aes(x = phenotype , y = Mean, fill=REF)) +
    geom_bar(stat = "identity", position = position_dodge()) + facet_wrap(.~marker) +
    ggtitle("Differential States") + ylab("Mean normalized intensity") + scale_fill_manual(values=getResponderColors()[1:2])+
    # add 90% CI errorbar 
    geom_errorbar(aes(ymin = Mean - 1.48*se, ymax = Mean + 1.48*se), width = 0.2, position=position_dodge(0.9))+theme_ipsum(base_family = "Arial")+
    theme(axis.text.x=element_text(colour="black"))+coord_flip()
  
```  

### UMAP stratified by treatment refractory.
- REVISION 9-6:  creates the UMAP plot with continuous expression in a panel of the top differential marker states at global level.
```{r}
  express<-t(assays(sce)$exprs)%>%as.data.frame
  express$sample_id<-colData(sce)$sample_id
  express<-express%>%group_by(sample_id)%>%summarise_all(mean)
  express$REF<-colData(sce)$REF[match(express$sample_id,colData(sce)$sample_id)]
 
  library(reshape2)
  library(ggh4x)
  xy <- ump[match(colData(sce)$id,ump$uniqueLabel) ,c("umap_x","umap_y")]
  df <- data.frame(colData(sce), xy, check.names = FALSE)
  
  express<-t(assays(x2)$counts)
  rownames(express)<-colData(sce)$id
  express<-express[match(df$id,rownames(express)),]
  
  df<-cbind(express,df)
  
  
  data2<-melt(df[,c("umap_x","umap_y","group_id","patient_id","ICOS","PDL1","Vista","pSTAT3","HLADR")],id=c("umap_x","umap_y","group_id","patient_id"))
  
  ggplot(data2, aes(x = umap_x, y =umap_y,color=(value))) +
    geom_point(size=0.5) + facet_nested(variable ~ group_id)+theme(strip.text.y = element_text(size = 7, colour = "black", angle=0),
                                                                              axis.ticks.length=unit(0.15,"cm"),
                                                                              axis.ticks.y=element_blank(),
                                                                              axis.text.y=element_blank())+
    scale_fill_gradient(low = "black", high = "yellow", na.value = NA)+theme_ipsum()

  
  ##global expression boxplotting.
  ## need to debug the plotPbExpression
  plotPbExprs(sce, k = "merging1", 
                   color_by="REF")
  
  ##manually print in middle of script.
  ggplot(df,aes(REF,value,col=REF))+facet_wrap(~antigen)+geom_boxplot()+scale_color_manual(values=c("firebrick2","darkslateblue"))+theme_ipsum()
 
```

### UMAP by including abundances withing 15 micron distance to family phenotypes
- UMAP with the addition of spatial distance.
- REVISION: 10-5  add the nearest neighbor distance to tumor/endo and plot all the family umap.
```{r}

  expr.cell<-as.data.frame(t(assays(sce)$exprs))
  expr.cell$sample_id<-sce$sample_id
  expr.cell$id<-sce$id
  expr.cell$cellType<-cluster_ids(sce,"merging1")
  for(i in unique(expr.cell$sample_id)){
    expr.cell[which(sce$sample_id==i),"id"]<-paste0(i,"_",1:nrow(expr.cell[which(sce$sample_id==i),]))
  }
  rownames(Hpool)<-Hpool$ROI
  with(Hpool,npoints(point))
  ## using the counts of family within 15 micron distances.
   allphenos<-unique(as.character(cluster_codes(sce)$merging1))
  allD<-matrix(0, nrow=nrow(expr.cell),ncol=length(allphenos))
  colnames(allD)<-allphenos
  rownames(allD)<-expr.cell$id
  allD<-as.data.frame(allD)
  for(roi in Hpool$ROI){
    testpoint<-Hpool$point[[which(Hpool$ROI==roi)]]
   alld<-nndist(testpoint,by=marks(testpoint)) 
   # alld2<-apply(alld,2,function(x) ifelse(x<=15,1,0))
    alld2<-as.data.frame(alld)
    rownames(alld2)<-paste0(roi,"_",seq(1:nrow(alld2)))
    allD[match(rownames(alld2),rownames(allD)),match(colnames(alld2),colnames(allD))]<-alld2
  }

  ##append expression with the distances.
  allD<- allD[match(expr.cell$id,rownames(allD)),]
  all(rownames(allD)==expr.cell$id)
  allD$id<-rownames(allD)
  allD<-left_join(allD,expr.cell,by="id")
  rownames(allD)<-allD$id
 allD<-allD[,which(colnames(allD)!="sample_id" & colnames(allD)!="id")]

 ##endoDistance average
 endoD<-allD[,grepl("Endo",colnames(allD))]%>%rowMeans%>%data.frame
 tumD<-allD[,grepl("tumor",colnames(allD))]%>%rowMeans%>%data.frame
 allD2<-data.frame(endoD,tumD)
 colnames(allD2)<-c("endo.avg","tumor.nnd")
 allD2<-percentilenormalize(data=allD2,percentile=0.999)
 allD$endo.avg<-allD2$endo.avg
 allD$tum.avg<-allD2$tumor.nnd

  library(umap)
  rois<-sapply(strsplit(rownames(allD),"_"),function(x) x[2])
  sid<-NULL
 for(roi in unique(rois)){ 
  sid<-c(sid,sample(rownames(allD)[grepl(roi,rownames(allD))],0.65*length(   rownames(allD)[grepl(roi,rownames(allD))])) )  
 }
    #######################################################
  ##includes tumor and endothelial distances inside map.
   umap.result<-umap(allD[,c(23:53,55,56)])
  
   save(umap.result,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/umap-full-8-28/umap.result.fullDLBCL_scaledDistance.tumor.endo.65.RData")
#############################################################
   ##load the umap full data.
  ump<-data.frame(umap_x=umap.result$layout[,1],umap_y=umap.result$layout[,2])
   
 ump$response<-colData(sce)$group_id[match(sapply(strsplit(rownames(ump),"_"),function(x) paste0(x[1],"_",x[2])),colData(sce)$sample_id)]
 ump$celltype<-expr.cell[match(rownames(ump),expr.cell$id),"cellType"]
 
 
 
 library(hrbrthemes)
 getPhenoColorsAnnotatedLabel<-function(full.dn4,phenotype="annotated.label.back_akil"){
 ##this requires the T-Cell names to not be included.
 require(circlize)
  tsn<-full.dn4[which(!is.na(full.dn4$tSNE1) & !is.na(full.dn4$tSNE2)),c("tSNE1",
	"tSNE2",
	"Cell_CD20",
	"Cell_CD3",
	"Cell_CD4",
	"Cell_CD31",
	"Cell_CD4",
	"Cell_CD68",
	"Cell_CD8",
	"Cell_FOXP3",
	"Cell_BCL2",
	"uniqueLabel","response","ROIID",
	phenotype)]
  
  ##balanced response representation.
   tsn$primary.phenotype<-(tsn[,phenotype])
   labs<-unique(full.dn4$annotated.label.back_akil)
   
   cd8s<-colorRampPalette(c("darkseagreen","green"),5)
  cd4s<-colorRampPalette(c("lightsteelblue1","blue"),5)
  macs<-colorRampPalette(c("magenta","maroon4"),5)
   tregs<-colorRampPalette(c("plum2","purple"),5)
   tumrs<-colorRampPalette(c("grey24","grey64"),20)
endos<-colorRampPalette(c("rosybrown1","red"),20)

     phenoColors<-c(cd4s(length(labs[grepl("CD4",labs)])),
	cd8s(length(labs[grepl("CD8",labs)])),
	macs(length(labs[grepl("MAC",labs)])),
	tregs(length(labs[grepl("T-reg",labs)])),
	tumrs(length(labs[grepl("tumor",labs)])),
	'bisque',
	endos(length(labs[grepl("Endothelial",labs)]))
	)

  names(phenoColors)<-levels(full.dn4[,phenotype])   


   return(phenoColors)
 }

  akilColor<-getPhenoColorsAnnotatedLabel(full.dn4)
  
  ggplot(ump,aes(x=umap_x,y=umap_y,color=celltype))+geom_point()

#  ggplot(ump,aes(x=umap_x,y=umap_y,color=response))+geom_point()

   
  #REVISION : 8-29: the cluster labels use the sub-cluster labeling. and all cells are used/
  phenoColorsLabel<-akilColor
   responseColorsLabel<-getResponderColors() 
 #names(responseColorsLabel)<-c("CR","Primary refract","not enriched")
   ##filter the cells that are far off the window.
   ### global tsne plotting.
 full<-ggplot(ump,  aes(x = umap_x, y = umap_y, color = celltype)) +
  geom_point(size = 0.8,alpha=0.8) +
  theme_ipsum(base_family='Arial') +
  scale_color_manual(values = phenoColorsLabel) +
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))+theme(panel.spacing=unit(1,"lines"))
  full
  full+theme(legend.position = "none")

  
```



## Abundance plots by cluster
- plot the abundance results of particular clusters that are significant from the model at the cluster level to illustrate the main figure REF model results.


```{r}
 plotAbundances(sce,k="merging2",group_by="REF",k_pal=phenoColors)

abundance.fam<-plotAbundances(sce, k = "merging1", by = "cluster_id", shape_by = "patient_id",
               group_by="REF")
# Analysis of the SCE experiment family level (pooled)
topTable(ref_DA,format_vals = TRUE,top_n=10,show_logFC = TRUE)

  ns <- table(cluster_id = cluster_ids(sce,"merging2"), sample_id = sample_ids(sce))
  fq <- prop.table(ns, 2) * 100
  df <- as.data.frame(fq)
  m <- match(df$sample_id, sce$sample_id)
  df<-df[which(df$cluster_id%in%c("Tumor_8(Non-Inflam.)","CD4_3(Act./Early/Exh.)","CD4_6(Act./Prolif.)")  ),]
  df$response<-colData(sce)$REF[match(df$sample_id,colData(sce)$sample_id)]
  cluster.abund.ref.da<-ggplot(df,aes(x=response,y=Freq,fill=response))+
    geom_violin(alpha=0.3)+
    theme_ipsum()+
    theme(axis.text.x=element_text(size=25))+
    scale_fill_manual(values=c("firebrick2","darkslateblue"))+
    ylab("Phenotype case proportion(%)")+
    xlab("Treatment response")+
    geom_point(size=4,color='black',alpha=0.3)
  cluster.abund.ref.da+facet_wrap(~cluster_id)

  
  ##expression at the family level.
diffcyt::topTable(joint_ref_NGCB_IPI_DS,format_vals = TRUE,top_n=30,show_logFC = TRUE)

  ##need to debug to manually print boxplot
  plotDiffHeatmap(sce2, rowData(joint_ref_NGCB_IPI_DS$res), top_n = 7, fdr = 0.05,lfc=0)
  
 
  #target to show
  ds.targ<-c("pSTAT3(PD-L1+M2-MAC(2))", 
             "pSTAT3(Act.Endothelial(3,6))",
             "pSTAT3(M2-MAC(1,5,6))",
             "Lag3(Hi.Suppress.T-reg(1,2,6))")
  
  
  
  global_merging1 <- plotPbExprs(sce, k = "merging1", 
                   color_by="REF",
    shape_by = "patient_id")
  
  df<-df[df$antigen%in%c("PDL1","pSTAT3","Vista","ICOS"),]

  ggplot(df,aes(x=REF,y=value,fill=REF))+geom_boxplot()+facet_wrap(~antigen)+theme_bw()+theme(axis.text.y=element_text(color="black",size=19),
                                                                                                    axis.text.x=element_text(color="black",size=15),strip.text.x=element_text(size=15,color="black"))+
     scale_fill_manual(values=c("firebrick2","darkslateblue"))+ylab("Median normalized intensity")+xlab("Response")+geom_jitter(alpha=0.4)+stat_compare_means(method="t.test")
  
```


### Linear model of zonal intensity zero inflated NB
- REVISION:  10-27:  we use a zero inflated NB model because these counts have more 0s. so we use the intensities but scale by 100,000 and perform a zinb model based on patient features ipi, ref, and molecular subtypes.
- we multiply the p-values from the model by 23 to account for multiple testing all the families, fortunately we passed this criteria.
- the nearest neighbor distance model which was created by created a mean cutpoint for pstat3 on the high supp treg to identify  Hi. Supp T-reg: pstat3+ cells, and their distance pattern to the exh/inflam cd8, M2-MAC, and early exh CD4 does match all the directions from the model.
- importantly we create a null model to test for CSR of the observed counts in the given T-reg hotspot reagion. we permuted 200 times the labels to recreate artificial T-reg hot spots under the null. by overlapping the masks, there are several T-reg zones containing Hi.Supp T-reg: pstat3+ combinations with baseline, proliferative T-regs, so for each permutation, we average across all patients per t-reg hotspot, and take an average of the zones.  This means that for 200 permutations, for each permutation, we have a patient average intensity per zone.  Averaging the zones (each are baesd on Hi.Supp Treg:pstat3+) we create a random normal variable to generate 1,000 RVs.  we then compare the grand average of the observed intensities across zones, across patients to the CSR.  does fairly well.
- REVISION 11-3: we use a logistic model to show prediction and avoid mutli testing on inference.
- using a prediction model we identified Prolif CD4, Exh/Inflam CD4,  M2-MAC
```{r}
 load("~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/masks-lists-zones/pstatList_5threshold.RData")
 load("~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/hyperframe/Hpool_continuousMarks.RData")
 allPhenos<-with(Hpool,marks(point)$marks%>%unique)%>%unlist%>%unique
   ##estimates for each region

    H<-Hpool[which(Hpool$ROI!="ROIID_3969"),]
   H$HighIPI<-colData(sce)$HighIPI[match(H$ROI,colData(sce)$sample_id)]
 

  countIntensityPhenotypePerArea<-function(tcell.im=NULL,
                                  allppp=NULL
                                   ){
  intList<-data.frame( matrix(0,nrow=length(levels(tcell.im)),ncol=length(marks(allppp)%>%levels)))
  rownames(intList)<-levels(tcell.im)
  colnames(intList)<-levels(marks(allppp))
  allcounts<-quadratcount(split(allppp),tess=as.tess(tcell.im))
  ints<-sapply(allcounts,function(x) x/tile.areas(as.tess(tcell.im)))
   
  return(ints)
  }
  
  allz<-sapply(pstatList,function(x) levels(x$tregzone.pstat3$image))%>%unlist%>%unique
    poolPheno<- with(Hpool,unique(marks(point)$marks))%>%unlist%>%unique()%>%as.character
    zones<-as.data.frame(matrix(0, nrow=nrow(H)*length(allz),ncol=length(poolPheno)))
    colnames(zones)<-poolPheno
    zones$ROIID<-rep(H$ROI,each=length(allz))
    zones$zone<-rep(allz,nrow(H))

    
 for(i in names(pstatList)){
   tregmask<-pstatList[[i]]$tregzone.pstat3
   myp<-pstatList[[i]]$ppp
  # count the intensity in each region
  cc<-as.data.frame(countIntensityPhenotypePerArea(tcell.im=tregmask,
                                     allppp=myp))
   for(jj in 1:nrow(cc)){
  zones[which(zones$ROIID==i& zones$zone==rownames(cc)[jj]),match(colnames(cc),colnames(zones))]<-cc[jj,]
   } 
   
 }    
    
  hotsp<-zones[which(grepl("pSTAT3",zones$zone)&grepl("Hi.Suppress.",zones$zone)),]
  hotsp$highIPI<-H$HighIPI[match(hotsp$ROIID,H$ROI)]
  hotsp$response<-H$treatment[match(hotsp$ROIID,H$ROI)]
  hotsp$C1<-colData(sce)$C1[match(hotsp$ROIID,colData(sce)$sample_id)]
  hotsp$C2<-colData(sce)$C2[match(hotsp$ROIID,colData(sce)$sample_id)]
  hotsp$C3<-colData(sce)$C3[match(hotsp$ROIID,colData(sce)$sample_id)]
  hotsp$C4<-colData(sce)$C4[match(hotsp$ROIID,colData(sce)$sample_id)]
  hotsp$C5<-colData(sce)$C5[match(hotsp$ROIID,colData(sce)$sample_id)]
  hotsp$case<-colData(sce)$patient_id[match(hotsp$ROIID,colData(sce)$sample_id)]
 
   test<-data.frame(hotsp)
    test$highIPI<-factor(test$highIPI,levels=c("LowIPI","HighIPI"))
      test$response<-factor(test$response,levels=c("CR","Primary refract"))

  
  	
   library(multcomp);library(lme4)
	    subExpr<-test
  subExpr[,1:22]<-round(subExpr[,1:22]*10000)
  
   subExpr$zone<-factor(subExpr$zone,levels=c(
    "Hi.Suppress.T-reg(1,2,6)xpSTAT3","Hi.Suppress.T-reg(1,2,6)xAct./Prolif.T-reg(5)xpSTAT3",
    "Hi.Suppress.T-reg(1,2,6)xBaseline T-reg(3,4)xAct./Prolif.T-reg(5)xpSTAT3",
"Hi.Suppress.T-reg(1,2,6)xBaseline T-reg(3,4)xpSTAT3"                        
 ))
  
  library(MASS)
  library(pscl)
  library(DHARMa)
   
  zeroInfTest<-function(model=NULL){
   simout<- simulateResiduals(fittedModel = model, n=250)
 print( testZeroInflation(simout))
plotSimulatedResiduals(simulationOutput = simout)
 testUniformity(simulationOutput = simout)  
    
  }
  findDispersion<-function(model=NULL){
     E2 <- resid(model, type = "pearson")
N  <- nrow(subExpr)
p  <- length(coef(model)) + 1 # '+1' is due to theta
sum(E2^2) / (N - p) 
 return(sum(E2^2) / (N - p) )
  }
  
### unsupervised detection and Zero inflation. tests.
  ### screening for phenotypes and testing for zero inflation.
  ## regular GLM commands.
 ## CD8 tests.
## baseline NULL  
  ## REVISION 11-1;  C14.VS.C235 DIFFERENCES 
  ps<-NULL  
  
 b8<-  glm.nb(Baseline.CD8.7.  ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)
   zeroInfTest(model=b8) 
   findDispersion(model=b8)
summary(b8) 

 ## 11-1 : Chapuy contrast   baseline CD8 +C1 ,  -C5
 b8.chap<-glm.nb(Baseline.CD8.7.  ~ highIPI+C1+C3+C5+zone, data=subExpr) 

 #ps<-coef(summary(b8))["responsePrimary refract",4]
 
###  Model CD4/CD8
# b8.z<-zeroinfl(Baseline.CD8.7.  ~ highIPI*response+C1+C2+C3+C4+C5|zone, data=subExpr)
# findDispersion(model=b8.z)

 ## exh CD8 NULL  
   exhinfcd8.nb<-  glm.nb(Exh..Inflam.CD8.2.6. ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)
   zeroInfTest(model=exhinfcd8.nb) 
   findDispersion(model=exhinfcd8.nb)
  summary(exhinfcd8.nb)

   #ps<-c(ps,coef(summary(exhinfcd8.nb))["responsePrimary refract",4])

  
## Chapuy  :   -C2,  +C4
  exhinfcd8.nb.chap<-glm.nb(Exh..Inflam.CD8.2.6. ~ highIPI+C2+C4+zone, data=subExpr)

  
  ### compare to ZINB (ZINB does worse)
  # exhinfcd8.z<-  zeroinfl(Exh..Inflam.CD8.2.6. ~ highIPI+response+C1+C2+C3+C4+C5| zone, data=subExpr)
  # findDispersion(model=exhinfcd8.z)
#  summary(exhinfcd8.nb)
  
  
  ###prol cd8 significant associated with REF.
  prolcd8.nb<-  glm.nb(Act..Prolif.CD8.1.4. ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)
  zeroInfTest(model=prolcd8.nb) 
   findDispersion(model=prolcd8.nb)
  summary(prolcd8.nb)
  prolcd8.nb.nest<-glm.nb(Act..Prolif.CD8.1.4. ~ highIPI+response+C1+C4+zone, data=subExpr)
   #  ps<-c(ps,coef(summary(prolcd8.nb.nest))["responsePrimary refract",4])
  summary(prolcd8.nb.nest)
  
 # prolcd8.z<-  zeroinfl(Act..Prolif.CD8.1.4. ~ highIPI*response+C1+C2+C3+C4+C5| case, data=subExpr)
#   findDispersion(model=prolcd8.z)
#  summary(prolcd8.z)
  
  ### Chapuy model:
  glm.nb(Act..Prolif.CD8.1.4. ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)%>%summary
  
  ## null. 
  t8<-  glm.nb(Terminal.Exhaust.CD8.3.5.  ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)
 zeroInfTest(model=t8) 
   findDispersion(model=t8)
  summary(t8)
  t8.nest<-glm.nb(Terminal.Exhaust.CD8.3.5.  ~ highIPI+response+C2+C3+C4+zone, data=subExpr)
   #  ps<-c(ps,coef(summary(t8.nest))["responsePrimary refract",4])

  ## Chapuy: -C2, -C3, +C4
  glm.nb(Terminal.Exhaust.CD8.3.5.  ~ highIPI+C1+C2+C3+C4+C5+zone, data=subExpr)
  
  
  ### do not see significant CD8 association, and most have reasonable dispersion, with  non-zero inflation.
  
## Cd4 
## exh/inflam 4  significant
   exh4.nb<- glm.nb(Exh..Inflam.CD4.1.5. ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)
       zeroInfTest(model=exh4.nb)
      summary(exh4.nb)
      exh4.nest.nb<- glm.nb(Exh..Inflam.CD4.1.5. ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)

  #  ps<-c(ps,coef(summary(exh4.nest.nb))["responsePrimary refract",4])
    
### compare      
       
    ##null  (not significant interaction)    
   act4.nb<- glm.nb(Act..Early.Exh.CD4.2.3.7. ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)
     zeroInfTest(model=act4.nb) 
      findDispersion(model=act4.nb)
  summary(act4.nb) 

 #ps<-c(ps,coef(summary(act4.nb))["responsePrimary refract",4])
       
## Significant under NB, but NULL under CSR.  
   prol4.nb<- glm.nb(Act..Prolif.CD4.6. ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)
       zeroInfTest(model=prol4.nb) 
       findDispersion(model=prol4.nb)
  summary(prol4.nb) 
  # ps<-c(ps,coef(summary(prol4.nb))["responsePrimary refract",4])

  ##nested
   prol4.nb.nest<-glm.nb(Act..Prolif.CD4.6. ~ highIPI+response+C1+C2+C3+C4+zone, data=subExpr)

  ##null 
  b4.nb<- glm.nb(Baseline.CD4.4. ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)
  summary(b4.nb) 
  # ps<-c(ps,coef(summary(b4.nb))["responsePrimary refract",4])
    
#################################################################  
   ## Mac
 m2mac.nb<- glm.nb( M2.MAC.1.5.6. ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)
 zeroInfTest(model=m2mac.nb) 
   findDispersion(model=m2mac.nb)
  summary(m2mac.nb)
  library(lmtest)
    ## Mac
 m2mac.nb.nest<- glm.nb( M2.MAC.1.5.6. ~ Exh..Inflam.CD4.1.5.+response+C1+C4+C5+zone, data=subExpr)
lrtest(m2mac.nb.nest,m2mac.nb)
  #  ps<-c(ps,coef(summary(m2mac.nb.nest))["responsePrimary refract",4])

## Chapuy:
 glm.nb( M2.MAC.1.5.6. ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)%>%summary


 ## M1, pdl1  NULL wrt  ref
  m1.nb<-  glm.nb(M1.MAC.3.4.  ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)
  
  
  pdl1m2.nb<-  glm.nb(PD.L1.M2.MAC.2.  ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)
 ## nesting out the model does not identify significant association with REF
  glm.nb(PD.L1.M2.MAC.2.  ~ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)%>%summary
  glm.nb(PD.L1.M2.MAC.2.  ~ highIPI+response+C1+C3+zone, data=subExpr)%>%summary
##########################################################################################
  ##########################################################################################
################## PREDICTION MODEL  WE KNOW WE HAVE INFLATED P-VALUES
  ## rejecting this due to CSR
  library(caret)
 # inTrain <- createDataPartition(y = subExpr, p = .60, list = FALSE)
  #training <- cats[inTrain,] 
  #testing <- cats[-inTrain,]
  
  ### LOGIT USING PREDICTION SCORES.
  m2pred<-predict(m2mac.nb.nest)
  exhpred<-predict(exh4.nb)
  prolif4<-predict(prol4.nb)
  prol8<-predict(prolcd8.nb.nest)
  subExpr$exhpred<-exhpred
  subExpr$m2pred<-m2pred
  subExpr$prol8<-prol8
  subExpr$prolif4<-prolif4

  
  subExpr$response.bin<-ifelse(subExpr$response=="Primary refract",1,0)
  
   cats<-subExpr%>%group_by(ROIID,response.bin)%>%summarise(exhpred=mean(exhpred),m2pred=mean(m2pred),
                                                            prol8=mean(prol8),
                                                            prolif4=mean(prolif4))%>%data.frame
   cats$HighIPI<-subExpr$highIPI[match(cats$ROIID,subExpr$ROIID)]
  
  
   library(caret)
     # balanced folding 
   folds.cr <- createFolds(cats$ROIID[which(cats$response.bin==0)], k =3, list = TRUE, returnTrain = FALSE)
   folds.cr<-lapply(folds.cr,function(x) cats$ROIID[which(cats$response.bin==0)][x]  )
   folds.ref <- createFolds(cats$ROIID[which(cats$response.bin==1)], k =3, list = TRUE, returnTrain = FALSE) 
   folds.ref<-lapply(folds.ref,function(x)cats$ROIID[which(cats$response.bin==1)][x])
    while( any(sapply(folds.ref,length)==1)){
       folds.ref <- createFolds(cats$ROIID[which(cats$response.bin==1)], k =3, list = TRUE, returnTrain = FALSE) 
   folds.ref<-lapply(folds.ref,function(x)cats$ROIID[which(cats$response.bin==1)][x])
    }
   while( any(sapply(folds.cr,length)==1)){
      folds.cr <- createFolds(cats$ROIID[which(cats$response.bin==0)], k =3, list = TRUE, returnTrain = FALSE)
   folds.cr<-lapply(folds.cr,function(x) cats$ROIID[which(cats$response.bin==0)][x]  )
    }
   
   
 valres.ac<-NULL
 trres.ac<-NULL
 
 valipi<-NULL
 tripi<-NULL
 for(k in 1:3){
   inTrain<-as.character(c(folds.cr[-k]%>%unlist,folds.ref[-k]%>%unlist))
   inTest<-as.character(c(folds.cr[k]%>%unlist,folds.ref[k]%>%unlist))

   training <- cats[match(inTrain,cats$ROIID),]
   testing <- cats[match(inTest,cats$ROIID),]

   cats.fit<-glm(response.bin~exhpred+m2pred,family="binomial",data=training)
  ipi.fit<-glm(response.bin~HighIPI,family="binomial",data=training)
   summary(cats.fit)
    
    cats.prob = predict(cats.fit, testing, type="response")
cats.pred = rep("CR", dim(training)[1])
cats.pred[cats.prob > .5] = "Primary refractory"
## confusion matrix
table(cats.pred, training$response.bin)
## average accuracy
  trres.ac<-c(trres.ac,mean(cats.pred == ifelse(training$response.bin==1,"Primary refractory","CR")))
## error 
 #1-mean(cats.pred == ifelse(training$response.bin==1,"Primary refractory","CR"))

## IPI train
 cats.prob = predict(ipi.fit, testing, type="response")
cats.pred = rep("CR", dim(training)[1])
cats.pred[cats.prob > .5] = "Primary refractory"
## confusion matrix
table(cats.pred, training$response.bin)
## average accuracy
  tripi<-c(tripi,mean(cats.pred == ifelse(training$response.bin==1,"Primary refractory","CR")))
  


 ### 
 cats.val<-glm(response.bin~exhpred+m2pred,family="binomial",data=testing)
 ipi.val<-glm(response.bin~HighIPI,family="binomial",data=testing)

   summary(cats.val)

    cats.prob = predict(cats.val, testing, type="response")
cats.pred = rep("CR", dim(testing)[1])
cats.pred[cats.prob > .5] = "Primary refractory"
## confusion matrix
table(cats.pred, testing$response.bin)
## average accuracy
mean(cats.pred == ifelse(testing$response.bin==1,"Primary refractory","CR"))
## error 
#1-mean(cats.pred == ifelse(testing$response.bin==1,"Primary refractory","CR"))

## collect the data and repeat.
 valres.ac<-c(valres.ac,mean(cats.pred == ifelse(testing$response.bin==1,"Primary refractory","CR"))
)
 ### IPI
 cats.prob = predict(ipi.val, testing, type="response")
cats.pred = rep("CR", dim(training)[1])
cats.pred[cats.prob > .5] = "Primary refractory"
## confusion matrix
table(cats.pred, training$response.bin)
## average accuracy
  valipi<-c(valipi,mean(cats.pred == ifelse(training$response.bin==1,"Primary refractory","CR")))
}
 
 

# cv<-data.frame(CV=c(mean(grandVal),mean(IPIval)),
 #               SE=c(sd(grandVal)/sqrt(3),sd(IPIval)/sqrt(3)),
  #              feature=c("M2-MAC, Exh./Inflam CD4","IPI"),
   #             stringsAsFactors = T)
 #cv$lower<-cv$CV-1.96*cv$SE
 #cv$upper<-cv$CV+1.96*cv$SE
# ggplot(cv,aes(x=feature,y=CV))+geom_bar(stat='identity',width=0.5)+geom_errorbar(aes(ymin=lower,ymax=upper),width=0.2)+ylab("Prediction accuracy (3-fold-CV)")+xlab("Treatment refractory predictor") 

 ##binary

cats.fit<-glm(response.bin~exhpred+m2pred,family="binomial",data=cats)

  library(jtools)
  #effect_plot(cats.fit, pred = m2pred, interval = TRUE, y.label = "% resistance to therapy")
  m2eff<-effect_plot(cats.fit, pred = m2pred, interval = TRUE, y.label = "Probability of treatment refractory")+xlab("M2-MAC(1,5,6)")+theme(axis.text=element_text(color="black",size=15))
  cd4eff<-effect_plot(cats.fit, pred = exhpred, interval = TRUE, y.label = "Probability of treatment refractory")+xlab("Exh./Inflam CD4(1,5)")+theme(axis.text=element_text(color="black",size=15))
  # ipieff<-effect_plot(cats.fit, pred = HighIPI, interval = TRUE, y.label = "Probability of treatment refractory")+xlab("High-IPI(>3)")+theme(axis.text=element_text(color="black",size=15))

   ## accuracy measures  (bar plot with 95% CI)
 cats.prob = predict(cats.fit, cats, type="response")
cats.pred = rep("CR", dim(cats)[1])
cats.pred[cats.prob > .5] = "Primary refractory"

  example <- confusionMatrix(data= factor(cats.pred), reference = factor(ifelse(cats$response.bin==1,"Primary refractory","CR")))

   fourfoldplot(example$table, color = c("darkgrey", "pink"),
             conf.level = 0, margin = 1, main = "Confusion Matrix")
 spats<-example$overall
  
#### IPI model
   
    ipi.fit<-glm(response.bin~HighIPI,family="binomial",data=cats)
 cats.prob = predict(ipi.fit, cats, type="response")
cats.pred = rep("CR", dim(cats)[1])
cats.pred[cats.prob > .5] = "Primary refractory"

  example2<-confusionMatrix(data= factor(cats.pred), reference = factor(ifelse(cats$response.bin==1,"Primary refractory","CR")))
  ipis<-example2$overall
   
  cv<-data.frame(Accuracy=c(spats[1],ipis[1]),lower=c(spats[3],ipis[3]),upper=c(spats[4],ipis[4]),feature=c("M2-MAC,Exh./Inflam CD4","High IPI(>3)"))
  
   ggplot(cv,aes(x=feature,y=Accuracy))+geom_bar(stat='identity',width=0.5)+geom_errorbar(aes(ymin=lower,ymax=upper),width=0.2)+ylab("Prediction accuracy (3-fold-CV)")+xlab("Treatment refractory predictor")+theme_ipsum()+theme(axis.text=element_text(color="black",size=10)) 
                                                                                                                           
                                                                                                                              
 
#### perform leave one out cross validation to a prediction model.
 library(sjPlot)
 tab_model(ipi.fit, cats.fit)
  
  tab_model(ipi.fit,cats.fit,
  pred.labels = c("Intercept", 
                  "High IPI (>3)",
                  "Exh./Inflam CD4(1,5)",
                  "M2-MAC(1,5,6)"),
  dv.labels = c("IPI", "M2-MAC(1,5,6), Exh.Inflam CD4(1,5)"),
  string.pred = "Coeffcient",
  string.ci = "Conf. Int (95%)",
  string.p = "P-Value",
  file="~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-figure-revision/NBIN/logistic-prediction/temp.html"
)
  
  ### these predictos are not significantly associated with IPI.
 ### testing if the features are associated with   IPI
       ipi.conf<-glm(HighIPI.bin~exhpred+m2pred,family="binomial",data=cats)

  ##
  
    
####################################################  
#####################################################
  #### back to inference
  
## inference model
  ## the problem is with multi test corrections. 
  
 ## gather the data to report
 ## gather the data to report
 c1<-data.frame(Estimate=coef(m2mac.nb.nest))
 m2est<-cbind(c1,confint(m2mac.nb.nest))
  colnames(m2est)<-c("Estimate","lower","upper")
  m2est$phenotype<-"M2-MAC(1,5,6)"  
     m2est$pvals<-coef(summary(m2mac.nb.nest))[,4]

        exh4.nest.nb<- glm.nb(Exh..Inflam.CD4.1.5. ~M2.MAC.1.5.6.+ highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)

## CRs
  c3<-data.frame(Estimate=coef(exh4.nest.nb))
 a4<-cbind(c3,confint(exh4.nest.nb))
  colnames(a4)<-c("Estimate","lower","upper")
  a4$phenotype<-"Exh./Inflam.CD4(1,5)"  
 a4$pvals<-coef(summary(exh4.nest.nb))[,4]



  ngfinal<-rbind(m2est["responsePrimary refract",],a4["responsePrimary refract",])
  ngfinal$adj.p<-ngfinal$pvals  ## multiply by total family
  ngfinal$sym=""
  ngfinal$sym[which(ngfinal$adj.p<0.05)]<-"*"
  ngfinal$direction<-"Primary refractory"
  ngfinal$direction[which(ngfinal$Estimate<0)]<-"CR"
  ggplot(ngfinal,aes(x=phenotype,y=Estimate,label=sym,color=direction))+geom_point(size=4)+geom_errorbar(aes(ymax=upper,ymin=lower),width=0.2)+geom_hline(yintercept = 0,linetype="dashed",color="red",size=1)+theme_ipsum()+theme(axis.text=element_text(color="black"),axis.text.x=element_text(size=12),axis.text.y=element_text(size=16),legend.position="none")+geom_text(color="black",nudge_y=(-0.025),nudge_x=(0.05),size=10)+coord_fixed(ratio=0.05)+coord_flip()+ylab("Expected change comparing REF to CR of (log) counts (intensity per 100,000)")+xlab("Phenotypes (CSR p<0.01)")+scale_color_manual(values=c("blue","red"))
  
  
  ## need to include zero inflation testing and the overdispersion parameter
  ## append the zerio inflation test and dispersion statistic to the final sheet.
  
### final NB prediction of Exh/CD4 ~ Cox  
  final.exh4.nb<- glm.nb(Exh..Inflam.CD4.1.5. ~M2.MAC.1.5.6.+highIPI+response+C1+C2+C3+C4+C5+zone, data=subExpr)
    preds<-predict(final.exh4.nb)    
  subExpr$ExhCD4.pred<-preds
  
   
    txb.sel.col=list(response=c("CR"="darkslateblue","Primary refract"="firebrick2"))

  zoneAn<-HeatmapAnnotation(response=subExpr$response,
                            which = "row",
                            col=txb.sel.col)

      Heatmap(subExpr[,c("M2.MAC.1.5.6.","Exh..Inflam.CD4.1.5.")],name="Intensity (per Area)*10000")+zoneAn
       
  par(mfrow=c(1,2))

 hist(subExpr$Exh..Inflam.CD4.1.5.,main="Exh./Inflam CD4(1,5)")
 hist(subExpr$M2.MAC.1.5.6.,main="M2-MAC(1,5,6)")
    
 
 ## final model outputs.
  zeroInfTest(model=exh4.nb) 
       findDispersion(model=exh4.nb)
       
     zeroInfTest(model=m2mac.nb.nest) 
       findDispersion(model=m2mac.nb.nest)   
  
 zero.inflatp<-c(0.088,0.36)       
      disper<-c(1.01,0.98) 
  ngfinal$ZeroInflation<-zero.inflatp
  ngfinal$dispersion<-disper    
  write.csv(ngfinal,file="~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-figure-revision/zeroInflatedNB/hotspot.zinb.csv")
  
  
   
##################print table#################################################################### 
  library(sjPlot)
 tab_model(m2mac.nb.nest, exh4.nest.nb)
  
  tab_model(m2mac.nb.nest,exh4.nest.nb,
  pred.labels = c("Intercept", "Exh./Inflam CD4(1,5)",
                  "Primary refractory", 
                  "C1",
                  "C4",
                  "C5",
                  "Hi.Suppress. T-reg, Act.Prolif.T-reg, pSTAT3+",
                  "Hi.Suppress. T-reg, Baseline T-reg, Act.Prolif. T-reg, pSTAT3+",
                  "Hi.Suppress. T-reg, Baseline T-reg, pSTAT3+",
                  "M2-MAC(1,5,6)",
                  "High IPI(>3)",
                  "C2","C3"),
  dv.labels = c("M2-MAC(1,5,6)", "Exh.Inflam CD4(1,5)"),
  string.pred = "Coeffcient",
  string.ci = "Conf. Int (95%)",
  string.p = "P-Value",
  file="~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-figure-revision/NBIN/temp.html"
)


  
#############
		    ## CSR TEST
		    ### loading in the permutations 
### compare the observed M2/ exh CD8 to the CSR         
     path<-"~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/masks-lists-zones/permutations/"
  nls<-dir(path)
  #  pclinic2<- metadata(sce)$experiment_info%>%data.frame
  permList<-list()
  
  for(j in nls){
 ##load permute
    print(j)
    load(paste0(path,j))
 
  ## compute hte zones
  allz<-sapply(permuteList,function(x) levels(x$tregzone.pstat3$image))%>%unlist%>%unique
    poolPheno<- with(Hpool,unique(marks(point)$marks))%>%unlist%>%unique()%>%as.character
   pzones<-as.data.frame(matrix(0, nrow=nrow(H)*length(allz),ncol=length(poolPheno)))
    colnames(pzones)<-poolPheno
    pzones$ROIID<-rep(H$ROI,each=length(allz))
    pzones$zone<-rep(allz,nrow(H))

    
 for(i in names(permuteList)){
   tregmask<-permuteList[[i]]$tregzone.pstat3
   myp<-permuteList[[i]]$ppp
  # count the intensity in each region
  cc<-as.data.frame(countIntensityPhenotypePerArea(tcell.im=tregmask,
                                     allppp=myp))
   for(jj in 1:nrow(cc)){
  pzones[which(pzones$ROIID==i& pzones$zone==rownames(cc)[jj]),match(colnames(cc),colnames(pzones))]<-cc[jj,]
   } 
   
 }    
    
  photsp<-pzones[which(grepl("pSTAT3",pzones$zone)&grepl("Hi.Suppress.",pzones$zone)),]
  photsp$highIPI<-H$HighIPI[match(photsp$ROIID,H$ROI)]
  photsp$response<-H$treatment[match(photsp$ROIID,H$ROI)]
  photsp$C1<-colData(sce)$C1[match(photsp$ROIID,colData(sce)$sample_id)]
  photsp$C2<-colData(sce)$C2[match(photsp$ROIID,colData(sce)$sample_id)]
  photsp$C3<-colData(sce)$C3[match(photsp$ROIID,colData(sce)$sample_id)]
  photsp$C4<-colData(sce)$C4[match(photsp$ROIID,colData(sce)$sample_id)]
  photsp$C5<-colData(sce)$C5[match(photsp$ROIID,colData(sce)$sample_id)]
  photsp$case<-colData(sce)$patient_id[match(photsp$ROIID,colData(sce)$sample_id)]
 
   ptest<-data.frame(photsp)
    ptest$highIPI<-factor(ptest$highIPI,levels=c("LowIPI","HighIPI"))
      ptest$response<-factor(ptest$response,levels=c("CR","Primary refract"))
  permList[[length(permList)+1]]<-ptest
    }## for loop
############################################
   save(permList,file="~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/masks-lists-zones/permList_450.RData")
####################################  
  load("~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/masks-lists-zones/permList_450.RData")
  
  
### act/prol CD4, Exh..Inflam.CD4.1.5., and M2-MACs 
  ##average by ROI
  ## m2 mac is CSR NULL
  ## each patient x permute  p<0.01
  ## average heterogeneous zones
## we look at each zone and average the ROI intensity for each hetero zone.  we then average across the zones (grand) for the NULL.  
  ## looking at the heterogeneous zones
 computeChiSquareStat<-function(permList,test=NULL,variable=NULL){
   rm<-sapply(permList,function(x) x%>%select(variable)%>%colMeans)
   om<-test%>%select(variable)%>%colMeans
   chs<-(om-rm)^2/rm
   return(chs)
 }
  
  
  rr2<-sapply(permList,function(x) x[which(x$zone!="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC)
  density(colMeans(rr2))%>%plot
  abline(v=test[which(test$zone!="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC%>%mean)
     obs<-test[which(test$zone!="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC%>%mean      
   table(obs>rowMeans(dd))
  
 
 rr<- sapply(permList,function(x) x[which(x$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC)
  colMeans(rr)%>%density%>%plot(main="CSR M2-MAC(1,5,6) p<0.01",xlim=c(4e-04,max(colMeans(rr))))
 ## grand average across zone for the NULL
 # density(colMeans(rr))%>%plot
   abline(v=test[which(test$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC%>%mean)
   obs<-test[which(test$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC%>%mean      
   table(obs>colMeans(rr))
 
  #### CD4  
   ### Exh/Inflam CD4  p<<0.01
  ## hetero zones
    cd4.het<-sapply(permList,function(x) x[which(x$zone!="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Exh..Inflam.CD4.1.5.))%$%M2MAC)
  density(colMeans(cd4.het))%>%plot
  abline(v=test[which(test$zone!="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Exh..Inflam.CD4.1.5.))%$%M2MAC%>%mean)
  #   obs<-test[which(test$zone!="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC%>%mean      
#   table(obs>rowMeans(dd))
 
  cd4.hom<- sapply(permList,function(x) x[which(x$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Exh..Inflam.CD4.1.5.))%$%M2MAC)
  colMeans(cd4.hom)%>%density%>%plot(main="CSR Exh/Inflam CD4 p<0.01",xlim=c(2.8e-04,5.2e-04))
   abline(v=test[which(test$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Exh..Inflam.CD4.1.5.))%$%M2MAC%>%mean)
  obs<-test[which(test$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Exh..Inflam.CD4.1.5.))%$%M2MAC%>%mean      
   table(obs>colMeans(cd4.hom))
   
 
 ## Act. prolif CD4 (nested) p=0.04  
    cd4.het<-sapply(permList,function(x) x[which(x$zone!="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC)
  density(colMeans(cd4.het))%>%plot
  abline(v=test[which(test$zone!="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC%>%mean)
  #   obs<-test[which(test$zone!="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC%>%mean      
#   table(obs>rowMeans(dd))
 
  cd4.hom<- sapply(permList,function(x) x[which(x$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC)
  colMeans(cd4.hom)%>%density%>%plot(main="CSR Exh/Inflam CD4 p<0.01")
   abline(v=test[which(test$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC%>%mean)
  obs<-test[which(test$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC%>%mean      
   table(obs>colMeans(cd4.hom))
   
     
  ## nested model for CD8 was significant
   cd8.het<-sapply(permList,function(x) x[which(x$zone!="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD8.1.4.))%$%M2MAC)
  density(colMeans(cd8.het))%>%plot
  abline(v=test[which(test$zone!="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD8.1.4.))%$%M2MAC%>%mean)
 
  cd8.hom<- sapply(permList,function(x) x[which(x$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD8.1.4.))%$%M2MAC)
  colMeans(cd8.hom)%>%density%>%plot(main="CSR Proliferative CD8 p<0.01", xlim=c(1.2e-04,2.1e-04))
   abline(v=test[which(test$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD8.1.4.))%$%M2MAC%>%mean)
  obs<-test[which(test$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD8.1.4.))%$%M2MAC%>%mean      
   table(obs>colMeans(cd8.hom))
    
   ## exh. inflam CD8
    ecd8.het<-sapply(permList,function(x) x[which(x$zone!="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Exh..Inflam.CD8.2.6.))%$%M2MAC)
  density(colMeans(ecd8.het))%>%plot
  abline(v=test[which(test$zone!="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Exh..Inflam.CD8.2.6.))%$%M2MAC%>%mean)
 
  ecd8.hom<- sapply(permList,function(x) x[which(x$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Exh..Inflam.CD8.2.6.))%$%M2MAC)
  colMeans(ecd8.hom)%>%density%>%plot(main="CSR Proliferative CD8 p<0.01",xlim=c(2.2e-04,4.3e-04))
   abline(v=test[which(test$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Exh..Inflam.CD8.2.6.))%$%M2MAC%>%mean,col='red')
 
    obs<-test[which(test$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Exh..Inflam.CD8.2.6.))%$%M2MAC%>%mean      
   table(obs>colMeans(ecd8.hom))
   
   
  
### 11-13:  we see non-CSR of the M2-macs prolif CD4, exh./inflam CD4 and prlif CD8 in both heterogeneous and homog.  T-reg pSTAT3+ zones.
   # method summary:  we looked at the intensity across all types of zones, and compared the observed intensity stratifying the heterogeneous zones, and the homogeneous zones.  we identify the patient average intensity for each zone type (hetero/homo) by averaging the intensity of a given phenotype in these zones.
   # the stratification is reasonable because mixed/hetero zones may have different spatial properties (larger areas) and more likely to have random counts there compared to homoegenous zones,  there is likely area differences which can influence the CSR testing, so we stratify this analysis.

   # we create the null by comparing grand averages.
   ## the features selected were identified from the negative binomial regression model.
   
  ## histograms to show 
 zz<-  unique(myl$zone)
 par(mfrow=c(4,2))
 ### M2-MAC  Has CSR need to stratify
 ### Hi.Suppress T-reg x pstat3 is non-CSR
  rr2<-sapply(permList,function(x) x[which(x$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC)
  density(colMeans(rr2))%>%plot(main="M2-MAC in mixed Hi.Supp.T-reg pSTAT3+ zone")
  abline(v=test[which(test$zone=="Hi.Suppress.T-reg(1,2,6)xpSTAT3"),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC%>%mean, col='red')
  
  ## Hi. Suppress T-reg x Act.Prolif + Hi.Suppress  is non-CSR.
  rr<- sapply(permList,function(x) x[which(x$zone%in%c("Hi.Suppress.T-reg(1,2,6)xpSTAT3","Hi.Suppress.T-reg(1,2,6)xAct./Prolif.T-reg(5)xpSTAT3")),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC)
  colMeans(rr)%>%density%>%plot(main="M2-MAC in Hi.Supp.T-reg pSTAT3+ zone 1 (p=0.078)")
  abline(v=test[which(test$zone%in%c("Hi.Suppress.T-reg(1,2,6)xpSTAT3","Hi.Suppress.T-reg(1,2,6)xAct./Prolif.T-reg(5)xpSTAT3")),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC%>%mean,col='red')
   obs<-test[which(test$zone%in%c("Hi.Suppress.T-reg(1,2,6)xpSTAT3","Hi.Suppress.T-reg(1,2,6)xAct./Prolif.T-reg(5)xpSTAT3")),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC
   null<- colMeans(rr)
   table(mean(obs)<null)
  
  
  ## baseline is very bad
  rr<- sapply(permList,function(x) x[which(x$zone%in%c("Hi.Suppress.T-reg(1,2,6)xpSTAT3","Hi.Suppress.T-reg(1,2,6)xBaseline T-reg(3,4)xpSTAT3")),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC)
  colMeans(rr)%>%density%>%plot(main="M2-MAC in Hi.Supp.T-reg pSTAT3+ zone")
  abline(v=test[which(test$zone%in%c("Hi.Suppress.T-reg(1,2,6)xpSTAT3","Hi.Suppress.T-reg(1,2,6)xBaseline T-reg(3,4)xpSTAT3")),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC%>%mean,col='red')
    ###
  ## triple interesction is very bad.
    rr<- sapply(permList,function(x) x[which(x$zone%in%c("Hi.Suppress.T-reg(1,2,6)xpSTAT3","Hi.Suppress.T-reg(1,2,6)xBaseline T-reg(3,4)xAct./Prolif.T-reg(5)xpSTAT3")),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC)
  colMeans(rr)%>%density%>%plot(main="M2-MAC in Hi.Supp.T-reg pSTAT3+ zone")
  abline(v=test[which(test$zone%in%c("Hi.Suppress.T-reg(1,2,6)xpSTAT3","Hi.Suppress.T-reg(1,2,6)xBaseline T-reg(3,4)xAct./Prolif.T-reg(5)xpSTAT3")),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC%>%mean,col='red')
  

#### final CSR testing
   #zone 1:  Hi.Supp T-reg x pstat3,   Hi.Suppress. T-reg, Act./Prolif. Treg x pSTAT3 
  ## zone 2: Hi Supp, Baseline x pstat3,   Hi Supp, Baseline x Act./Prolif x pstat3   (more CSR with baseline t-reg regions)
  ### M2 non-CSR regions.
par(mfrow=c(3,2))  
  
  zone1<-c("Hi.Suppress.T-reg(1,2,6)xpSTAT3","Hi.Suppress.T-reg(1,2,6)xAct./Prolif.T-reg(5)xpSTAT3")
   rr<- sapply(permList,function(x) x[which(x$zone%in% zone1),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC)
  colMeans(rr)%>%density%>%plot(main="M2-MAC in Hi.Supp.T-reg pSTAT3+ zone 1 (p=0.078)")
  abline(v=test[which(test$zone%in% zone1),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC%>%mean,col='red')
   obs<-test[which(test$zone%in% zone1),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC
   null<- colMeans(rr)
   table(mean(obs)<null)
  
  ## CSR regions (zone 2)
   zone2<-c("Hi.Suppress.T-reg(1,2,6)xBaseline T-reg(3,4)xpSTAT3","Hi.Suppress.T-reg(1,2,6)xBaseline T-reg(3,4)xAct./Prolif.T-reg(5)xpSTAT3")
    rr<- sapply(permList,function(x) x[which(x$zone%in% zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC)
   sapply(rr,mean)[!is.nan(sapply(rr,mean))]%>%density%>%plot(main="M2-MAC in Hi.Supp.T-reg pSTAT3+ zone 2")
  abline(v=test[which(test$zone%in% zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC%>%mean,col='red')
  
  
  #### 
  ## PDL1 M2  zone 1
   rr3<-sapply(permList,function(x) x[which(x$zone%in%zone1 ),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(PD.L1.M2.MAC.2.))%$%M2MAC)
  density(colMeans(rr2))%>%plot(main="PDL1+M2-MAC in Hi.Supp.T-reg pSTAT3+ zone 1")
 # abline(v=test[which(test$zone%in%zone1),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(PD.L1.M2.MAC.2.))%$%M2MAC%>%mean, col='red')
   abline(v=0.00055,col='red')
  
  
  ## PDL1 M2 zone 2
  rr4<- sapply(permList,function(x) x[which(x$zone%in%zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(PD.L1.M2.MAC.2.))%$%M2MAC)
  sapply(rr4,mean)[!is.nan(sapply(rr4,mean))]%>%density%>%plot(main="PDL1+M2-MAC in Hi.Supp.T-reg pSTAT3+ zone 2 (p=0.057)")
  abline(v=test[which(test$zone%in%zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(PD.L1.M2.MAC.2.))%$%M2MAC%>%mean,col='red')
   obs<-test[which(test$zone%in% zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(PD.L1.M2.MAC.2.))%$%M2MAC
   null<- sapply(rr4,mean)[!is.nan(sapply(rr4,mean))]
   table(mean(obs)<null)
  
  
  ## CD4
  ### act/prolife cd4
  rr5<-sapply(permList,function(x) x[which(x$zone%in%zone1 ),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC)
  density(colMeans(rr5))%>%plot(main="Act./Prolif. CD4 in Hi.Supp.T-reg pSTAT3+ zone 1")
   abline(v=test[which(test$zone%in%zone1),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC%>%mean, col='red')

    rr6<-sapply(permList,function(x) x[which(x$zone%in%zone2 ),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC)
  sapply(rr6,mean)[!is.nan(sapply(rr6,mean))]%>%density%>%plot(main="Act./Prolif. CD4 in Hi.Supp.T-reg pSTAT3+ zone 2 (p=0.042)")
   abline(v=test[which(test$zone%in%zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC%>%mean, col='red')
  obs<-test[which(test$zone%in% zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC
   null<- sapply(rr6,mean)[!is.nan(sapply(rr6,mean))]
   table(mean(obs)>null)
  
   
  ## EXAMINE AREAS OF ZONE 1 ZONE2
   z1.area<-sapply(pstatList,function(x) mean(tile.areas(x$tregzone.pstat3)[names(tile.areas(x$tregzone.pstat3))%in%zone1]))
   z2.area<-sapply(pstatList,function(x) mean(tile.areas(x$tregzone.pstat3)[names(tile.areas(x$tregzone.pstat3))%in%zone2]))
   z2.area[is.nan(z2.area)]<-mean(z2.area[!is.nan(z2.area)])
   z1.area[is.nan(z1.area)]<-mean(z1.area[!is.nan(z1.area)])
   ##more area in Z1 
   data.frame(Z1=z1.area,Z2=z2.area)%>%melt%>%ggplot(aes(x=variable,y=value))+geom_boxplot()

  #### 11-13:  comparing the model to randomized spatial model
  ## we have the random/observed intensities, and we know the regions/zones that does not have CSR
   ## we fit a logistic model based on the expected counts modeled by negative binomial regression.
  ###  using the intensities alone we see the null model.  using the observed intensities as features we do not see a relation with logistic.  can we consider a count model?  
   
#### we gather the data counts for specific phenotypes that had linear differences identified from a NB model. 
   ## we fit a logistic model for each feature, and gather all the ORs estimates.  we compare the observed to randomized effects.
### create a randomized model to compare the effects for these specific regions.
   # features interested:  M2-MAC (homog. zone), all Exh./Inflam, prolif CD4, prolif CD8.

      
  ## observed model.
     subExpr$response.bin<-ifelse(subExpr$response=="Primary refract",1,0)
     myl<-subExpr
     myl$response.bin<-ifelse(myl$response=="Primary refract",1,0)

## for M2-MACs we fixed the zone to ignore the heterogeneous zones.
     ## from CSR testing in baseline regions, and triple intersection had CSR so we ignore these points.
   myl[which(myl$zone == c("Hi.Suppress.T-reg(1,2,6)xBaseline T-reg(3,4)xpSTAT3")),"M2.MAC.1.5.6."] <- NA 
     
    myl[which(myl$zone == c("Hi.Suppress.T-reg(1,2,6)xBaseline T-reg(3,4)xAct./Prolif.T-reg(5)xpSTAT3")),"M2.MAC.1.5.6."] <- NA     
    myl$zonalRegion<-"zone1"
    myl$zonalRegion[myl$zone%in%zone1]<-"zone1"
    myl$zonalRegion[myl$zone%in%zone2]<-"zone2"
    
## prediction LASSO################
    library(glmnet)
    test$response.bin<-ifelse(test$response=="Primary refract",1,0)
    test$zonalRegion<-myl$zonalRegion
    test$time<-clinic2$os_d[match(test$ROIID,clinic2$sample_id)]
    test$status<-clinic2$status[match(test$ROIID,clinic2$sample_id)]

    x<-test[,c(1:23,34)]%>%group_by(ROIID,zonalRegion)%>%summarise_all(mean)%>%data.frame()
    x$response<-subExpr$response[match(x$ROIID,subExpr$ROIID)]
    x$highIPI<-subExpr$highIPI[match(x$ROIID,subExpr$ROIID)]
    x$highIPI<-ifelse(x$highIPI=="HighIPI",1,0)
    #x$time<-clinic2$os_d[match(x$ROIID,clinic2$sample_id)]
    #x$status<-clinic2$status[match(x$ROIID,clinic2$sample_id)]

    x<-x[which(x$zonalRegion=="zone1"),]
    y<-ifelse(x$response=="Primary refract",1,0)
     #tt<-x[,c("time","status")]
     #x<-x[,c(3:24,26)]%>%as.matrix
    x<-x[,grepl("CD4",colnames(x)) | grepl("MAC",colnames(x))  | grepl("CD8",colnames(x)) | grepl("highIPI",colnames(x))]
    
    lambdas <- 10^seq(3, -2, by = -.1)
    cvfit <- cv.glmnet(as.matrix(x), y, family = "binomial", type.measure = "class",nfolds=3,alpha=0.85)
    plot(cvfit)
    coef(cvfit)
    
## Cox    
   fit <- cv.glmnet(x, as.matrix(tt), family = "cox",nfolds=3,alpha=0.5)
    plot(fit)
    coef(fit)
    
#############################    
### the lasso picked out similar phenotypes
    # Terminal exhaust, M2.MAC, Act.Prolif CD4, PDL1+M2
    
  ## pooling/summarize the effects to reduce over-fitting.
    myl$M2.Summary<-(myl$M2.MAC.1.5.6.-myl$PD.L1.M2.MAC.2.)/2
    myl$T.Summary<-(myl$Act..Prolif.CD4.6.+myl$Terminal.Exhaust.CD8.3.5.)/2

 
  ## LASSO showed Terminal Exh 8, M2 , PDL1+M2,  Act./Prolif CD4 
   
  zone1.glm<-glm(response.bin~M2.MAC.1.5.6.+Act..Prolif.CD4.6.+PD.L1.M2.MAC.2.+Terminal.Exhaust.CD8.3.5.+highIPI,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')%>%summary
  zone2.glm<-glm(response.bin~Terminal.Exhaust.CD8.3.5.+Act..Prolif.CD4.6.+PD.L1.M2.MAC.2.+highIPI,data=myl[which(myl$zonalRegion=="zone2"),],family='binomial')%>%summary
  ##zone 1 summary model.
    zone1.summary.glm<-glm(response.bin~M2.Summary+T.Summary+highIPI,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')%>%summary


   
 obsCount<-myl%>%group_by(ROIID)%>%summarise(M2=mean(M2.MAC.1.5.6.),
                                         ActCD4=mean(Act..Prolif.CD4.6.),
                                         TermCD8=mean(Terminal.Exhaust.CD8.3.5.),
                                         PDL1M2=mean(PD.L1.M2.MAC.2.)
                                         )%>%data.frame   
obsCount$highIPI<-myl$highIPI[match(obsCount$ROIID,myl$ROIID)]
obsCount$response.bin<-myl$response.bin[match(obsCount$ROIID,myl$ROIID)]

  load("~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/masks-lists-zones/permList_450.RData")

   orList<-list()
   for(i in 1:length(permList)){
     rmyl<-permList[[i]]
     rmyl[,1:22]<-round(rmyl[,1:22]*10000)
     rmyl$response.bin<-ifelse(rmyl$response=="Primary refract",1,0)
 
    rmyl$M2.Summary<-(rmyl$M2.MAC.1.5.6.-rmyl$PD.L1.M2.MAC.2.)/2
    rmyl$T.Summary<-(rmyl$Act..Prolif.CD4.6.+rmyl$Terminal.Exhaust.CD8.3.5.)/2

  rCount<-myl%>%group_by(ROIID)%>%summarise(M2=mean(M2.MAC.1.5.6.),
                                         ActCD4=mean(Act..Prolif.CD4.6.),
                                         TermCD8=mean(Terminal.Exhaust.CD8.3.5.),
                                          PDL1M2=mean(PD.L1.M2.MAC.2.)
                                         )%>%data.frame   
  rCount$highIPI<-rmyl$highIPI[match(rCount$ROIID,rmyl$ROIID)]
  rCount$response.bin<-rmyl$response.bin[match(rCount$ROIID,rmyl$ROIID)]
  
  #rfit<-glm(response.bin~M2+ExhCD4+ActCD8+highIPI,data=rCount,family='binomial')
  #rfit<-glm(response.bin~M2.MAC.1.5.6.+PD.L1.M2.MAC.2.+Act..Prolif.CD4.6.+highIPI+zone,data=myl,family='binomial')%>%summary
  #rfit<-glm(response.bin~M2+PDL1M2+ActCD4+highIPI,data=rCount,family='binomial')%>%summary
   rfit<-glm(response.bin~M2.Summary+T.Summary+highIPI,data=rmyl[which(myl$zonalRegion=="zone1"),],family='binomial')%>%summary

  ## store the model.
  orList[[length(orList)+1]]<-coef(rfit)
   }
     
  oFit<-glm(response.bin~M2.Summary+T.Summary+highIPI,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')%>%summary

  par(mfrow=c(4,2)) 
  density(sapply(orList,function(x) x["M2.Summary","Estimate"])[which(sapply(orList,function(x) x["M2.Summary","Estimate"])<20)])%>%plot(main="Random M2-MAC log-odds for REF")
  abline(v=coef(oFit)[2,1],col='red')
  
  
  density(sapply(orList,function(x) x[3,1]))%>%plot(main="Random PDL1+M2 log-odds for REF")
  abline(v=coef(oFit)[3,1],col='red')   
 density(sapply(orList,function(x) x[4,1]))%>%plot(main="Random PDL1+M2 log-odds for REF")
  abline(v=coef(oFit)[4,1],col='red')  
  
  
  
##### final table for Inference using LASSO selections. #####
   library(sjPlot)
  ## number of ophenotypes to correct
  lengthTests<-which(grepl("CD4",allPhenos) | grepl("CD8",allPhenos) | grepl("MAC",allPhenos))%>%length
  
  zone1.summary.glm<-glm(response.bin~M2.Summary+T.Summary+highIPI,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')
   zone1.glm<-glm(response.bin~M2.MAC.1.5.6.+Act..Prolif.CD4.6.+PD.L1.M2.MAC.2.+Terminal.Exhaust.CD8.3.5.+highIPI,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')
#  zone2.glm<-glm(response.bin~+Act..Prolif.CD4.6.+PD.L1.M2.MAC.2.+Terminal.Exhaust.CD8.3.5.+highIPI,data=myl[which(myl$zonalRegion=="zone2"),],family='binomial')

  
  tab_model(zone1.glm,zone1.summary.glm,
  pred.labels = c("Intercept", 
                  "M2-MAC","Act./Prolif. CD4","PD-L1+M2-MAC","Terminal. exhausted CD8",
                  "High IPI(>3)",
                  "(M2-MAC - PDL1+M2-MAC)/2",
                  "(Act./Prolif. CD4 + Terminal exhausted CD8)/2"
                  
                    ),
  dv.labels = c("LASSO model (zone 1)", "Summary model (zone 1)"),
  string.pred = "Primary refractory predictors",
  string.ci = "Conf. Int (95%)",
  string.p = "P-Value",
  show.aic=TRUE,
    file="~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-figure-revision/zone-analysis/lassoModel/temp.html"
)

## heatmap of the zones.
 # Heatmap(myl[,c("M2.MAC.1.5.6.","PD.L1.M2.MAC.2.","Act..Prolif.CD4.6.","Terminal.Exhaust.CD8.3.5.")])
  
  
  
######################################################################
######################################################################  
  zoneEx<-myl
  zoneRowAnn<-HeatmapAnnotation(REF=myl[,c("response")],which="row")
  zrowAnn2<-HeatmapAnnotation(zone=myl[,c("zonalRegion")],which="row")

  Heatmap(myl[,c("M2.MAC.1.5.6.","PD.L1.M2.MAC.2.","Act..Prolif.CD4.6.","Terminal.Exhaust.CD8.3.5.")],show_row_names=FALSE)
          
###########################################################################
  ###########################################################################
  
  
### Prediction model conditioned on CSR and LASSO
## REVISION 11-21:  Term Exh8,  Act/Prolif CD4,  PDL1+MAC, M2-MAC was selected from LASSO
  
   library(caret)
 
  cats<-myl[which(myl$zonalRegion=="zone1"),]%>%group_by(ROIID)%>%summarise(M2=mean(M2.MAC.1.5.6.),
                                         ActCD4=mean(Act..Prolif.CD4.6.),
                                         TermCD8=mean(Terminal.Exhaust.CD8.3.5.),
                                         PDL1M2=mean(PD.L1.M2.MAC.2.)
                                         )%>%data.frame   
 cats$highIPI<-myl$highIPI[match(cats$ROIID,myl$ROIID)]
 cats$response.bin<-myl$response.bin[match(cats$ROIID,myl$ROIID)]
 cats$M2Summary<-c(cats$M2-cats$PDL1M2)/2
 cats$TSummary<-c(cats$ActCD4-cats$TermCD8)/2

  
   library(caret)
     # balanced folding 
  # folds.cr <- createFolds(cats$ROIID[which(cats$response.bin==0)], k =3, list = TRUE, returnTrain = FALSE)
  # folds.cr<-lapply(folds.cr,function(x) cats$ROIID[which(cats$response.bin==0)][x]  )
  # folds.ref <- createFolds(cats$ROIID[which(cats$response.bin==1)], k =3, list = TRUE, returnTrain = FALSE) 
  # folds.ref<-lapply(folds.ref,function(x)cats$ROIID[which(cats$response.bin==1)][x])
  #  while( any(sapply(folds.ref,length)==1)){
   #    folds.ref <- createFolds(cats$ROIID[which(cats$response.bin==1)], k =3, list = TRUE, returnTrain = FALSE) 
   #folds.ref<-lapply(folds.ref,function(x)cats$ROIID[which(cats$response.bin==1)][x])
  #  }
  # while( any(sapply(folds.cr,length)==1)){
   #   folds.cr <- createFolds(cats$ROIID[which(cats$response.bin==0)], k =3, list = TRUE, returnTrain = FALSE)
  # folds.cr<-lapply(folds.cr,function(x) cats$ROIID[which(cats$response.bin==0)][x]  )
   # }

 ### just need to iterate the LOO validation
## 

 final.valres<-list()
 final.valipi<-list()
 final.vals<-list()
  for(f in 1:500){ 
   folds<- createFolds(cats$ROIID, k =3, list = TRUE, returnTrain = FALSE)
   folds<-lapply(folds,function(x) cats$ROIID[x]  )
   
 valres.ac<-NULL
  ipires.ac<-NULL
   sres.ac<-NULL

 for(k in 1:3){
  # inTrain<-as.character(c(folds.cr[-k]%>%unlist,folds.ref[-k]%>%unlist))
  # inTest<-as.character(c(folds.cr[k]%>%unlist,folds.ref[k]%>%unlist))
   inTrain<-as.character(folds[-k]%>%unlist)
  inTest<-as.character(c(folds[k]%>%unlist))
   training <- cats[match(inTrain,cats$ROIID),]
   testing <- cats[match(inTest,cats$ROIID),]
  ## fit the model on training data
   cats.fit<-glm(response.bin~M2+PDL1M2+ActCD4+TermCD8,data=training,family='binomial')
  ipi.fit<-glm(response.bin~highIPI,family="binomial",data=training)
  summFit<-glm(response.bin~M2Summary+TSummary,data=training,family='binomial')
   summary(cats.fit)
    
  ## predict using testing (LOO) 
  cats.prob = predict(cats.fit, testing, type="response")
  cats.pred = rep("CR", dim(testing)[1])
  cats.pred[cats.prob > .5] = "Primary refractory"
## confusion matrix
table(cats.pred, testing$response.bin)
## average accuracy
  valres.ac<-c(valres.ac,mean(cats.pred == ifelse(testing$response.bin==1,"Primary refractory","CR")))
 ## IPI prediction
  
  ## predict using testing (LOO) 
  ipi.prob = predict(ipi.fit, testing, type="response")
  ipi.pred = rep("CR", dim(testing)[1])
  ipi.pred[ipi.prob > .5] = "Primary refractory"
## confusion matrix
table(ipi.pred, testing$response.bin)
## average accuracy
  ipires.ac<-c(ipires.ac,mean(ipi.pred == ifelse(testing$response.bin==1,"Primary refractory","CR")))

  s.prob = predict(summFit, testing, type="response")
  s.pred = rep("CR", dim(testing)[1])
  s.pred[s.prob > .5] = "Primary refractory"
## confusion matrix
table(s.pred, testing$response.bin)
## average accuracy
  sres.ac<-c(sres.ac,mean(s.pred == ifelse(testing$response.bin==1,"Primary refractory","CR")))


}
 final.valres[[length(final.valres)+1]]<-valres.ac
 final.valipi[[length(final.valipi)+1]]<-ipires.ac
  final.vals[[length(final.vals)+1]]<-sres.ac

  }
 
 grandVal<-sapply(final.valres,mean)
 IPIVal<-sapply(final.valipi,mean)
 SumVal<-sapply(final.vals,mean)

 cv<-data.frame(CV=c(mean(grandVal),mean(IPIVal),mean(SumVal)),
                SE=c(sd(grandVal)/sqrt(3),sd(IPIVal)/sqrt(3) , sd(SumVal)/sqrt(3)),
               feature=c("LASSO model","IPI", "Summary model"),
              stringsAsFactors = T)
 cv$lower<-cv$CV-1.96*cv$SE
 cv$upper<-cv$CV+1.96*cv$SE
 cv$feature<-factor(cv$feature,levels=c("IPI","Summary model","LASSO model"))
  ggplot(cv,aes(x=feature,y=CV))+geom_bar(stat='identity',width=0.5)+geom_errorbar(aes(ymin=lower,ymax=upper),width=0.2)+ylab("Treatment refractory prediction accuracy (3-fold-CV)")+xlab("Treatment refractory predictor")+theme_ipsum(base_size = 14,axis_title_size=15)+
    theme(axis.text=element_text(color="black"))
        

 ##binary

cats.fit<-glm(response.bin~M2+PDL1M2+highIPI,data=cats,family='binomial')
 cats.fit<-glm(response.bin~M2Summary+TSummary,data=cats,family='binomial')
  library(jtools)
  #effect_plot(cats.fit, pred = m2pred, interval = TRUE, y.label = "% resistance to therapy")
  m2eff<-effect_plot(cats.fit, pred = m2pred, interval = TRUE, y.label = "Probability of treatment refractory")+xlab("M2-MAC(1,5,6)")+theme(axis.text=element_text(color="black",size=15))
  cd4eff<-effect_plot(cats.fit, pred = exhpred, interval = TRUE, y.label = "Probability of treatment refractory")+xlab("Exh./Inflam CD4(1,5)")+theme(axis.text=element_text(color="black",size=15))
  # ipieff<-effect_plot(cats.fit, pred = HighIPI, interval = TRUE, y.label = "Probability of treatment refractory")+xlab("High-IPI(>3)")+theme(axis.text=element_text(color="black",size=15))

   ## accuracy measures  (bar plot with 95% CI)
 cats.prob = predict(cats.fit, cats, type="response")
cats.pred = rep("CR", dim(cats)[1])
cats.pred[cats.prob > .5] = "Primary refractory"

  example <- confusionMatrix(data= factor(cats.pred), reference = factor(ifelse(cats$response.bin==1,"Primary refractory","CR")))

   fourfoldplot(example$table, color = c("darkgrey", "pink"),
             conf.level = 0, margin = 1, main = "Confusion Matrix")
 spats<-example$overall
  
#### IPI model
   
    ipi.fit<-glm(response.bin~highIPI,family="binomial",data=cats)
 cats.prob = predict(ipi.fit, cats, type="response")
cats.pred = rep("CR", dim(cats)[1])
cats.pred[cats.prob > .5] = "Primary refractory"

  example2<-confusionMatrix(data= factor(cats.pred), reference = factor(ifelse(cats$response.bin==1,"Primary refractory","CR")))
  ipis<-example2$overall
   
  cv<-data.frame(Accuracy=c(spats[1],ipis[1]),lower=c(spats[3],ipis[3]),upper=c(spats[4],ipis[4]),feature=c("M2-MAC,Exh./Inflam CD4","High IPI(>3)"))
  
   ggplot(cv,aes(x=feature,y=Accuracy))+geom_bar(stat='identity',width=0.5)+geom_errorbar(aes(ymin=lower,ymax=upper),width=0.2)+ylab("Prediction accuracy (3-fold-CV)")+xlab("Treatment refractory predictor")+theme_ipsum()+theme(axis.text=element_text(color="black",size=10)) 
                                                                                                                           
                                                                                      
###################################################
  ################################################
  
  
  
### validating with NND
# inflamtum  exhCD8,  PDL1M2,  Prolif Endo had associations with IPI , need to validate via NND.
      
  load("~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/hyperframe/HtregPstat.RData")
  allPhenos2<-with(HtregPstat,unique(marks(point)))%>%unlist%>%unique
   ## global Kinhom
  
    
  ### REVISION 11-17  we have different phenotypes in the model, M2-MAC, PDL1M2 MAc, and act/prolif CD4 
   
#### if  desparate validate using NND   
  k<-(with(HtregPstat,length(which(marks(point)=="Hi.Suppress.T-reg(1,2,6)_pSTAT3+"))))
  k2<-(with(HtregPstat,length(which(marks(point)=="Act./Prolif.CD4(6)"))))
  names(k)<-names(k2)<-HtregPstat$ROI  
  H<-HtregPstat[which(k>20&k2>20),]
    nnD<-NULL
     for(roi in H$ROI){
       myp<-(H$point[[which(H$ROI==roi)]])
        spl<-split(myp)
        x<-spl[["Hi.Suppress.T-reg(1,2,6)_pSTAT3+"]]
        y<-spl[["Act./Prolif.CD4(6)"]]
      if(!is.null(x) & !is.null(y)){  
        nnd<-nncross(x,y)
        nnd<-data.frame(nnd,ROI=roi,response=H$treatment[which(H$ROI==roi)])
        if(is.null(nnD)){
          nnD<-nnd
        }else{
          nnD<-rbind(nnD,nnd)
        }
       
      }  
     }  
    
  lm(dist~response,nnD[which(nnD$dist<100),])%>%summary  
   ggplot(nnD[which(nnD$dist<100),],aes(x=response,y=dist))+geom_boxplot()+ggpubr::stat_compare_means(method='t.test')

   
 a<-ggplot(nnD[which(nnD$dist<100),],aes(x=response,y=dist))+geom_boxplot()+ggpubr::stat_compare_means(method='t.test')+theme_ipsum()+ylab("Hi.Suppress.T-reg(1,2,6):pSTAT3+ NND Act./Prolif.CD4(6) (microns)")+theme(axis.text=element_text(color="black"))

 ## patient avg.  does not detect differences.
  nnD.avg<-nnD[which(nnD$dist<100),]%>%group_by(ROI,response)%>%summarise(NND=mean(dist))%>%data.frame
  lm(NND~response,nnD.avg)%>%summary
  
  k<-(with(HtregPstat,length(which(marks(point)=="Hi.Suppress.T-reg(1,2,6)_pSTAT3+"))))
  k2<-(with(HtregPstat,length(which(marks(point)=="M2-MAC(1,5,6)"))))
  names(k)<-names(k2)<-HtregPstat$ROI  
  H<-HtregPstat[which(k>20&k2>20),]
  nnD<-NULL
     for(roi in H$ROI){
       myp<-(HtregPstat$point[[which(H$ROI==roi)]])
        spl<-split(myp)
        x<-spl[["Hi.Suppress.T-reg(1,2,6)_pSTAT3+"]]
        y<-spl[["M2-MAC(1,5,6)"]]
      if(!is.null(x) & !is.null(y)){  
        nnd<-nncross(x,y)
        nnd<-data.frame(nnd,ROI=roi,response=HtregPstat$treatment[which(H$ROI==roi)])
        if(is.null(nnD)){
          nnD<-nnd
        }else{
          nnD<-rbind(nnD,nnd)
        }
       
      }  
     }  
    
  lm(dist~HighIPI+response,nnD[which(nnD$dist<100),])%>%summary  

b<-ggplot(nnD[which(nnD$dist<100),],aes(x=response,y=dist))+geom_boxplot()+ggpubr::stat_compare_means(method='t.test')+theme_ipsum()+ylab("Hi.Suppress.T-reg(1,2,6):pSTAT3+ NND M2-MAC (microns)")+theme(axis.text=element_text(color="black"))
 
### PDL1+M2MAC
  
  k<-(with(HtregPstat,length(which(marks(point)=="Hi.Suppress.T-reg(1,2,6)_pSTAT3+"))))
  k2<-(with(HtregPstat,length(which(marks(point)=="PD-L1+M2-MAC(2)"))))
  names(k)<-names(k2)<-HtregPstat$ROI  
  H<-HtregPstat[which(k>20&k2>20),]
  nnD<-NULL
     for(roi in H$ROI){
       myp<-(HtregPstat$point[[which(H$ROI==roi)]])
        spl<-split(myp)
        x<-spl[["Hi.Suppress.T-reg(1,2,6)_pSTAT3+"]]
        y<-spl[["PD-L1+M2-MAC(2)"]]
      if(!is.null(x) & !is.null(y)){  
        nnd<-nncross(x,y)
        nnd<-data.frame(nnd,ROI=roi,response=HtregPstat$treatment[which(H$ROI==roi)])
        if(is.null(nnD)){
          nnD<-nnd
        }else{
          nnD<-rbind(nnD,nnd)
        }
       
      }  
     }  
    
  lm(dist~response,nnD[which(nnD$dist<200),])%>%summary  

  c<-ggplot(nnD[which(nnD$dist<200),],aes(x=response,y=dist))+geom_boxplot()+ggpubr::stat_compare_means(method='t.test')+theme_ipsum()+ylab("Hi.Suppress.T-reg(1,2,6):pSTAT3+ NND PD-L1+M2-MAC(2) (microns)")+theme(axis.text=element_text(color="black"))
 

   grid.arrange(a,c,b,nrow=1,ncol=3)

  
 ############################################################## 
  
  
  
### survival prediction equatoin from the final model.
  #### seeing if the counts of M2/CD8/CD4 ameloriate the hazards estimate
  ## results: using a cox model we see that HiSup_pstat3 is hazardous, and including the count frequencies predicted by the model,the predicted CD4/CD8/M2 using all clinical features, it shows a protective trend.  i don't know how to interpret this. not significantly.   not including.
  # zone1.glm<-glm(response.bin~M2.MAC.1.5.6.+Act..Prolif.CD4.6.+PD.L1.M2.MAC.2.+highIPI,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')
  # zone1.glm<-glm(response.bin~M2.MAC.1.5.6.+Act..Prolif.CD4.6.+Terminal.Exhaust.CD8.3.5.+Act..Prolif.CD8.1.4.+M1.MAC.3.4.+PD.L1.M2.MAC.2.,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')
 #glm(response.bin~M2.MAC.1.5.6.+Act..Prolif.CD4.6.+Terminal.Exhaust.CD8.3.5.+Act..Prolif.CD8.1.4.+M1.MAC.3.4.+PD.L1.M2.MAC.2.,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')%>%summary
   ## best prediction model.
   
   ### best survival prediction
   par(mfrow=c(5,2),mar=c(2,2,2,2))  
  
  zone1<-c("Hi.Suppress.T-reg(1,2,6)xpSTAT3","Hi.Suppress.T-reg(1,2,6)xAct./Prolif.T-reg(5)xpSTAT3")
   rr<- sapply(permList,function(x) x[which(x$zone%in% zone1),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC)
  colMeans(rr)%>%density%>%plot(main="M2-MAC in Hi.Supp.T-reg pSTAT3+ zone 1 (p=0.078)")
  abline(v=test[which(test$zone%in% zone1),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC%>%mean,col='red')
   obs<-test[which(test$zone%in% zone1),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC
   null<- colMeans(rr)
   table(mean(obs)<null)
  
  ## CSR regions (zone 2)
   zone2<-c("Hi.Suppress.T-reg(1,2,6)xBaseline T-reg(3,4)xpSTAT3","Hi.Suppress.T-reg(1,2,6)xBaseline T-reg(3,4)xAct./Prolif.T-reg(5)xpSTAT3")
    rr<- sapply(permList,function(x) x[which(x$zone%in% zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC)
   sapply(rr,mean)[!is.nan(sapply(rr,mean))]%>%density%>%plot(main="M2-MAC in Hi.Supp.T-reg pSTAT3+ zone 2 (p>0.05)")
  abline(v=test[which(test$zone%in% zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(M2.MAC.1.5.6.))%$%M2MAC%>%mean,col='red')
  
  
  #### 
  ## PDL1 M2  zone 1
   rr3<-sapply(permList,function(x) x[which(x$zone%in%zone1 ),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(PD.L1.M2.MAC.2.))%$%M2MAC)
  density(colMeans(rr3))%>%plot(main="PDL1+M2-MAC in Hi.Supp.T-reg pSTAT3+ zone 1 (p<0.01)")
 # abline(v=test[which(test$zone%in%zone1),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(PD.L1.M2.MAC.2.))%$%M2MAC%>%mean, col='red')
   abline(v=0.0002,col='red')
  
  
  ## PDL1 M2 zone 2
  rr4<- sapply(permList,function(x) x[which(x$zone%in%zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(PD.L1.M2.MAC.2.))%$%M2MAC)
  sapply(rr4,mean)[!is.nan(sapply(rr4,mean))]%>%density%>%plot(main="PDL1+M2-MAC in Hi.Supp.T-reg pSTAT3+ zone 2 (p=0.057)")
  abline(v=test[which(test$zone%in%zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(PD.L1.M2.MAC.2.))%$%M2MAC%>%mean,col='red')
   obs<-test[which(test$zone%in% zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(PD.L1.M2.MAC.2.))%$%M2MAC
   null<- sapply(rr4,mean)[!is.nan(sapply(rr4,mean))]
   table(mean(obs)<null)
  
  
  ## CD4
  ### act/prolife cd4
  rr5<-sapply(permList,function(x) x[which(x$zone%in%zone1 ),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC)
  density(colMeans(rr5))%>%plot(main="Act./Prolif. CD4 in Hi.Supp.T-reg pSTAT3+ zone 1 (p<0.01)")
   abline(v=test[which(test$zone%in%zone1),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC%>%mean, col='red')

    rr6<-sapply(permList,function(x) x[which(x$zone%in%zone2 ),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC)
  sapply(rr6,mean)[!is.nan(sapply(rr6,mean))]%>%density%>%plot(main="Act./Prolif. CD4 in Hi.Supp.T-reg pSTAT3+ zone 2 (p=0.042)")
   abline(v=test[which(test$zone%in%zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC%>%mean, col='red')
  obs<-test[which(test$zone%in% zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD4.6.))%$%M2MAC
   null<- sapply(rr6,mean)[!is.nan(sapply(rr6,mean))]
   table(mean(obs)>null)
  
   ## CD8
    rr7<-sapply(permList,function(x) x[which(x$zone%in%zone1 ),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Terminal.Exhaust.CD8.3.5.))%$%M2MAC)
  density(colMeans(rr7))%>%plot(main="Terminal exhausted CD8 in Hi.Supp.T-reg pSTAT3+ zone 1 (p>0.05)")
   abline(v=test[which(test$zone%in%zone1),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Terminal.Exhaust.CD8.3.5.))%$%M2MAC%>%mean, col='red')

    rr8<-sapply(permList,function(x) x[which(x$zone%in%zone2 ),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Terminal.Exhaust.CD8.3.5.))%$%M2MAC)
  sapply(rr8,mean)[!is.nan(sapply(rr8,mean))]%>%density%>%plot(main="Terminal exhausted CD8 in Hi.Supp.T-reg pSTAT3+ zone 2 (p=0.042)")
   abline(v=test[which(test$zone%in%zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Terminal.Exhaust.CD8.3.5.))%$%M2MAC%>%mean, col='red')
  obs<-test[which(test$zone%in% zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Terminal.Exhaust.CD8.3.5.))%$%M2MAC
   null<- sapply(rr8,mean)[!is.nan(sapply(rr8,mean))]
   table(mean(obs)>null)
   
  #  rr9<-sapply(permList,function(x) x[which(x$zone%in%zone1 ),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD8.1.4.))%$%M2MAC)
  #density(colMeans(rr9))%>%plot(main="Act./Prolif. CD8 in Hi.Supp.T-reg pSTAT3+ zone 1 (p<0.01)")
  # abline(v=test[which(test$zone%in%zone1),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD8.1.4.))%$%M2MAC%>%mean, col='red')

   # rr10<-sapply(permList,function(x) x[which(x$zone%in%zone2 ),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD8.1.4.))%$%M2MAC)
 # sapply(rr10,mean)[!is.nan(sapply(rr10,mean))]%>%density%>%plot(main="Act./Prolif. CD8 in Hi.Supp.T-reg pSTAT3+ zone 2 (p=0.038)")
# abline(v=test[which(test$zone%in%zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD8.1.4.))%$%M2MAC%>%mean, col='red')
 # obs<-test[which(test$zone%in% zone2),]%>%group_by(ROIID)%>%summarise(M2MAC=mean(Act..Prolif.CD8.1.4.))%$%M2MAC
#   null<- sapply(rr10,mean)[!is.nan(sapply(rr10,mean))]
 #  table(mean(obs)>null)
   
   
   
   
     zone1.pred<- glm(response.bin~M2.MAC.1.5.6.+Act..Prolif.CD4.6.+Terminal.Exhaust.CD8.3.5.+PD.L1.M2.MAC.2.,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')
      lasso.pred<- glm(response.bin~M2.MAC.1.5.6.+Act..Prolif.CD4.6.+Terminal.Exhaust.CD8.3.5.+PD.L1.M2.MAC.2.,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')
     
  lm(M2.MAC.1.5.6.~Act..Prolif.CD4.6.+Terminal.Exhaust.CD8.3.5.+PD.L1.M2.MAC.2.,data=myl[which(myl$zonalRegion=="zone1"),])%>%summary
 
  myl$M2.Summary<-(myl$M2.MAC.1.5.6.-myl$PD.L1.M2.MAC.2.)/2
    myl$T.Summary<-(myl$Act..Prolif.CD4.6.+myl$Terminal.Exhaust.CD8.3.5.)/2

  ### predictive models to compare
    ipi.pred<- glm(response.bin~highIPI,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial') 
    tme.pred<- glm(response.bin~M2.MAC.1.5.6.+Act..Prolif.CD4.6.+Terminal.Exhaust.CD8.3.5.+PD.L1.M2.MAC.2.,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')  
    Summtme.pred<- glm(response.bin~M2.Summary+T.Summary,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')
    lasso.pred<- glm(response.bin~M2.MAC.1.5.6.+Act..Prolif.CD4.6.+Terminal.Exhaust.CD8.3.5.+PD.L1.M2.MAC.2.+highIPI,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')
 sumlasso.pred<- glm(response.bin~M2.Summary+T.Summary+highIPI,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')
      summary(sumlasso.pred)
      
### comparing 3 models IPI alone,  TME features alone,  Summary features alone      
       myl$IPIprediction<-myl$tmePrediction<-myl$SummtmePrediction<-myl$LassoPrediction<-myl$sumlassoPrediction<-NA
       
  myl$IPIprediction[which(myl$zonalRegion=="zone1")]<-predict(ipi.pred,type="response")
  myl$tmePrediction[which(myl$zonalRegion=="zone1")]<-predict(tme.pred,type="response")
  myl$SummtmePrediction[which(myl$zonalRegion=="zone1")]<-predict(Summtme.pred,type="response")
  myl$LassoPrediction[which(myl$zonalRegion=="zone1")]<-predict(lasso.pred,type="response")
  myl$sumlassoPrediction[which(myl$zonalRegion=="zone1")]<-predict(sumlasso.pred,type="response")
### regular NBin predictions
  ### LOGIT USING PREDICTION SCORES.
  
  
  
  m2pred<-myl[which(myl$zonalRegion=="zone1"),]%>%group_by(ROIID)%>%summarise(IPIPred=mean(IPIprediction),
                                                                              tmePred=mean(tmePrediction),
                                                                              summTMEPred=mean(SummtmePrediction),
                                                                              LassoPred=mean(LassoPrediction),
                                                                              sumlassoPred=mean(sumlassoPrediction)
                                                                              )%>%data.frame
  par(mfrow=c(3,2),mar=c(2,2,2,2))
  density(m2pred$IPIPred)%>%plot(main="IPI prediction refractory risk")
  abline(v=0.4,col='red')
  density(m2pred$tmePred)%>%plot(main="TME prediction refractory risk")
  abline(v=0.4,col='red')
   density(m2pred$summTMEPred)%>%plot(main="Summary of TME prediction refractory risk")
  abline(v=0.4,col='red')
    density(m2pred$LassoPred)%>%plot(main="LASSO prediction refractory risk")
  abline(v=0.4,col='red')
      density(m2pred$sumlassoPred)%>%plot(main="Summarized LASSO prediction refractory risk")
  abline(v=0.4,col='red')


  m2pred$IPIcut<-cut2(m2pred$IPIPred,0.4)
    m2pred$tmeCut<-cut2(m2pred$tmePred,0.4)
    m2pred$SummTMECut<-cut2(m2pred$summTMEPred,0.4)

  m2pred$Lassocut<-cut2(m2pred$LassoPred,0.4)
  m2pred$Summcut<-cut2(m2pred$sumlassoPred,0.4)

  
   cats<-m2pred
   cats$HighIPI<-subExpr$highIPI[match(cats$ROIID,subExpr$ROIID)]
      
      
    clinic2<- metadata(sce)$experiment_info
   clinic2$os_d<-full.dn4$os_d[match(clinic2$sample_id,paste0("ROIID_",full.dn4$ROIID))]
   clinic2$os<-full.dn4$os[match(clinic2$sample_id,paste0("ROIID_",full.dn4$ROIID))]
  clinic2$os_ref<-full.dn4$response[match(clinic2$sample_id,paste0("ROIID_",full.dn4$ROIID))]

### death status  
  clinic2$status<-ifelse(clinic2$os=="event",1,0)
    
## refractory status
      clinic2$refstatus<-ifelse(clinic2$os_ref=="Primary refract",1,0)
  
clinic2$C1f<-factor(clinic2$C1)
clinic2$C2f<-factor(clinic2$C2)
clinic2$C3f<-factor(clinic2$C3)
clinic2$C4f<-factor(clinic2$C4)
clinic2$C5f<-factor(clinic2$C5)
 ## individual hazard plots
c1cx<-coxph(Surv(os_d,status)~C1+highIPI,clinic2)
c2cx<-coxph(Surv(os_d,status)~C2+highIPI,clinic2)
c3cx<-coxph(Surv(os_d,status)~C3+highIPI,clinic2)
c4cx<-coxph(Surv(os_d,status)~C4+highIPI,clinic2)
c5cx<-coxph(Surv(os_d,status)~C5+highIPI,clinic2)

 # subExpr$predict<-predict(final.exh4.nb) 
  #prd<-subExpr%>%group_by(ROIID)%>%summarise(predict=mean(predict),obs=mean(Exh..Inflam.CD4.1.5.))%>%data.frame
   p4<-with(Hpool,length(which(marks(point)$marks=="Act./Prolif. CD4(6)"))/npoints(point))
  names(p4)<-Hpool$ROI[match(names(p4),rownames(Hpool))]

  p5<-with(Hpool,length(which(marks(point)$marks=="M2-MAC(1,5,6)"))/npoints(point))
  names(p5)<-Hpool$ROI[match(names(p5),rownames(Hpool))]

### IPI 
  clinic2$IPIPred<-cats$IPIPred[match(clinic2$sample_id,cats$ROIID)]
   clinic2$IPICut<-cats$IPIcut[match(clinic2$sample_id,cats$ROIID)]
## tme only
    clinic2$tmePred<-cats$tmePred[match(clinic2$sample_id,cats$ROIID)]
   clinic2$tmeCut<-cats$tmeCut[match(clinic2$sample_id,cats$ROIID)]

## summary 
    clinic2$summTMEPred<-cats$summTMEPred[match(clinic2$sample_id,cats$ROIID)]
   clinic2$SummTMECut<-cats$SummTMECut[match(clinic2$sample_id,cats$ROIID)]
   
   ## lasso
    clinic2$LassoPred<-cats$LassoPred[match(clinic2$sample_id,cats$ROIID)]
   clinic2$Lassocut<-cats$Lassocut[match(clinic2$sample_id,cats$ROIID)]
## summary lasso
  clinic2$sumlassoPred<-cats$sumlassoPred[match(clinic2$sample_id,cats$ROIID)]
   clinic2$Summcut<-cats$Summcut[match(clinic2$sample_id,cats$ROIID)]
####
    
  ipicx<-coxph(Surv(os_d,status)~highIPI,clinic2)
   tmecx<-coxph(Surv(os_d,status)~tmeCut+highIPI,clinic2)
    summcx<-coxph(Surv(os_d,status)~SummTMECut+highIPI,clinic2)
  lasscx<- coxph(Surv(os_d,status)~Lassocut,clinic2)
  summlasscx<-coxph(Surv(os_d,status)~Summcut,clinic2)

   ### plot the Cox survival
 
 tab_model(ipicx,tmecx,lasscx,summlasscx,
  pred.labels = c("High IPI(>3)", 
                  "TME risk",
                  "LASSO risk",
                  "Summarized LASSO risk"
                    ),
  dv.labels = c("IPI", "TME", "LASSO", "Summary LASSO"),
  string.pred = "Hazards risk",
  string.ci = "Conf. Int (95%)",
  string.p = "P-Value",
  show.aic=TRUE,
    file="~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-figure-revision/zone-analysis/lassoModel/survtemp.html"
)
  

  # risk.death<- ggplot(cxs,aes(x=(Cox),y=Chapuy,color=Chapuy))+geom_point(size=5)+coord_fixed(ratio=1.25)+scale_x_discrete(limits=0:5)+geom_vline(xintercept=0,color="black",linetype="dashed")+theme_ipsum(axis_text_size=19)+scale_color_manual(values=c("firebrick2","firebrick2"))+geom_errorbar(aes(xmax=upper,xmin=lower),width=0.2)+theme(axis.text=element_text(color="black"),legend.position="none")+xlab("Log hazards rate for death (95% CI)")+ylab("")  
  
#############################################################   
  ####
   ##### final table for Prediction #####
   library(sjPlot)
  ## number of ophenotypes to correct
  lengthTests<-which(grepl("CD4",allPhenos) | grepl("CD8",allPhenos) | grepl("MAC",allPhenos))%>%length
  
 zone1.pred<- glm(response.bin~M2.MAC.1.5.6.+Act..Prolif.CD4.6.+Act..Prolif.CD8.1.4.+Terminal.Exhaust.CD8.3.5.+PD.L1.M2.MAC.2.,data=myl[which(myl$zonalRegion=="zone1"),],family='binomial')  
 zone2.pred<- glm(response.bin~Act..Prolif.CD4.6.+Act..Prolif.CD8.1.4.+Terminal.Exhaust.CD8.3.5.+PD.L1.M2.MAC.2.,data=myl[which(myl$zonalRegion=="zone2"),],family='binomial')
 clinic2$ref.bin<-ifelse(clinic2$group_id=="Primary refract",1,0)
  clinical.pred<- glm(ref.bin~highIPI+NGCB,data=clinic2,family='binomial')
  
  tab_model(zone1.pred,clinical.pred,
  pred.labels = c("Intercept", 
                  "M2-MAC(1,5,6)",
                  "Act./Prolif. CD4(6)",
                  "Act./Prolif. CD8(1,4)",
                  "Terminal exhausted CD8(3,5)",
                  "PD-L1+M2-MAC(2)", 
                  "High IPI (>3)",
                  "Non-GCB"
                    ),
  dv.labels = c("Zone 1 risk","Clinical risk"),
  string.pred = "Primary refractory",
  string.ci = "Conf. Int (95%)",
  string.p = "P-Value",
  show.aic=TRUE,
    file="~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-figure-revision/zone-analysis/prediction-model/prediction.html"
)

  
  #### NND for prediction
  
  ### REVISION 11-17  we have different phenotypes in the model, M2-MAC, PDL1M2 MAc, and act/prolif CD4 
   
#### if  desparate validate using NND   
  k<-(with(HtregPstat,length(which(marks(point)=="Hi.Suppress.T-reg(1,2,6)_pSTAT3+"))))
  k2<-(with(HtregPstat,length(which(marks(point)=="Act./Prolif.CD8(1,4)"))))
  names(k)<-names(k2)<-HtregPstat$ROI  
  H<-HtregPstat[which(k>20&k2>20),]
    nnD<-NULL
     for(roi in H$ROI){
       myp<-(H$point[[which(H$ROI==roi)]])
        spl<-split(myp)
        x<-spl[["Hi.Suppress.T-reg(1,2,6)_pSTAT3+"]]
        y<-spl[["Act./Prolif.CD8(1,4)"]]
      if(!is.null(x) & !is.null(y)){  
        nnd<-nncross(x,y)
        nnd<-data.frame(nnd,ROI=roi,response=H$treatment[which(H$ROI==roi)])
        if(is.null(nnD)){
          nnD<-nnd
        }else{
          nnD<-rbind(nnD,nnd)
        }
       
      }  
     }  
    
  lm(dist~response,nnD[which(nnD$dist<100),])%>%summary  
   ggplot(nnD[which(nnD$dist<100),],aes(x=response,y=dist))+geom_boxplot()+ggpubr::stat_compare_means(method='t.test')

   
 a<-ggplot(nnD[which(nnD$dist<100),],aes(x=response,y=dist))+geom_boxplot()+ggpubr::stat_compare_means(method='t.test')+theme_ipsum(axis_text_size = 16)+ylab("Hi.Suppress.T-reg(1,2,6):pSTAT3+ NND Act./Prolif.CD8(1,4) (microns)")+theme(axis.text=element_text(color="black"))

 ## patient avg.  does not detect differences.
  nnD.avg<-nnD[which(nnD$dist<100),]%>%group_by(ROI,response)%>%summarise(NND=mean(dist))%>%data.frame
  lm(NND~response,nnD.avg)%>%summary
  
  k<-(with(HtregPstat,length(which(marks(point)=="Hi.Suppress.T-reg(1,2,6)_pSTAT3+"))))
  k2<-(with(HtregPstat,length(which(marks(point)=="M2-MAC(1,5,6)"))))
  names(k)<-names(k2)<-HtregPstat$ROI  
  H<-HtregPstat[which(k>20&k2>20),]
  nnD<-NULL
     for(roi in H$ROI){
       myp<-(HtregPstat$point[[which(H$ROI==roi)]])
        spl<-split(myp)
        x<-spl[["Hi.Suppress.T-reg(1,2,6)_pSTAT3+"]]
        y<-spl[["M2-MAC(1,5,6)"]]
      if(!is.null(x) & !is.null(y)){  
        nnd<-nncross(x,y)
        nnd<-data.frame(nnd,ROI=roi,response=HtregPstat$treatment[which(H$ROI==roi)])
        if(is.null(nnD)){
          nnD<-nnd
        }else{
          nnD<-rbind(nnD,nnd)
        }
       
      }  
     }  
    
  lm(dist~HighIPI+response,nnD[which(nnD$dist<100),])%>%summary  

b<-ggplot(nnD[which(nnD$dist<100),],aes(x=response,y=dist))+geom_boxplot()+ggpubr::stat_compare_means(method='t.test')+theme_ipsum(axis_text_size = 15)+ylab("Hi.Suppress.T-reg(1,2,6):pSTAT3+ NND M2-MAC (microns)")+theme(axis.text=element_text(color="black"))
 
### PDL1+M2MAC
  
 

   grid.arrange(a,b,nrow=1,ncol=3)

  
   
   
  
  
  
###############################################################  
   
   

   ## KM plotting
     Z<-list()
  Z$HighIPI<-data.frame(HighIPI=clinic2[,c("highIPI")],row.names=clinic2$sample_id)
  Z$tmePred<-data.frame(Prediction=clinic2[,c("tmePred")],row.names=clinic2$sample_id)
    Z$summTMEPred<-data.frame(Prediction=clinic2[,c("summTMEPred")],row.names=clinic2$sample_id)
  Z$LassoPred<-data.frame(Prediction=clinic2[,c("LassoPred")],row.names=clinic2$sample_id)
  Z$sumlassoPred<-data.frame(Prediction=clinic2[,c("sumlassoPred")],row.names=clinic2$sample_id)

   Z$highIPI.TME<-cbind(Z$HighIPI,Z$tmePred)
      Z$highIPI.Summ<-cbind(Z$HighIPI,Z$summTMEPred)

  titl<-c("High IPI (>3)",
          "TME",
          "Summary TME",
          "LASSO",
          "Summary LASSO")
          
  
 library(car);library(Hmisc)
  S<-Surv(clinic2$os_d,ifelse(clinic2$os=="event",1,0))
  set.seed(42)
  concordanceCV = data.frame()
  cv_ix = sample(1:3, 38, replace=TRUE)
  for(i in unique(cv_ix)){
    c = lapply(Z, function(x) ecoxph(data.frame(x[cv_ix!=i,]), S[cv_ix!=i] ))
    p = mapply(function(x,y) as.matrix(x[cv_ix==i,]) %*% coef(y), Z, c)
    concordanceCV = rbind(concordanceCV, apply(-p,2, rcorr.cens, S[cv_ix==i])[1,])
  }
  colnames(concordanceCV) = names(Z)
  colMeans(concordanceCV)

  
  ### concordance CV
  cind<-data.frame(Cindex=colMeans(concordanceCV),feature=c("High IPI(>3)","Prediction risk score","High IPI(>3), Prediction risk score"))
  cind$SE<-colSds(as.matrix(concordanceCV))/5
  cind$upper<-cind$Cindex+1.96*cind$SE
  cind$lower<-cind$Cindex-1.96*cind$SE
  cind$feature<-factor(cind$feature,levels=c("Prediction risk score","High IPI(>3)","High IPI(>3), Prediction risk score")
   )
    ggplot(cind,aes(x=feature,y=Cindex))+geom_bar(stat='identity',width=0.5)+geom_errorbar(aes(ymin=lower,ymax=upper),width=0.2)+ylab("Harrell's c-index (3-fold-CV)")+xlab("Survival predictor")+theme_ipsum(axis_text_size=18)+theme(axis.text=element_text(color="black",size=10)) 
        
    
  
  
  set1 = c(brewer.pal(9,"Set1"), brewer.pal(8, "Dark2"))
  
  par(bty="n",mfrow=c(3,3), mgp = c(1.9,.33,0), mar=c(2.3,9,2,2.1)+.1, las=1, tcl=-.25)
 j <- 0
 for(ii in 1:length(names(Z))){
      j <- j +1

   x<-Z[[ii]]
    c = sapply(1:3, function(i) coef(ecoxph(data.frame(x[cv_ix!=i,]),S[cv_ix!=i])))
  if(is.null(nrow(c))==FALSE){
    r = as.matrix(x) %*% rowMeans(c) 
  }else{
  r = as.matrix(x) %*% mean(c) 
  }
   r[is.na(r),1]<-mean(r[!is.na(r)]) 
  
 # plot(survfit(S ~ cut(r, quantile(r+runif(length(r), -0.01,0.01), seq(0,1,l=4), na.rm=TRUE), right=FALSE)), col = set1[2:1], xlab="", ylab="Overall survival",mark.time=TRUE)
    #grp<-ifelse(r[,1]>median(r[,1]),2,1)
    grp<-as.numeric(kmeans(r,2)$cluster)
    if(ii<2){
      grp<-ifelse(r[,1]>median(r[,1]),2,1)
    plot(survfit(S~grp),col=set1[2:1],xlab="",ylab="Overall survival",mark.time=T, main=titl[j])
   pv<-round(coef(summary(coxph(S~grp)))[,5],2)
    }else if(ii>1){
        plot(survfit(S~grp),col=set1[1:2],xlab="",ylab="Overall survival",mark.time=T, main=titl[j])
   pv<-round(coef(summary(coxph(S~grp)))[,5],2)
      
    }
   title(xlab="Days", line=1.5)
    #mtext(capitalize(titl[j]), font=1, at=40, side=3, line=0.5)
    par(xpd=TRUE)
    legend(x=2000, y=1.2, bty="n", "Risk", cex=0.9, text.font=2) 
    legend(x=2000, y=1.1, bty="n", text.col = set1[2:1], c("Low","High"), cex=0.9)
   
   text(x=0, y=0.05, paste("C =", round(colMeans(concordanceCV)[j],2)), cex=1, pos=4)
   text(x=500, y=0.05, paste("p =", pv), cex=1, pos=4)

  #readkey()
}
   
############################ synthetic images
 ##look at cox model for specific features, do not pool.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 ########################################################
 
 
 
######################################33333333333333333333
## Zero inflated predicted
##M2 macs predicted
 subExpr$predict<-predict(finalm2)
 prd<-subExpr%>%group_by(ROIID)%>%summarise(predict=mean(predict),obs=mean(M2.MAC.1.5.6.))%>%data.frame
 
 ##predicting cd4
 subExpr$predict4<-predict(final4)
  prd4<-subExpr%>%group_by(ROIID)%>%summarise(predict=mean(predict4))%>%data.frame

  
  ##predicting cd8s
  subExpr$predict8<-predict(final8)
  prd8<-subExpr%>%group_by(ROIID)%>%summarise(predict=mean(predict8))%>%data.frame
 
 ##overall OS trends
  m2<-with(Hpool,length(which(marks(point)$marks=="M2-MAC(1,5,6)"))/npoints(point))
  p8<-with(Hpool,length(which(marks(point)$marks=="Exh./Inflam.CD8(2,6)"))/npoints(point))
  p4<-with(Hpool,length(which(marks(point)$marks=="Act./Early/Exh.CD4(2,3,7)"))/npoints(point))
 
     p4<-with(Hpool,length(which(marks(point)$marks=="Act./Early/Exh.CD4(2,3,7)"))/npoints(point))

  names(m2)<-Hpool$ROI[match(names(m2),rownames(Hpool))]
  names(p8)<-Hpool$ROI[match(names(p8),rownames(Hpool))]
  names(p4)<-Hpool$ROI[match(names(p4),rownames(Hpool))]
 

   allD<-as.data.frame(matrix(NA,nrow=nrow(Hpool),ncol=length(allPhenos)))
 colnames(allD)<-allPhenos
 allD$ROI<-Hpool$ROI
 allD$pSTAT3<-NA
 allD$Ki67<-NA
  for( roi in Hpool$ROI){
   myr<-Hpool$point[[which(Hpool$ROI==roi)]]
   prd<-split(myr,factor(marks(myr)$marks))
   his<-prd[[which(names(prd)=="Hi.Suppress.T-reg(1,2,6)")]]
   pstat3<-marks(his)$pSTAT3
   ki<-marks(his)$Ki67
   allD[which(allD$ROI==roi),"pSTAT3"]<-mean(pstat3)
   allD[which(allD$ROI==roi),"Ki67"]<-mean(ki)
 }
      hisp<-with(Hpool,100*length(which(marks(point)$marks=="Hi.Suppress.T-reg(1,2,6)"))/npoints(point))
  names(hisp)<-Hpool$ROI
  
   act<-with(Hpool,100*length(which(marks(point)$marks=="Act./Prolif.T-reg(5)"))/npoints(point))
  names(act)<-Hpool$ROI
  bt<-with(Hpool,100*length(which(marks(point)$marks=="Baseline T-reg(3,4)"))/npoints(point))
  names(bt)<-Hpool$ROI
  
  
  clinic2$HiSup<-hisp[match(clinic2$sample_id,names(hisp))]
  clinic2$pstat3<-allD$pSTAT3[match(clinic2$sample_id,names(hisp))]
  clinic2$Ki67<-allD$Ki67[match(clinic2$sample_id,names(hisp))]

  clinic2$act<-act[match(clinic2$sample_id,names(act))]
  clinic2$bt<-bt[match(clinic2$sample_id,names(bt))]
  clinic2$HiSup_pstat3<-clinic2$HiSup*clinic2$pstat3
  clinic2$HiSup_Ki67<-clinic2$HiSup*clinic2$Ki67

  
    clinic2$M2.abund<-m2[match(clinic2$sample_id,names(m2))]
 clinic2$CD8.abund<-p8[match(clinic2$sample_id,names(p8))]
 clinic2$CD4.abund<-p4[match(clinic2$sample_id,names(p4))]
 

 clinic2$M2.hot<-cut2(prd$predict[match(clinic2$sample_id,prd$ROIID)],2)
 clinic2$CD4.hot<-cut2(prd4$predict[match(clinic2$sample_id,prd4$ROIID)],2)
 clinic2$CD8.hot<-cut2(prd8$predict[match(clinic2$sample_id,prd8$ROIID)],2)

 clinic2$M2.t<-(prd$predict[match(clinic2$sample_id,prd$ROIID)])
 clinic2$CD4.t<-(prd4$predict[match(clinic2$sample_id,prd4$ROIID)])
 clinic2$CD8.t<-(prd8$predict[match(clinic2$sample_id,prd8$ROIID)])

 coxph(Surv(os_d,status)~act+bt+HiSup_pstat3+highIPI,clinic2)

coxph(Surv(os_d,status)~act+bt+HiSup_pstat3+highIPI+M2.t+CD4.t+CD8.t,clinic2)


   coxph(Surv(os_d,status)~M2.abund+CD8.abund+CD4.abund+highIPI,clinic2)
      coxph(Surv(os_d,status)~M2.hot+CD4.hot+CD8.hot+highIPI,clinic2)

  coxph(Surv(os_d,status)~HiSup_pstat3+M2.t+CD4.t+CD8.t+highIPI,clinic2)
  
  
   sink("~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-figure-revision/zeroInflatedNB/m2.multivar.txt");summary(final);sink()

```

### Revised and simplified LASSO comparing Hi.Suppress T-reg (pSTAT3+) and Baseline T-reg
```{r}
# T-reg with continuous marks
 ## we create a mask based on phenotypes only, some of the pSTAT3 raw images are not ideal. 
 load("~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/hyperframe/Hpool_continuousMarks.RData")
 
  # need to identify Hi.Supp T-reg : pSTAT3+ phenotypes by tertile gating (or median gating) ? 
 for(i in Hpool$ROI){
   mypp<-Hpool$point[[which(Hpool$ROI==i)]]
   mks<-marks(mypp)
   mks$new_marks<-as.character(mks$marks)
   mks$new_marks[which(mks$pSTAT3>quantile(mks$pSTAT3,0.5) & mks$marks=="Hi.Suppress.T-reg(1,2,6)")]<-"Hi.Suppress.T-reg:pSTAT3+"
   mks$marks<-factor(mks$new_marks)
   marks(mypp)<-mks
   Hpool$point[[which(Hpool$ROI==i)]]<-mypp
 }
 
 ## create zones for Baseline T-reg  and Hi.Supp.Treg:pstat3+ 
 
 H<-Hpool
 
pstatList<-list()
  for(ROI in H$ROI){
    print(ROI)
 roi_4193<-H$point[[which(H$ROI==ROI)]]
 #allppp<-split(roi_4193)
 allppp<-split(roi_4193,factor(marks(roi_4193)$marks))
 phenos<-names(allppp)
  flag1<-(table(marks(roi_4193)$marks)["Hi.Suppress.T-reg:pSTAT3+"]>20)
    flag2<-(table(marks(roi_4193)$marks)["Baseline T-reg(3,4)"]>20)
     if(is.na(flag2)){
       flag2<-FALSE
     }
    if(is.na(flag1)){
      flag1<-FALSE
    }
  if(flag1){
## suppressive : pstat3+  
  cd4_4V<-tessellatePoints(H,ROI=ROI,phenotypeToTess = "Hi.Suppress.T-reg:pSTAT3+")
  }else{
    cd4_4V<-"none"
  }
 if(flag2){
 ## baseline 
 cd4_b<-tessellatePoints(H,ROI=ROI,phenotypeToTess = "Baseline T-reg(3,4)" )
 }else{
   cd4_b<-"none"
 }
   roi_4193<-H$point[[which(H$ROI==ROI)]]
  mps<-roi_4193
  marks(mps)<-marks(mps)$marks
  
  if(flag1){
cd4Int<-countIntensityPhenotypePerArea(tcell.im=cd4_4V$image,
                                  allppp=mps)
  }else{
    cd4Int<-"none"
  }
  if(flag2){
    cd4base<-countIntensityPhenotypePerArea(tcell.im=cd4_b$image,
                                  allppp=mps)
  }else{
    cd4base<-"none"
  }
     
   
      
 
##rename levels of TREG mask.
 roi<-list(    
              ppp=roi_4193,
              suppTreg=cd4_4V,
              baseTreg=cd4_b,
              suppTregInt=cd4Int,
              baseTregInt=cd4base
              )

    pstatList[[(length(pstatList)+1)]]<-roi
   }##ROI list 
 


    names(pstatList)<-H$ROI
    
## gather intensity in either region per Hi.Suppress  /  Baseline
    
      ## spatial zone counting.
    allz<-c( "Hi.Suppress.T-reg:pSTAT3+" ,"Baseline T-reg(3,4)")
    
    
    poolPheno<- with(Hpool,unique(marks(point)$marks))%>%unlist%>%unique()%>%as.character
    zones<-as.data.frame(matrix(0, nrow=nrow(H)*2,ncol=length(poolPheno)))
    colnames(zones)<-poolPheno
    zones$ROIID<-rep(H$ROI,each=length(allz))
    zones$zone<-rep(allz,nrow(H))
    
  ## gather the intensity. 
    
 for(i in names(pstatList)){
   mask1<-pstatList[[i]]$suppTregInt
   mask2<-pstatList[[i]]$baseTregInt
   myp<-pstatList[[i]]$ppp
   
   if(mask1!="none"){
  zones[which(zones$ROIID==i& zones$zone=="Hi.Suppress.T-reg:pSTAT3+"),match(colnames(mask1),colnames(zones))]<-mask1["Hi.Suppress.T-reg:pSTAT3+",]
   }
   if(mask2!="none"){
  zones[which(zones$ROIID==i& zones$zone=="Baseline T-reg(3,4)"),match(colnames(mask2),colnames(zones))]<-mask2["Baseline T-reg(3,4)",]
   }
  
 }# for loop  
    
     
 ## prediction LASSO################
    library(glmnet)
    zones$response<-metadata(sce)$experiment_info[match(zones$ROIID,metadata(sce)$experiment_info$sample_id),"group_id"]
    zones$response.bin<-ifelse(zones$response=="Primary refract",1,0)
       zones$highIPI<-metadata(sce)$experiment_info[match(zones$ROIID,metadata(sce)$experiment_info$sample_id),"highIPI"]

    
    hip<-zones[which(zones$zone=="Hi.Suppress.T-reg:pSTAT3+"),]
   # hip<-hip[which(hip[,"Hi.Suppress.T-reg(1,2,6)"]>0), ]
    
    btp<-zones[which(zones$zone!="Hi.Suppress.T-reg:pSTAT3+"),]
   # btp<-btp[which(btp[,"Baseline T-reg(3,4)"]>0), ]

    x<-hip[,c(1:23,24,28)]%>%group_by(ROIID)%>%summarise_all(mean)%>%data.frame()
    x<-x[,-1]

    
    y<-hip$response.bin
    
    #x<-x[,grepl("CD4",colnames(x)) | grepl("MAC",colnames(x))  | grepl("CD8",colnames(x)) | grepl("highIPI",colnames(x))]
    
    lambdas <- 10^seq(3, -2, by = -.1)
    cvfit <- cv.glmnet(as.matrix(x)*10000, y, family = "binomial", type.measure = "class",nfolds=3,alpha=0.85)
    plot(cvfit)
    coef(cvfit)
    


```

## Plotting figure of zones
```{r}
 roi<-"ROIID_4047"
  regions<-pstatList[[roi]]$tregzone.pstat3
 levels(regions$image)<-c("empty",
                           "pSTAT3+",
                           "Act./Prolif.T-reg(5)",
                           "Act./Prolif.T-reg(5)",
                           "Baseline T-reg(3,4)",
                           "Baseline T-reg(3,4)",
                          "Baseline T-reg, Act./Prolif T-reg",
                          "Zone 2",
                          "empty",
                          "Zone 1",
                          "empty",
                          "Zone 1",
                          "Zone 2",
                          "Zone 2",
                           "empty","Zone 2")
  spl<-split(pstatList[[roi]]$ppp,factor(marks(pstatList[[roi]]$ppp)$marks))
 plot(regions, main="ROI 4047 (REF)")
 points(spl[["PD-L1+M2-MAC(2)"]],pch=20,col='red')
  points(spl[["Act./Prolif.CD4(6)"]],pch=20,col='green')
  points(spl[["M2-MAC(1,5,6)"]],pch=20)

  
### CR  
  roi<-"ROIID_4061"
  regions<-pstatList[[roi]]$tregzone.pstat3
    spl<-split(pstatList[[roi]]$ppp,factor(marks(pstatList[[roi]]$ppp)$marks))
 levels(regions$image)<-c("empty",
                           "pSTAT3+",
                           "Act./Prolif.T-reg(5)",
                           "Act./Prolif.T-reg(5)",
                           "Baseline T-reg(3,4)",
                           "Baseline T-reg(3,4)",
                          "Baseline T-reg, Act./Prolif T-reg",
                          "Baseline T-reg, Act./Prolif T-reg",
                          "empty",
                          "Zone 1",
                          "Hi.Suppress T-reg, Act./Prolif. T-reg",
                          "Zone 1",
                          "empty",
                          "Zone 2",
                           "empty","Zone 2")
 plot(regions, main="ROI 4185 (CR)")
 points(spl[["PD-L1+M2-MAC(2)"]],pch=20,col='red')
  points(spl[["Act./Prolif.CD4(6)"]],pch=20,col='green')
  points(spl[["M2-MAC(1,5,6)"]],pch=20) 
 
 
```

### Null distribution permuting the labels.
- for each ROI we randomize all the labels, and reconstruct zone counts to store.
- tried without window groups and observed null.  10-11: added 2x2 group to see improve
- 10-21: use the threshold of 5
- REVISION 11-1: need to source the helper functions from the Kinhom script file.
```{r}
 library(spatstat)
 library(magrittr)
 library(imcExperiment)

 load("~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/masks-lists-zones/pstatList.RData")
 load("~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/hyperframe/Hpool_continuousMarks.RData")
 load("~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/SCE-data/sce_omitND.RData")
  load("~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/SCE-data/exper_info2.RData")

 
   H<-Hpool[which(Hpool$ROI!="ROIID_3969"),]
### simulate swaps all labels, but fixes the positions.
  rownames(H)<-H$ROI
  numsims<-75
 #simH<-with(H,rlabel(point,nsim=numsims, group=quadrats(Window(point),2,2)))
   simH<-with(H,rlabel(point,nsim=numsims))

  
assemblePermutedHyperframe<-function(simH=NULL,numberSim=1){
   simp<-sapply(simH,function(x) x[numberSim])
   hsim<-hyperframe(simp)
   colnames(hsim)<-"point"
   hsim$ROI<-names(simH)
   hsim$treatment<-H$treatment[match(hsim$ROI,H$ROI)]
   rownames(hsim)<-hsim$ROI
   return(hsim)
}  
  hsim<-assemblePermutedHyperframe(simH=simH,numberSim=1)

all(coords(hsim$point[[1]])==coords(H$point[[1]]))  ##coords match, labeling is perm
 marks(hsim$point[[1]])%>%head
 marks(H$point[[1]])%>%head

 ##perm modelList: stores the model estimates bayesian result
  permModelList<-list()
  zoneList<-list()
  subExprList<-list()
##permute list stores the masks for each iteration.  
  
    for(mysim in 1:numsims){
  ##each ROI in list
      permuteList<-list()
      print(mysim)
  hsim<-assemblePermutedHyperframe(simH=simH,numberSim=mysim)
  
 
  for(ROI in H$ROI){
    print(ROI)
 roi_4193<-hsim$point[[which(hsim$ROI==ROI)]]
 #allppp<-split(roi_4193)
 allppp<-split(roi_4193,factor(marks(roi_4193)$marks))
 phenos<-names(allppp)
  ##CD4/CD8/TREG/MAC/Endo are possible TME.
#cd4.mask<-intensityMask(H,ROI=ROI,tme="CD4")
 #cd4.mask<-intensityMaskContinuousMarks(H=hsim,ROI=ROI,tme="CD4")
 #cd4.im<-cd4.mask$mask.image
 #cd4.tess<-cd4.mask$tess
 #cd4.tess$image<-cd4.im
# cd8.mask<-intensityMask(H,ROI=ROI,tme="CD8")
 #cd8.mask<-intensityMaskContinuousMarks(H=hsim,ROI=ROI,tme="CD8")
 #cd8.im<-cd8.mask$mask.image
 #cd8.tess<-cd8.mask$tess
#  cd8.tess$image<-cd8.im

# treg.mask<-intensityMask(H,ROI=ROI,tme="TREG")
 treg.mask<-intensityMaskContinuousMarks(H=hsim,ROI=ROI,tme="TREG",cutoff=5)

   treg.tess<-treg.mask$tess
  treg.im<-treg.mask$mask.image
  treg.tess$image<-treg.im
##rename levels of TREG mask.
  
  #  mac.mask<-intensityMask(H,ROI=ROI,tme="MAC")
 #  mac.mask<-intensityMaskContinuousMarks(H=hsim,ROI=ROI,tme="MAC")
#   mac.tess<-mac.mask$tess
 #  mac.im<-mac.mask$mask.image
#   mac.tess$image<-mac.mask$mask.image
   
   
 ## protein pSTAT3 masks.
   test<-roi_4193
   marks(test)<-marks(test)[,c("pSTAT3")]
  ##create a mask based on expression.
  #elv<-expr.im$pSTAT3
  elv<-Smooth(test)
  b<-quantile(elv,probs=(0:5)/5,type=2)
  Zcut<-cut(elv,breaks=b,labels=c(0,0,0,0,"pSTAT3"))
  pstat3mask<-tess(image=Zcut)
  
  # test<-roi_4193
  # marks(test)<-marks(test)[,c("Lag3")]
  #create a mask based on expression.
#  elv<-Smooth(test)
 # b<-quantile(elv,probs=(0:5)/5,type=2)
  #Zcut<-cut(elv,breaks=b,labels=c(0,0,0,0,"Lag3"))
  #lag3mask<-tess(image=Zcut)
   
  
  ##treg zone pSTAT3 overlap
  treg.pstat3<-intersect.tess(treg.im,pstat3mask)
  
  ##treg zone Lag3 overlap
  # treg.lag3<-intersect.tess(treg.im,lag3mask)

roi<-list(    #cd4.zone=cd4.mask$zone,
              #cd8.zone=cd8.mask$zone,
              #treg.zone=treg.mask$zone,
              #mac.zone=mac.mask$zone,
              ppp=roi_4193,
              #cd4=cd4.im,
              #cd8=cd8.im,
              #mac=mac.im,
              treg=treg.im,
              pSTAT3Global=pstat3mask,
             # Lag3Global=lag3mask,
              tregzone.pstat3=treg.pstat3
              #tregzone.lag3=treg.lag3
              )

    permuteList[[(length(permuteList)+1)]]<-roi
   }##ROI list 
  ##for each simulation, the entire 37 ROIs are masked (simulated masked)
  ## we save the simulation mask for down stream analysis.
    names(permuteList)<-hsim$ROI
       save(permuteList,file=paste0("~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/masks-lists-zones/permutations/","permutList_batch5_",mysim,"_masks.RData"))
    } ###simulation.
  
``` 

### Zone intensity association survival analysis
```{r}


ecoxph <- function(X, surv, tol=1e-3, max.iter=50){
    if(class(X)=="data.frame")
        X = as.matrix(X)
    beta0 = rep(0,ncol(X))
    beta1 = rep(1,ncol(X))
    sigma2 = 1
    iter = 1
    while(max(abs(beta1-beta0))>tol& iter < max.iter){
        fit = coxph(surv ~ ridge(X, theta=1/sigma2, scale=FALSE))
        sigma2 = (1 + sum((fit$coefficients-mean(fit$coefficients))^2))/(ncol(X))   
        beta0 = beta1
        beta1 = fit$coefficients
        #cat(beta1,"\n")
        #cat(sigma,"\n")
        iter = iter+1
    }
    fit$sigma2 = sigma2
    names(fit$coefficients) = colnames(X)
    return(fit)
}

 readkey<-function () 
{
    cat("Press [enter] to continue")
    line <- readline()
}



 ## Z list for High IPI,  NGCB,  tumor intensity,  exhausted CD4
  ## abundances
   hisp<-with(Hpool,100*length(which(marks(point)$marks=="Hi.Suppress.T-reg(1,2,6)"))/npoints(point))
  names(hisp)<-Hpool$ROI
  exh<-with(Hpool,100*length(which(marks(point)$marks=="Exh./Inflam.CD4(1,5)"))/npoints(point))
  names(exh)<-Hpool$ROI
  nt<-with(Hpool,100*length(which(marks(point)$marks=="Non-Inflam. B-Cell tumor(1-5,7-9)"))/npoints(point))
  names(nt)<-Hpool$ROI
 
   clinic2$ExhCD4.abund<-exh[match(clinic2$sample_id,names(exh))]
    clinic2$Tumor.abund<-nt[match(clinic2$sample_id,names(nt))]

  ### tuned survival
  Z<-list()
  Z$HighIPI<-data.frame(HighIPI=clinic2[,c("highIPI")],row.names=clinic2$sample_id)
  Z$exhCD4<-data.frame(ExhCD4=clinic2[,c("exhCD4")],row.names=clinic2$sample_id)
  Z$nonTum<-data.frame(nonTum=clinic2[,c("nonTum")],row.names=clinic2$sample_id)
  Z$exhCD4[is.na( Z$exhCD4)]<-mean(Z$exhCD4[!is.na(Z$exhCD4)])
  Z$nonTum[is.na(Z$nonTum)]<-mean(Z$nonTum[!is.na(Z$nonTum)])
  
  Z$Exh.Abund<-data.frame(HighIPI=clinic2[,c("ExhCD4.abund")],row.names=clinic2$sample_id)
  Z$Tum.Abund<-data.frame(HighIPI=clinic2[,c("Tumor.abund")],row.names=clinic2$sample_id)

  Z$highIPI.exhCD4<-cbind(Z$HighIPI,Z$exhCD4)
  Z$highIPI.nonTum<-cbind(Z$HighIPI,Z$nonTum)
  Z$highIPI.CD4Abund<-cbind(Z$HighIPI,Z$Exh.Abund)
  Z$highIPI.nonTumAbund<-cbind(Z$HighIPI,Z$Tum.Abund)

  titl<-c("High IPI (>3)","Exh./Inflam.CD4/ T-reg zone","Non-Inflam. B-Cell tumor/ T-reg zone",
          "Exh./Inflam.CD4 abundance",
          "Non-Inflam. B-Cell tumor abundance",
          "High IPI, Exh./Inflam.CD4/ T-reg zone",
          "High IPI, Non-Inflam. B-Cell tumor/ T-reg zone",
          "High IPI, Exh./Inflam.CD4 abundance",
          "High IPI,Non-Inflam. B-Cell tumor abundance")
  
 library(car);library(Hmisc)
  S<-Surv(clinic2$os_d,ifelse(clinic2$os=="event",1,0))
  set.seed(42)
  concordanceCV = data.frame()
  cv_ix = sample(1:3, 38, replace=TRUE)
  for(i in unique(cv_ix)){
    c = lapply(Z, function(x) ecoxph(data.frame(x[cv_ix!=i,]), S[cv_ix!=i] ))
    p = mapply(function(x,y) as.matrix(x[cv_ix==i,]) %*% coef(y), Z, c)
    concordanceCV = rbind(concordanceCV, apply(-p,2, rcorr.cens, S[cv_ix==i])[1,])
  }
  colnames(concordanceCV) = names(Z)
  colMeans(concordanceCV)

  
  set1 = c(brewer.pal(9,"Set1"), brewer.pal(8, "Dark2"))
  
  par(bty="n",mfrow=c(3,3), mgp = c(1.9,.33,0), mar=c(2.3,9,2,2.1)+.1, las=1, tcl=-.25)
 j <- 0
 for(ii in 1:length(names(Z))){
      j <- j +1

   x<-Z[[ii]]
    c = sapply(1:3, function(i) coef(ecoxph(data.frame(x[cv_ix!=i,]),S[cv_ix!=i])))
  if(is.null(nrow(c))==FALSE){
    r = as.matrix(x) %*% rowMeans(c) 
  }else{
  r = as.matrix(x) %*% mean(c) 
  }
    
  
 # plot(survfit(S ~ cut(r, quantile(r+runif(length(r), -0.01,0.01), seq(0,1,l=4), na.rm=TRUE), right=FALSE)), col = set1[2:1], xlab="", ylab="Overall survival",mark.time=TRUE)
    grp<-ifelse(r[,1]>median(r),2,1)
    #grp<-as.numeric(kmeans(r,2)$cluster)
    plot(survfit(S~grp),col=set1[2:1],xlab="",ylab="Overall survival",mark.time=T, main=titl[j])
   pv<-round(coef(summary(coxph(S~as.numeric(kmeans(r,2)$cluster))))[,5],2)
   
   title(xlab="Days", line=1.5)
    #mtext(capitalize(titl[j]), font=1, at=40, side=3, line=0.5)
    par(xpd=TRUE)
    legend(x=2500, y=1.2, bty="n", "Risk", cex=0.9, text.font=2) 
    legend(x=2500, y=1.1, bty="n", text.col = set1[2:1], c("Low","High"), cex=0.9)
   
   text(x=0, y=0.05, paste("C =", round(colMeans(concordanceCV)[j],2)), cex=1, pos=4)
   text(x=500, y=0.05, paste("p =", pv), cex=1, pos=4)

  #readkey()
}

```


### Bar plot with 95% intervals of Good .vs. Band tumor environments comparing REF vs. CR from tumor context
- loads the vito spatial interaction data (p<0.01)
- compares the proportions of significant interactions with tumor (first label) to each cluster (second label)
- produces a barplot with 95% CI.
- 7-24: revision using the 0.01 significance threshold.
- REVISION 9-20: need the t-test values for the comparisons of REF.vs.CR
- REVISION 9-21: figure shows tumor,mac, treg, cd4,cd8 all differenes.
- REVISION 9-22: exclude repulsions for the comparison.
```{r}
 
# load("C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/p1_15_unsup.tumor.15distance.01.RData")

 # load("C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/p1_15_unsup.subcommunity.15distance.01.RData")

  load(file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/p1_15_annotated.label.simple_akil.15distance.01.RData")
  p1$dat_p$treatment<-colData(sce)$group_id[match(paste0("ROIID_",p1$dat_p$group),colData(sce)$sample_id)]

 ##global frequency
 global.pmat<-as.data.frame(p1$pmat)
 global.pmat<-global.pmat[which(rownames(global.pmat)!="Tumor_11"),which(colnames(global.pmat)!="Tumor_11")]
 global.pmat<-100*global.pmat/rowSums(abs(global.pmat))
 #absolute proportion
 rowSums(abs(global.pmat))
 
 ##pool by annotation class.
 rownames(global.pmat)<-full.dn4$annotated.label.back_akil[match(rownames(global.pmat),full.dn4$annotated.label.simple_akil)]
 
 colnames(global.pmat)<-full.dn4$annotated.label.back_akil[match(colnames(global.pmat),full.dn4$annotated.label.simple_akil)]
 
 

   ##compute the T-statistic for each comparing REF/CR using two sample T-test.
   pmat = dcast(p1$dat_p[which(p1$dat_p$treatment=="CR"),], 'FirstLabel ~ SecondLabel', value.var = 'sigval', fun.aggregate = sum,
             fill=0, drop=F)
   rname = pmat$FirstLabel
   pmat<-as.data.table(pmat)
   pmat = pmat[,which(colnames(pmat)!="FirstLabel"),with=FALSE] %>%
    as.data.frame()
row.names(pmat) <- rname
 
 ## compare only the attractions, ignore the repulsions.
 for(i in 1:nrow(pmat)){
   for(j in 1:ncol(pmat)){
     if(pmat[i,j]<0){
       pmat[i,j]<-0
     }
   }
 }

   cr.int<-100*pmat/(0.001+rowSums(abs(pmat)))
   rowSums(abs(cr.int))
  
   pmat2 = dcast(p1$dat_p[which(p1$dat_p$treatment=="Primary refract"),], 'FirstLabel ~ SecondLabel', value.var = 'sigval', fun.aggregate = sum,
             fill=0, drop=F)
   rname = pmat2$FirstLabel
   pmat2<-as.data.table(pmat2)
   pmat2 = pmat2[,which(colnames(pmat2)!="FirstLabel"),with=FALSE] %>%
    as.data.frame()
row.names(pmat2) <- rname

## compare only the attractions, ignore the repulsions.
 for(i in 1:nrow(pmat2)){
   for(j in 1:ncol(pmat2)){
     if(pmat2[i,j]<0){
       pmat2[i,j]<-0
     }
   }
 }

  ref.int<-100*pmat2/(0.001+rowSums(abs(pmat2)))
    ##absolute proportion
     rowSums(abs(ref.int))
  
   avg.ref.tumor<-data.frame(ref=colMeans(ref.int))
  avg.cr.tumor<-data.frame(cr=colMeans(cr.int))

  
   ##from the tumor context embedding 
  tumorEnv<-as.data.frame( t(rbind(ref.int[grepl("Tumor",rownames(ref.int)),],cr.int[grepl("Tumor",rownames(cr.int)),])))

  ## global interaction summary across all
  # tumorEnv<-cbind(avg.ref.tumor,avg.cr.tumor)
  ## here was error, the column names for "tumor" grabbed 2 tumors, so there were 4 columns. not 2.
  #colnames(tumorEnv)<-c("REF","CR")
  tumorEnv$phenotype<-full.dn4$annotated.label.back_akil[match(rownames(tumorEnv),full.dn4$annotated.label.simple_akil)]
  
 
  
interactionProportionStatistic<-function(ref.int,cr.int,tmeCompartment="InflamTumor"){
  reff<-ref.int[which(rownames(ref.int)==tmeCompartment),]
  crr<-cr.int[which(rownames(cr.int)==tmeCompartment),]
   tumorEnv<-as.data.frame( t(rbind(reff,crr)))

  ## global interaction summary across all
  # tumorEnv<-cbind(avg.ref.tumor,avg.cr.tumor)
  colnames(tumorEnv)<-c("REF","CR")
  tumorEnv$phenotype<-full.dn4$annotated.label.back_akil[match(rownames(tumorEnv),full.dn4$annotated.label.simple_akil)]
  
  tumorEnv$diff<-tumorEnv$REF-tumorEnv$CR
  N<-nrow(tumorEnv)
  ##pooled SD
  tumorEnv$pooledSD<-sqrt( ((N-1)*var(abs(tumorEnv$CR))+(N-1)*var(abs(tumorEnv$REF)))/(N+N-2))
  ##pooled standard error of the mean.
# https://sphweb.bumc.bu.edu/otlt/mph-modules/bs/bs704_confidence_intervals/bs704_confidence_intervals5.html
 # t= xbar1-xbar2/SE
  #SE= Sp*sqrt(1/N1+1/N2)
  #Sp= S1^2(N1-1)+S2^2(N2-1)/(N1+N2-2)
  ## x1-x2 +/- t*SE
     S1<-sd(abs(tumorEnv$REF))
  S2<-sd(abs(tumorEnv$CR))
  Varpooled<-(S1^2*(N-1)+S2^2*(N-1))/(N+N-2)
  Spooled<-sqrt(Varpooled)
  totalDF<-(N+N-2)
  standErr<-Spooled*sqrt(1/N+1/N)
 # tumorEnv$pooledError<-unique(tumorEnv$pooledSD)*sqrt(1/N+1/N)
  tumorEnv$pooledError<-standErr
  
  ## REF-CR
  ## statistic  x-y/se(mean)
    tumorEnv$Z<-tumorEnv$diff/unique(tumorEnv$pooledError)
  t.thresh<-  qt(0.025,(N+N-2),lower.tail=FALSE)
  tumorEnv$sig<-"no"
  tumorEnv$sig[which(abs(tumorEnv$Z)>1.96*standErr)]<-'yes'
   tumorEnv$enrich<-"not enriched"
   tumorEnv$enrich[which(tumorEnv$Z>=1.96*standErr)]<-"Primary refractory"
      tumorEnv$enrich[which(tumorEnv$Z<=(-1.96*standErr))]<-"CR"

   tumorEnv[which(tumorEnv$Z==0),"pooledError"]<-0
   ##95% CI.
   tumorEnv$lower.95<-tumorEnv$Z-1.96*tumorEnv$pooledError
     tumorEnv$upper.95<-tumorEnv$Z+1.96*tumorEnv$pooledError
   
   tumorEnv.compare<- ggplot(tumorEnv, aes(x = phenotype , y = Z, fill=enrich, label= ifelse(sig=="yes","*",""))) +
    geom_bar(stat = "identity", position = position_dodge()) +
    ggtitle(paste0("Average embedding proportion ",tmeCompartment)) + ylab("Proportion Sig. Interaction(p<0.01)") + scale_fill_manual(values=getResponderColors())+
    # add 90% CI errorbar 
    geom_errorbar(aes(ymin = Z - 1.96*pooledError, ymax = Z + 1.96*pooledError), width = 0.2, position=position_dodge(0.9))+theme_ipsum(base_family = "Arial")+
    theme(axis.text.x=element_text(colour="black",angle=90,vjust=0.5, hjust=1), axis.text.y=element_text(colour="black"))+geom_text(vjust=0,size=8,nudge_x=(-0.1),nudge_y=(-0.75))+coord_flip()+guides(fill=guide_legend(title="Interaction enrichment"))
  
  
  #plot(tumorEnv.compare)
  return(tumorEnv)
}
  
  
  final<-NULL
  tstat<-as.data.frame( matrix(0,nrow=22,ncol=22))
  rownames(tstat)<-colnames(tstat)<-full.dn4$annotated.label.back_akil[match(rownames(tumorEnv),full.dn4$annotated.label.simple_akil)]%>%unique
  tstat.sig<-tstat
   for(i in rownames(ref.int) ){
  intList<-as.data.frame(matrix(0,nrow=nrow(ref.int),ncol=8))
  rownames(intList)<-1:nrow(intList)
  colnames(intList)<-c("Z","First","Second","lower.95","upper.95","sig","pooledError","enrich")
  macEnv<-interactionProportionStatistic(ref.int,cr.int,tmeCompartment=i)
  intList[,c("Z","lower.95","upper.95","sig","pooledError","enrich")]<-macEnv[,c("Z","lower.95","upper.95","sig","pooledError","enrich")]
  intList$First<-full.dn4$annotated.label.back_akil[match(i,full.dn4$annotated.label.simple_akil)]
  intList$Second<-macEnv$phenotype
  if(is.null(final)){
  final<-intList
  }else if(!is.null(final)){
  final<-rbind(final,intList)
     }
   }
    
   for(i in final$First){  
      for(k in final$Second){
  tstat[i,k]<-final$Z[which(final$First==i & final$Second==k)]
    tstat.sig[i,k]<-ifelse( final$sig[which(final$First==i & final$Second==k)]=='yes',1,0)
   }  
   }
  
   tumorEnv.compare<- ggplot(final, aes(x = Second , y = Z, fill=enrich, label= ifelse(sig=="yes","*",""))) +
    geom_bar(stat = "identity", position = position_dodge()) +
    ggtitle(paste0("Average attraction proportion")) + ylab("Proportion Sig. Interaction(p<0.01)") + scale_fill_manual(values=getResponderColors())+
    # add 90% CI errorbar 
    geom_errorbar(aes(ymin = Z - 1.96*pooledError, ymax = Z + 1.96*pooledError), width = 0.2, position=position_dodge(0.9))+theme_ipsum(base_family = "Arial")+
    theme(axis.text.x=element_text(colour="black",angle=90,vjust=0.5, hjust=1), axis.text.y=element_text(colour="black"))+geom_text(vjust=0,size=8,nudge_x=(-0.1),nudge_y=(-0.75))+guides(fill=guide_legend(title="Interaction enrichment"))+facet_wrap(~First)
  
   tumorEnv.compare
   
  tstat<- tstat[!grepl("none",rownames(tstat)),!grepl("none",rownames(tstat))]
   tstat.sig<- tstat.sig[!grepl("none",rownames(tstat.sig)),!grepl("none",rownames(tstat.sig))]

    ## FIX ME Heatmap with grids and stars.
   
   Heatmap(tstat, name="t-value attraction",
           cell_fun = function(j, i, x, y, w, h, fill) {
    if(tstat.sig[i, j]>=1) {
        grid.text("*", x, y)
   # } else if(mat2[i, j] < 0.01) {
    #    grid.text("**", x, y)
    }
    })
   
   
  write.csv(final,"~/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/final-model-worksheets/Figure2-9-20/tumorEmbedding_attraction.csv")
  
 

```
  
# Spatial Image Exploration
```{r}
  crs<-p1$dat_p[which(p1$dat_p$treatment=="CR"),]
  refs<-p1$dat_p[which(p1$dat_p$treatment=="Primary refract"),]
  
  crs[which(crs$FirstLabel=="EphrinB2_Endothelial" & crs$sig==TRUE),]
  refs[which(refs$FirstLabel=="EphrinB2_Endothelial" & refs$sig==TRUE),]

  ##plot 4047 cartoon
  
  
```

# Plot Cartoons
- ROI 4047 showed interaction with Term Exh CD8 and Non Inflammatory Tumor
```{r}
 load("C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/simpleModel-1-14/final-submission-folder/Box-RData/cartoons/cartoon-shapeFiles/final-shapes/4047_spdf-1-23.validation.RData")

 akilColor2<-getPhenoColorsAnnotatedLabel(full.dn4)

 #  akilColor2["Terminal Exhaust.CD8(3,5)"]<-"#A020F0"
 #  akilColor2["Exh./Inflam.CD8(2,6)"]<-"#C767EF"
#  akilColor2["Baseline T-reg(3,4)"]<-"#3D3D3D"
 # akilColor2["Act./Prolif.T-reg(5)"]<-"#CAE1FF"  
#    akilColor2["Non-Inflam. B-Cell tumor(1-5,7-9)"]<-"#00FF00" 


  akilphenoColors<-data.frame(colors=akilColor2,phenotype=names(akilColor2))
  
  plotShape<-function(path="~/Documents/imageAnalysis/DLBCL/simpleModel-1-14/DLBCL-shape-objects-revised/final-shapes/",ROI="3964",cols=NULL,full.dn4,compartment=NULL,phenotype=NULL,phenotype.column.toShape=NULL){
   sh<-dir(path)
  n<-sh[grepl(ROI,sh)]
  load(paste0(path,n))
  spdf$cellType2<-sapply(strsplit(as.character(spdf$cellType),"_"),function(x) x[1])
  mycase<-full.dn4[which(full.dn4$ROIID==ROI),]
  tumor.id<-mycase$uniqueLabel[which(mycase[,compartment]==phenotype) ]
  spdf$uniqueLabel<-spdf$id
  spdf<-left_join(spdf,mycase[,c("uniqueLabel",phenotype.column.toShape)],by="uniqueLabel")
   spdf$cellType3<-factor(spdf[,phenotype.column.toShape],levels=unique(spdf[,phenotype.column.toShape]))
 test<- ggplot(spdf,aes(x=long,y=lat,group=id,fill=cellType3)) +
      geom_polygon( size=0.1,colour="black") +scale_fill_manual(values=cols[match(levels(spdf$cellType3),cols$phenotype),"colors"])+ggtitle(ROI)+theme_bw()
 
  # print(test)
  return(test)
  }
   ## visually check.
  message(roi)
 path<-"~/IMC-Ranalysis/DLBCL/simpleModel-1-14/final-submission-folder/Box-RData/cartoons/cartoon-shapeFiles/final-shapes/"

  c4192<-plotShape(path=path,
	ROI='4047',
	cols=akilphenoColors,
	full.dn4,
	compartment="phenograph_cluster_meta",
	phenotype="2",
	phenotype.column.toShape="annotated.label.back_akil")
  print(c4192)


 
 
 

```
  
#### cluster level.  
```{r}  
 
 load("C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/p1_15_unsup.tumor.15distance.01.RData")

 p1$dat_p$treatment<-exper_info2$group_id[match(paste0("ROIID_",p1$dat_p$group),exper_info2$sample_id)]
 
  pmat = dcast(p1$dat_p[which(p1$dat_p$treatment=="CR"),], 'FirstLabel ~ SecondLabel', value.var = 'sigval', fun.aggregate = sum,
             fill=0, drop=F)
   rname = pmat$FirstLabel
   pmat<-as.data.table(pmat)
   pmat = pmat[,which(colnames(pmat)!="FirstLabel"),with=FALSE] %>%
    as.data.frame()
row.names(pmat) <- rname
 

 cr.int<-100*pmat/(0.01+rowSums(abs(pmat)))
  
  #rowSds(as.matrix(cr.int))/sqrt(ncol(cr.int))
  ##absolute proportion
   rowSums(abs(cr.int))
  
   pmat = dcast(p1$dat_p[which(p1$dat_p$treatment=="Primary refract"),], 'FirstLabel ~ SecondLabel', value.var = 'sigval', fun.aggregate = sum,
             fill=0, drop=F)
   rname = pmat$FirstLabel
   pmat<-as.data.table(pmat)
   pmat = pmat[,which(colnames(pmat)!="FirstLabel"),with=FALSE] %>%
    as.data.frame()
row.names(pmat) <- rname
  ref.int<-100*pmat/(0.01+rowSums(abs(pmat)))
    ##absolute proportion
     rowSums(abs(ref.int))

 avg.ref.tumor<-data.frame(ref=colMeans(ref.int[grepl("Tumor_",rownames(ref.int)),]))
 avg.cr.tumor<-data.frame(cr=colMeans(cr.int[grepl("Tumor_",rownames(cr.int)),]))

    
#  tumorEnv<-as.data.frame( t(rbind(ref.int[grepl("Tumor",rownames(ref.int)),],cr.int[grepl("Tumor",rownames(cr.int)),])))
 tumorEnv<-cbind(avg.ref.tumor,avg.cr.tumor)
 colnames(tumorEnv)<-c("REF","CR")
  tumorEnv$phenotype<-full.dn4$subcluster_annotated[match(rownames(tumorEnv),full.dn4$unsup.subcommunity)]
  
  tumorEnv$diff<-tumorEnv$REF-tumorEnv$CR
  N<-nrow(tumorEnv)
  ##pooled SD
  tumorEnv$pooledSD<-sqrt( ((N-1)*var(tumorEnv$CR)+(N-1)*var(tumorEnv$REF))/(N+N-2))
  ##pooled standard error of the mean.
  tumorEnv$pooledError<-unique(tumorEnv$pooledSD)*sqrt(1/N+1/N)

    tumorEnv$Z<-tumorEnv$diff/(unique(tumorEnv$pooledSD)*sqrt(1/N+1/N))
  
   tl<-melt(tumorEnv[,c("REF","CR","phenotype")])  
   tl$response<-as.character(tl$variable)
  tl$response[which(tl$response=="REF")]<-"Primary refractory"
  
  tl$error<-unique(tumorEnv$pooledError)
  tl$error[which(tl$value==0)]<-0
  tl$rank<-0
  tl$rank[!grepl("Tumor_",tl$phenotype)]<-rank(abs(tl$value[!grepl("Tumor_",tl$phenotype)])) 
  
  targs<-tl$phenotype[which(tl$rank>=quantile(tl$rank,0.89))]%>%unique
   
  topRank<-tl[which(tl$phenotype%in%targs),]
  topRank<-topRank[order(topRank$rank),]
  topRank$signif<-"no"
  topRank$signif<-ifelse(abs(topRank$value)>=2,"yes","no")
  topRank<-topRank[!topRank$phenotype%in%c("CD4_2(Act./Early/Exh.)", "CD4_5(Exh./Inflam.)"),]
  topRank$signif[which(topRank$phenotype=="CD4_3(Act./Early/Exh.)" & topRank$variable=="REF")]<-"no"

   tumorEnv.compare<- ggplot(topRank, aes(x = phenotype , y = value, fill=response, label= ifelse(signif=="yes","*",""))) +
    geom_bar(stat = "identity", position = position_dodge()) +
    ggtitle("Top ranking tumor spatial interaction frequency") + ylab("Proportion Sig. Interaction(p<0.01)") + scale_fill_manual(values=getResponderColors()[1:2])+
    # add 90% CI errorbar 
    geom_errorbar(aes(ymin = value - 1.96*error, ymax = value + 1.96*error), width = 0.2, position=position_dodge(0.9))+theme_ipsum(base_family = "Arial")+
    theme(axis.text.x=element_text(colour="black",angle=90,vjust=0.5, hjust=1))+geom_text(vjust=0,size=8)
  
  tumorEnv.compare
  
  
 
  
```



### Analysis of spatial interactions and Bar plot of top ranked tumor environment
- REVISION 9-5: computes the average interaction frequency for a given phenotype by treatment response. 
- Generates umap of all spatial interactions
```{r}

 load("C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/p1_15_unsup.subcommunity.15distance.01.RData")
 p1$dat_p$treatment<-exper_info2$group_id[match(paste0("ROIID_",p1$dat_p$group),exper_info2$sample_id)]
 
  pmat = dcast(p1$dat_p[which(p1$dat_p$treatment=="CR"),], 'FirstLabel ~ SecondLabel', value.var = 'sigval', fun.aggregate = sum,
             fill=0, drop=F)
   rname = pmat$FirstLabel
   pmat<-as.data.table(pmat)
   pmat = pmat[,which(colnames(pmat)!="FirstLabel"),with=FALSE] %>%
    as.data.frame()
row.names(pmat) <- rname
  cr.int<-100*pmat/(rowSums(abs(pmat)))
    pmat<-pmat[which(rowSums(abs(pmat))!=0),]

  ##absolute proportion
   rowSums(abs(cr.int))
   

   #total interactions across all.
   total.cr.int<- rowMeans(cr.int)

   
  #pmat.cr<-pmat[which( rowSums(abs(pmat))>0 ),]
  pmat.cr<-cr.int
   rownames(pmat.cr)<-paste0(rownames(pmat.cr),"_First")
  pmat.cr$response<-"CR"
    cr.int$response<-"CR"

  
   pmat = dcast(p1$dat_p[which(p1$dat_p$treatment=="Primary refract"),], 'FirstLabel ~ SecondLabel', value.var = 'sigval', fun.aggregate = sum,
             fill=0, drop=F)
   rname = pmat$FirstLabel
   pmat<-as.data.table(pmat)
   pmat = pmat[,which(colnames(pmat)!="FirstLabel"),with=FALSE] %>%
    as.data.frame()
row.names(pmat) <- rname
  pmat<-pmat[which(rowSums(abs(pmat))!=0),]

  ref.int<-100*pmat/(rowSums(abs(pmat)))
    ##absolute proportion
     rowSums(abs(ref.int))
     
   #total interactions across all.
    total.ref.int<-rowMeans(ref.int)
     

  pmat.ref<-pmat[which( rowSums(abs(pmat))>0 ),]
  rownames(pmat.ref)<-paste0(rownames(pmat.ref),"_First")
  pmat.ref$response<-"REF"
  ref.int$response<-"REF"

  ## all the first labels in CR, and REF thta have non-zero interaction scores.
#  spats<-rbind(pmat.cr,pmat.ref)
  spats<-rbind(cr.int,ref.int)

  #spats$direction<-rownames(spats)
  #spats.melt<-melt(spats)
  # using scaled intensity in both similar distribution.
  #ggplot(spats.melt,aes(response,value))+geom_boxplot()
 for(i in 1:ncol(spats)){
   spats[which(is.nan(spats[,i])),i]<-0
   
 }
  
  ump.spat<-umap::umap(spats[,1:43])

  ump.res<-data.frame(ump.spat$layout)
  ump.res$response<-spats$response
  ump.res$direction<-sapply(strsplit(rownames(ump.res),"_"),function(x) paste0(x[1],"_",x[2]))
  
  ump.res$direction<-full.dn4$subcluster_annotated[match(ump.res$direction,full.dn4$unsup.subcommunity)]  
  
  ggplot(ump.res,aes(x=X1,y=X2,color=response))+geom_point(size=3)+scale_color_manual(values=c("firebrick2","darkslateblue"))+theme_ipsum()+xlab("")+ylab("")

    names(phenoColors)<-full.dn4$subcluster_annotated[match(names(phenoColors),full.dn4$unsup.subcommunity)]


 
 #vol<- ggplot(res,aes(x=logFC,y=log10p,fill=new_cluster,label=marker_id))
 #vol+  geom_point(size = 4,alpha=1, shape=21,colour='black') + 
  # scale_fill_manual(values=akilColor[targs])+
   #   theme_ipsum()+
    #  geom_label_repel(
     #   alpha=0.75,
    # aes(label=factor(marker_id)),
    # fontface = 'bold', color = 'black',
    #box.padding = unit(0.45, "lines"),
    #point.padding = unit(0.15, "lines"),
    #segment.color = 'grey50',
    #show.legend=FALSE)+geom_hline(yintercept=1.30103,linetype='dashed',color='blue')

 


 #p<- ggplot(ump.res,aes(x=X1,y=X2,fill=direction,label=direction))
 #library(ggrepel)
  #p<- p+geom_point(size = 4,alpha=1, shape=21,colour='black') +
   # scale_fill_manual(values=phenoColors)+
    #theme_ipsum()
       
 #p+geom_label_repel(
  #      alpha=0.75,
  #   aes(label=factor(direction)),
  #   fontface = 'bold', color = 'black',
  #  box.padding = unit(0.45, "lines"),
  #  point.padding = unit(0.15, "lines"),
  #  segment.color = 'grey50',
  #  show.legend=FALSE)
   



  
  #######
  ## use the total interactions of a phenotype
   tumorEnv<-data.frame(REF=total.ref.int,CR=total.cr.int)
 colnames(tumorEnv)<-c("REF","CR")
  tumorEnv$phenotype<-full.dn4$subcluster_annotated[match(rownames(tumorEnv),full.dn4$unsup.subcommunity)]
  filterID<-tumorEnv$phenotype[which(tumorEnv$REF<=0 & tumorEnv$CR<=0)]
  
  tumorEnv$diff<-tumorEnv$REF-tumorEnv$CR
  N<-nrow(tumorEnv)
  ##pooled SD
  tumorEnv$pooledSD<-sqrt( ((N-1)*var(tumorEnv$CR)+(N-1)*var(tumorEnv$REF))/(N+N-2))
  ##pooled standard error of the mean.
  tumorEnv$pooledError<-unique(tumorEnv$pooledSD)*sqrt(1/N+1/N)

    tumorEnv$Z<-tumorEnv$diff/unique(tumorEnv$pooledSD)
  
  tl<-melt(tumorEnv[,c("REF","CR","phenotype")])  
    
 # tl<-melt(tumorEnv,variable.name=c("response"),id=c("phenotype","pooledSD","pooledError","Z"))
  #tl$error<-unique(tumorEnv$pooledError)
  #tl$response<-as.character(tl$response)
  tl$response<-as.character(tl$variable)
 tl$response[which(tl$response=="REF")]<-"Primary refractory"
  
   # tl$family<-sapply(strsplit(tl$phenotype,"_"),function(x) x[1])
 tl$error<-unique(tumorEnv$pooledError)
  tl$error[which(tl$value==0)]<-0
   
  targs<-c("Endothelial_4","Tumor_2","CD4_3","Tumor_5","CD4_1")
   
   tumorEnv.compare<- ggplot(tl[which(tl$phenotype%in%full.dn4$subcluster_annotated[match(targs,full.dn4$unsup.subcommunity)]),], aes(x = phenotype , y = value, fill=response)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    ggtitle("Average Relative Phenotypic Spatial Interaction Frequency") + ylab("Proportion Sig. Interaction(p<0.01)") + scale_fill_manual(values=getResponderColors()[1:2])+
    # add 90% CI errorbar 
    geom_errorbar(aes(ymin = value - 1.96*error, ymax = value + 1.96*error), width = 0.2, position=position_dodge(0.9))+theme_ipsum(base_family = "Arial")+
    theme(axis.text.x=element_text(colour="black",angle=90,vjust=0.5, hjust=1))
  
  tumorEnv.compare
  
 
   pmat = dcast(p1$dat_p, 'FirstLabel ~ SecondLabel', value.var = 'sigval', fun.aggregate = sum,
             fill=0, drop=F)
   rname = pmat$FirstLabel
   pmat<-as.data.table(pmat)
   pmat = pmat[,which(colnames(pmat)!="FirstLabel"),with=FALSE] %>%
    as.data.frame()
row.names(pmat) <- rname

   spat.data<-pmat[targs,]   
   spat.data<-spat.data[,which(colSums(abs(spat.data))>0)]
   rownames(spat.data)<-full.dn4$subcluster_annotated[match(rownames(spat.data),full.dn4$unsup.subcommunity)]
  colnames(spat.data)<-full.dn4$subcluster_annotated[match(colnames(spat.data),full.dn4$unsup.subcommunity)]

  ### interaction frequency needs to be added to the chart.
  tumor.int<-Heatmap(spat.data[,grepl("Tumor_",colnames(spat.data))],name="Tumor Interaction Score")
   tme.int<-Heatmap(spat.data[,!grepl("Tumor_",colnames(spat.data))],name="TME Interaction Score")
   spatial_col_fun<-colorRamp2(c(-3,0,3),c("skyblue1","grey96","red"))

  enrichment.spat.Z <- HeatmapAnnotation("REF"=anno_simple( tumorEnv[match(rownames(spat.data),tumorEnv$phenotype),"Z"],
                                            pch=ifelse( abs(tumorEnv[match(rownames(spat.data),tumorEnv$phenotype),"Z"])>2, 3,NA),
                                            col=spatial_col_fun,
                                            border=TRUE,
                                            width=unit(2.9,'mm'),
                                            pt_size=unit(2,'mm'),
                                            gp=gpar(col='grey79')),
                                            which="row")
  
  
 draw(enrichment.spat.Z+tumor.int+tme.int)
 
 tumorEnv.compare
 
 
 datap<-p1$dat_p
 datap<-datap[!is.na(datap$treatment),]
  pmat = dcast(datap, 'FirstLabel ~ SecondLabel+treatment', value.var = 'sigval', fun.aggregate = sum,
             fill=0, drop=F)
  
  ump.spat<-umap(pmat[,-1])
  
  ump.res<-data.frame(ump.spat$layout)
  ggplot(ump.res,aes(X1,X2))+geom_point()
  
  
```

## Spatial Interaction Frequency
```{r}

 load("C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/p1_15_unsup.subcommunity.15distance.01.RData")
 p1$dat_p$treatment<-exper_info2$group_id[match(paste0("ROIID_",p1$dat_p$group),exper_info2$sample_id)]
 
  pmat = dcast(p1$dat_p, 'FirstLabel ~ SecondLabel', value.var = 'sigval', fun.aggregate = sum,
             fill=0, drop=F)
   rname = pmat$FirstLabel
   pmat<-as.data.table(pmat)
   pmat = pmat[,which(colnames(pmat)!="FirstLabel"),with=FALSE] %>%
    as.data.frame()
row.names(pmat) <- rname

  prop.int<-100*pmat/rowSums(abs(pmat))
   
  

  pmat.ref<-pmat[which( rowSums(abs(pmat))>0 ),]
  rownames(pmat.ref)<-paste0(rownames(pmat.ref),"_First")
  pmat.ref$response<-"REF"
  ref.int$response<-"REF"


```




### Spatial Analysis at the cluster level
- spatial analysis of 15 distance, with unsupervised cluster interactions and the tumor bulk population. p=0.01
- generates and saves the data at cluster level used for figure production.
- produces the interaction spatial data at the cluster level.  
- used this in the final analysis.
- 7-22: revision for using significance level of 0.01.
- includes interactions with endothelial clusters.
- revision 8-28: we do not pool the tumor clusters. The current spatial analysis includes pool all the tumor sub-clusters into a single broad family, here we revise the analysis to perform the interactions at the cluster level.
```{r, spatialCluster}
 #group tumor together.
 full.dn4$unsup.tumor<-as.character(full.dn4$unsup.subcommunity)
 full.dn4$unsup.tumor[grepl("Tumor",full.dn4$unsup.tumor)]<-"Tumor"
 
  table(full.dn4$unsup.tumor)

 ##perform's Vito's interaction/permutations.
 # can be slow.
  # REVISION 8-28: the analysis is at the cluster level for all phenotypes
  dat_cells<-data.frame(ImageNumber=full.dn4$ROIID,
	ObjectNumber=full.dn4$CellId,
	label=as.character(full.dn4$unsup.subcommunity),
	group=full.dn4$ROIID)
  dat_cells<-data.table(dat_cells)
  
    # REVISION 8-28: the analysis is at the cluster level for all phenotypes
  dat_relation_15<-createRelationTable(dn5=full.dn4,
	myPheno="unsup.subcommunity",
	minDistance=15)
  
 # save(dat_relation_15,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/dat_relation_15_unsup.tumor.15distance.p025.RData")
 save(dat_relation_15,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/dat_relation_15_unsup.subcommunity.15distance.p01.RData")

  
 load("C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/dat_relation_15_unsup.subcommunity.15distance.p01.RData")
 
  dat_cells$label%>%table
  
  
 ## REVISION: using the p=0.01 threshold.
  p1<-makePermutationNBHD(dat_cells=dat_cells,
	dat_relation=dat_relation_15,
	n_perm=1000,pthreshold=0.01)

  p1$dat_p$treatment<-exper_info2$group_id[match(paste0("ROIID_",p1$dat_p$group),exper_info2$sample_id)]
  
 # save(p1,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/p1_15_unsup.tumor.15distance.01.RData")
 
   save(p1,file="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/p1_15_unsup.subcommunity.15distance.01.RData")


```





### Abundance result figure (experimental)
- the IPI main effect identified Tumor, the NGCB, and REF as main effects did not identify significant abundance changes, the joint effects of NGCB+IPI identified activatied prol. TREG, and the joint effect of IPI+REF identified baseline CD4.
- This section examines how to depict the abundance results from the model. Explored showing density, log-CPM.  however the CPM data does not look good. 
- may be best not to show abundance results.
- a problem is that some of the ROIs have missing clusters, and has sparsity issues.
```{r}

  relab<-as.data.frame.matrix(table(full.dn4$ROIID,full.dn4$unsup.subcommunity))
  #relab<-100*relab/rowSums(relab)
  
  

  relab$area<-full.dn4%>%group_by(ROIID)%>%summarise(area=sum(Area))%>%data.frame%$%area
  
  for(j in unique(full.dn4$unsup.subcommunity)) {
    relab[,j]<-100000*relab[,j]/relab[,"area"]
  }
  
 relab$NGCB<-0
 relab$NGCB[match(exper_info2$sample_id,paste0("ROIID_",rownames(relab)))]<-(exper_info2$NGCB)
 relab$NGCB<-ifelse(relab$NGCB==1,"Non-GCB","GCB")
  relab$REF<-0
  relab$REF[match(exper_info2$sample_id,paste0("ROIID_",rownames(relab)))]<-(exper_info2$group_id)
 relab$REF<-ifelse(relab$REF==1,"Refractory","CR")

  relab$highIPI<-0
    relab$highIPI[match(exper_info2$sample_id,paste0("ROIID_",rownames(relab)))]<-(exper_info2$highIPI)
 relab$highIPI<-ifelse(relab$highIPI==1,"High IPI","Low IPI")
  relab$de[match(exper_info2$sample_id,paste0("ROIID_",rownames(relab)))]<-(exper_info2$doubleExpressor)
 relab$de<-ifelse(relab$de==1,"doublExpressor","Not Double expressor")

  long2 <- melt(relab, id.vars = c("highIPI"), variable.name ="density")
    long2 <- melt(relab, id.vars = c("de"), variable.name ="density")
   long2$de[which(is.na(long2$de))]<-"Not Double expressor"
  
   long2$value<-as.numeric(long2$value)
   
   
  a<-ggplot(long2[which(long2$density%in%c("Tumor_1","Tumor_8","CD4_3","CD4_6")),],aes(x=density,y=value,fill=highIPI))+geom_boxplot()+geom_jitter(color="grey")+theme_ipsum(base_family="Arial")+ylab("Density (1e+03 microns^2)")+xlab("Phenotype")+scale_fill_manual(values=c("lightpink","steelblue1"))

 b<-ggplot(long2[which(long2$density%in%c("CD4_6","CD4_3","CD4_7","Macrophage_3","Tumor_9","Tumor_4")),],aes(x=density,y=value,fill=de))+geom_boxplot()+geom_jitter(color="grey")+theme_ipsum(base_family="Arial")+ylab("Density (1e+03 microns^2)")+xlab("Phenotype")+scale_fill_manual(values=c("lightpink","steelblue1"))

 

diffcyt::topTable(res_IPI.LDH2,format_vals = TRUE,top_n=10,show_logFC =TRUE)

diffcyt::topTable(ngcb_DA,format_vals = TRUE,top_n=10, show_logFC = TRUE)

topTable(ref_DA,format_vals = TRUE,top_n=10,show_logFC = TRUE)




 as<-  plotMedianExpressionBoxplot(d_medians=ngcb_DS$d_medians,cluster="Hi_Supp_TREG",marker="Lag3",clinicalFactor="highIPI")

 bs<-  plotMedianExpressionBoxplot(d_medians=ngcb_DS$d_medians,cluster="Exh_Inflam_CD8",marker="Lag3",clinicalFactor="highIPI")

 plotAbundanceCPMDiffCyt(d_counts=ngcb_DA$d_counts,cluster="Tumor_1",clinicalFactor = "highIPI")

 
 
 
counts<-assays(ngcb_DA$d_counts)[["counts"]]
  cluster_id <- rowData(ngcb_DA$d_counts)$cluster_id
    tf <- counts >= 50
    ix_keep <- apply(tf, 1, function(r) sum(r) >=4)
    counts <- counts[ix_keep, , drop = FALSE]
    cluster_id <- cluster_id[ix_keep]
    
   norm.factors<-edgeR::calcNormFactors(counts,method="TMM")
    y <- edgeR::DGEList(counts,norm.factors = norm.factors)
  
  ###generate CPM counts of abundance  
  y <- edgeR::estimateDisp(y, design, trend.method = "none")
  logCPM<-asinh(edgeR::cpm(y))
  logCPM<-as.data.frame(t(logCPM))
  logCPM$highIPI<-factor(exper_info2$highIPI[match(rownames(logCPM),exper_info2$sample_id)])
  
   long2 <- melt(logCPM, id.vars = c("highIPI"), variable.name ="density")
   long2$value<-as.numeric(long2$value)
  a<-ggplot(long2[which(long2$density%in%c("Tumor_1","Tumor_8","CD4_3","CD4_6")),],aes(x=density,y=value,fill=highIPI))+geom_boxplot()+geom_jitter(color="grey")+theme_ipsum(base_family="Arial")+ylab("Log-CPM")+xlab("Phenotype")+scale_fill_manual(values=c("lightpink","steelblue1"))

 
  
  
  #  logCPM$REF<-factor(exper_info2$group_id[match(rownames(logCPM),exper_info2$sample_id)])
  #logCPM$NGCB<-factor(exper_info2$NGCB[match(rownames(logCPM),exper_info2$sample_id)])
  #logCPM$C1<-factor(exper_info2$C1[match(rownames(logCPM),exper_info2$sample_id)])
  #logCPM$C2<-factor(exper_info2$C2[match(rownames(logCPM),exper_info2$sample_id)])
  #logCPM$C3<-factor(exper_info2$C3[match(rownames(logCPM),exper_info2$sample_id)])
  #logCPM$C4<-factor(exper_info2$C4[match(rownames(logCPM),exper_info2$sample_id)])
  #logCPM$C5<-factor(exper_info2$C5[match(rownames(logCPM),exper_info2$sample_id)])
  #logCPM$doubleExpressor<-factor(exper_info2$doubleExpressor[match(rownames(logCPM),exper_info2$sample_id)]) 
 
 
```



### Cartoons
- path to windows
- load the interactions with bulk tumor and unsupervised cluster 0.01 level
- clark evans analysis of the immune cells via REF/CR
```{r}

load("C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/p1_15_unsup.tumor.15distance.01.RData")


# load("C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/blood-revisions-5-1-21/spatial-analysis/p1_15_topology.tumor.5nn.unsup.tme.15distance.01.RData")


 plotShape<-function(path="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/simpleModel-1-14/DLBCL-shape-objects-revised/final-shapes/",ROI="3964",cols=NULL,full.dn4=NULL,compartment=NULL,phenotype=NULL,phenotype.column.toShape=NULL){
 # compartment is the phenotype column (subType.correction)
 ##phenotype is the cell type to customize.
 ## phenotype.column  is the spatial class.
 
   sh<-dir(path)
  n<-sh[grepl(ROI,sh)]
  load(paste0(path,n))
  spdf$cellType2<-sapply(strsplit(as.character(spdf$cellType),"_"),function(x) x[1])
  mycase<-full.dn4[which(full.dn4$ROIID==ROI),]
  tumor.id<-mycase$uniqueLabel[which(mycase[,compartment]==phenotype) ]
  spdf$uniqueLabel<-spdf$id
  spdf<-left_join(spdf,mycase[,c("uniqueLabel",phenotype.column.toShape)],by="uniqueLabel")
   spdf$cellType3<-factor(spdf[,phenotype.column.toShape],levels=unique(spdf[,phenotype.column.toShape]))
 test<- ggplot(spdf,aes(x=long,y=lat,group=id,fill=cellType3)) +
      geom_polygon( colour="black") +scale_fill_manual(values=cols[match(levels(spdf$cellType3),cols$phenotype),"colors"])+ggtitle(ROI)+theme_bw()
 
  # print(test)
  return(test)
 }






   
  dat<- p1$dat_p[which(p1$dat_p$FirstLabel=="Tumor"& p1$dat_p$sig==TRUE| p1$dat_p$SecondLabel=="Tumor"& p1$dat_p$sig==TRUE),]
  dat<-dat[!is.na(dat$treatment),]
  #dat<-dat[which(dat$FirstLabel=="Tumor"& dat$SecondLabel!="Tumor" | dat$FirstLabel!="Tumor"& dat$SecondLabel=="Tumor"),]
  
   dat$tme<-"Tumor"
  dat$tme[which(dat$FirstLabel!="Tumor")]<-as.character(dat$FirstLabel[which(dat$FirstLabel!="Tumor")])
    dat$tme[which(dat$SecondLabel!="Tumor")]<-as.character(dat$SecondLabel[which(dat$SecondLabel!="Tumor")])


  dat2<-dat%>%group_by(treatment,tme)%>%summarise(sigval=sum(sigval))%>%data.frame

 dd<-reshape(dat2, idvar = "treatment", timevar = "tme", direction = "wide")
 dd[2,is.na(dd[2,])]<-0
  rownames(dd)<-dd$treatment
  dd<-dd[,-1]
 dd<-dd[,which(colSums(dd)>0)]
 
 
 dd[,c(12,4,19)]%>% chisq.test(dd)

###set up the color codeing
    cols<-getSpatialPhenoColors(full.dn4=full.dn4)
    spatialColors<-data.frame(phenotype=names(phenoColors),colors=phenoColors)
    spatialColors$colors[grepl("Tumor",spatialColors$phenotype)]<-"gray82"
    spatialColors$phenotype[grepl("Tumor",spatialColors$phenotype)]<-"Tumor"
    spatialColors["CD8_3","colors"]<-"yellow"
        spatialColors["Macrophage_5","colors"]<-"#37E537"

  ##focus on CD8_3, and MAC_2  
 dat[which(dat$FirstLabel=="Tumor" & dat$SecondLabel%in%c("CD8_3","CD8_1","CD8_2","CD8_4","CD8_5","CD8_6") | dat$SecondLabel=="Tumor" & dat$FirstLabel%in%c("CD8_3","CD8_1","CD8_2","CD8_4","CD8_5","CD8_6")),]

    
     c4192<-plotShape(path="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/simpleModel-1-14/DLBCL-shape-objects-revised/final-shapes/",
	ROI="3965",
	cols=spatialColors,
	full.dn4=full.dn4,
	compartment="unsup.tumor",
	phenotype="Tumor",
	phenotype.column.toShape="unsup.tumor")
     
  print(c4192)
  
  
   c4192<-plotShape(path="C:/Users/UOSC/Documents/IMC-Ranalysis/DLBCL/simpleModel-1-14/DLBCL-shape-objects-revised/final-shapes/",
	ROI="4055",
	cols=spatialColors,
	full.dn4=full.dn4,
	compartment="unsup.tumor",
	phenotype="Tumor",
	phenotype.column.toShape="unsup.tumor")
     
  print(c4192)


  #### spatial clustering of CD8_3 and MAC_2
  
  HH3<-NULL
   rois<-full.dn4$ROIID[which(full.dn4$treatment.status!="ND")]%>%unique()
  for(i in rois){
  print(i)
  data<-subset(full.dn4,full.dn4$ROIID==i)
     pp<-phenographToPPP(case=data,marksCase=factor(data$annotated.label.simple_akil),shift=FALSE)
   H<-hyperframe(point=pp,
	response=unique(data$response),
	ROI=i)
   if(is.null(HH3)!=TRUE){
  HH3<-rbind(H,HH3)
  }else{
 HH3<-H
  } 
 } ###

 table(full.dn4$annotated.label.simple_akil,full.dn4$unsup.tumor)
 
 
  dat[which(dat$FirstLabel=="Tumor" & dat$SecondLabel%in%c("CD8_3","CD8_5","Macrophage_2") | dat$SecondLabel=="Tumor" & dat$FirstLabel%in%c("CD8_3","CD8_5","Macrophage_2")),]

 
  man3<-with(HH3, point[which(marks(point)%in%unique(c(
	'Term_Exh_CD8',
	"PDL1M2MAC")))])
  names(man3)<-HH3$ROI
  
   id<-which(sapply(man3,npoints)!=0)
  man3<-hyperframe(point=man3[id],ROI=names(man3)[id])
  man3$response<-HH3$response[match(man3$ROI,HH3$ROI)]
 ## border corrections on Clark-Evans statistic.
  man3$z<-with(man3,clarkevans.test(point,alternative='clustered',correction='Donnelly')$statistic)

  lm(z~response, man3[which(man3$response!="LTF"),])%>%summary()
  
  ggplot(man3[which(man3$response!="LTF"),],aes(x=response,y=z))%>%geom_boxplot()
  
 ## perform regression.
  cedata<-data.frame(response=man3$response,z=man3$z,row.names=man3$ROI)
    ggplot(cedata[which(cedata$response!="LTF"),],aes(x=response,y=z,fill=response))+geom_boxplot()+theme_ipsum(base_family="Arial")+scale_fill_manual(values=c("darkslateblue","firebrick2"))+ylab("Clark-Evans Spatial Irregularity Index")+stat_compare_means()

  
  cedata$case<-full.dn4.5nn2$case[match(rownames(cedata),full.dn4.5nn2$ROIID)]
  cedata$case<-factor(cedata$case)
  ### mixed effects model. 
  ##droppin tumor_d, much improved.
  print(paste0("dropping domain d"))
  print( lm(z~COO,cedata)%>%summary)
    fit<-lm(z~COO,cedata)%>%summary


 ## RLN clark evans.
   rlnZ<-data.frame(COO="RLN",z=rln$z,case=rln$ROI)


  ce.d<-rbind(cedata,rlnZ)
  ce.d$COO<-relevel(ce.d$COO,ref='RLN')

  

```



